{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:17.276218+00:00", "interaction_id": "898ce970-fec5-4b56-8b0e-030843f64422"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三目前的工作单位是哪家公司？\",\n  \"张三最近的工作地点是哪里？\",\n  \"张三过去的工作经历有哪些？\"\n]", "processed_llm_output": "[\n  \"张三目前的工作单位是哪家公司？\",\n  \"张三最近的工作地点是哪里？\",\n  \"张三过去的工作经历有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:18.130911+00:00", "interaction_id": "693abda0-07a9-415a-8104-f3e7127dba4e"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:21.611107+00:00", "interaction_id": "e15f5c41-3ed0-4df7-b14e-c669dad5330a"}
{"task_type": "cypher_generation", "user_query": "张三目前的工作单位是哪家公司？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三目前的工作单位是哪家公司？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:24.127180+00:00", "interaction_id": "bd095df1-85b1-4d9e-b48d-4a1c62a57cc3"}
{"task_type": "cypher_generation", "user_query": "张三最近的工作地点是哪里？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三最近的工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:26.265805+00:00", "interaction_id": "ee4ce7ef-9401-428c-9d35-a8245d0ef5b1"}
{"task_type": "cypher_generation", "user_query": "张三过去的工作经历有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三过去的工作经历有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName, p.text AS personName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName, p.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:28.525575+00:00", "interaction_id": "5329687d-d7da-48dc-99fb-449554f2c20f"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:30.662848+00:00", "interaction_id": "fa05fb52-f404-4c53-8c75-810a5e98cf35"}
{"task_type": "answer_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:32.259759+00:00", "interaction_id": "e868266e-f08a-4565-b4d4-8a435106291d"}
{"timestamp_utc": "2025-05-31T07:38:32.261488+00:00", "interaction_id": "61015caa-dd7f-44c1-bc0a-43d332678bc3", "task_type": "rag_query_processing_success", "user_query": "张三在哪里工作？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": 6.6953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 6.6953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三目前的工作单位是哪家公司？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:32.656405+00:00", "interaction_id": "430d16fc-3101-4086-8263-cd7cca5918d5"}
{"task_type": "query_expansion", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"谁被分配了项目Alpha的文档编写任务？\",\n  \"项目Alpha的文档编写任务截止日期是什么时候？\",\n  \"项目Alpha的文档编写任务主要涉及哪些具体内容？\"\n]", "processed_llm_output": "[\n  \"谁被分配了项目Alpha的文档编写任务？\",\n  \"项目Alpha的文档编写任务截止日期是什么时候？\",\n  \"项目Alpha的文档编写任务主要涉及哪些具体内容？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:33.676306+00:00", "interaction_id": "48a2813a-dc70-498c-9e3b-34f1173cd80b"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:35.834726+00:00", "interaction_id": "2c490ada-8467-4035-a06b-c0fd7c3225e9"}
{"task_type": "cypher_generation", "user_query": "谁被分配了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谁被分配了项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (d:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {label: 'PERSON'}) RETURN p.text AS personName", "processed_llm_output": "MATCH (d:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {label: 'PERSON'}) RETURN p.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:38.027779+00:00", "interaction_id": "371e8882-7333-4f30-8421-871f7fd8079f"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务截止日期是什么时候？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务截止日期是什么时候？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:HAS_DEADLINE]->(deadline:ExtractedEntity) RETURN deadline.text AS deadlineDate", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:HAS_DEADLINE]->(deadline:ExtractedEntity) RETURN deadline.text AS deadlineDate", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:40.117255+00:00", "interaction_id": "1b181be7-ce72-46b2-af3b-cde7ffdc5af8"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务主要涉及哪些具体内容？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务主要涉及哪些具体内容？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:41.407033+00:00", "interaction_id": "0eb67688-5355-4dbf-bcf8-cb6979e7e316"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:44.479898+00:00", "interaction_id": "d23bf5b0-801c-44ff-8a01-a6c0ead62292"}
{"task_type": "answer_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:46.056794+00:00", "interaction_id": "c18b5318-c23f-4b6a-b5c9-74ee9db4aa13"}
{"timestamp_utc": "2025-05-31T07:38:46.058334+00:00", "interaction_id": "0e727940-d15e-4d4b-80de-56fc08c39e32", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的文档编写任务分配给了谁？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "5af962307c33de17029190bba9ffd195", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": 9.2578125, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}, {"source": "keyword_bm25s", "score": -10.1953125, "id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "content_preview": "第二个文档讨论了自然语言处理技术。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 9.2578125, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}, {"source_type": "keyword_bm25s", "content": "第二个文档讨论了自然语言处理技术。", "score": -10.1953125, "metadata": {"chunk_id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}], "final_context_docs_count": 2, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:46.444539+00:00", "interaction_id": "d215b79a-4206-4779-b783-77154be5d91d"}
{"task_type": "query_expansion", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四目前负责的所有任务清单是什么？\",\n  \"李四在过去一年中主要负责哪些任务？\",\n  \"李四接下来的任务安排有哪些？\"\n]", "processed_llm_output": "[\n  \"李四目前负责的所有任务清单是什么？\",\n  \"李四在过去一年中主要负责哪些任务？\",\n  \"李四接下来的任务安排有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:47.293704+00:00", "interaction_id": "469bb476-df2e-47a4-a11f-2e119aecc757"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:49.402863+00:00", "interaction_id": "3353991a-640e-4bb6-80ca-62015cf689bd"}
{"task_type": "cypher_generation", "user_query": "李四目前负责的所有任务清单是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四目前负责的所有任务清单是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(tasks:ExtractedEntity {label: 'TASK'}) RETURN tasks.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(tasks:ExtractedEntity {label: 'TASK'}) RETURN tasks.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:51.535524+00:00", "interaction_id": "41adc52b-7d1d-47ba-bf41-2cbaffe80981"}
{"task_type": "cypher_generation", "user_query": "李四在过去一年中主要负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在过去一年中主要负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) WHERE task.period CONTAINS '过去一年' RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) WHERE task.period CONTAINS '过去一年' RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:53.839962+00:00", "interaction_id": "dac519f3-91e7-408b-9532-4d715dba60b0"}
{"task_type": "cypher_generation", "user_query": "李四接下来的任务安排有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四接下来的任务安排有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(nextTask:ExtractedEntity {label: 'TASK'}) RETURN nextTask.text AS nextTaskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(nextTask:ExtractedEntity {label: 'TASK'}) RETURN nextTask.text AS nextTaskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:56.029027+00:00", "interaction_id": "809fadc2-ba3d-4aa9-b402-7824d2127709"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:58.151057+00:00", "interaction_id": "3d7b130c-9e8b-4a15-8a0f-193e57c77e93"}
{"task_type": "intent_classification", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:58.545445+00:00", "interaction_id": "80ba4f7d-24c9-46f7-a933-3177bf9bd7c6"}
{"task_type": "query_expansion", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"市场部的具体员工名单是什么？\",\n  \"市场部员工的年龄分布情况如何？\",\n  \"市场部员工的平均薪资是多少？\"\n]", "processed_llm_output": "[\n  \"市场部的具体员工名单是什么？\",\n  \"市场部员工的年龄分布情况如何？\",\n  \"市场部员工的平均薪资是多少？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:38:59.346678+00:00", "interaction_id": "c624961e-f634-4e1b-9cb4-ca4b6457a2e3"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:01.521790+00:00", "interaction_id": "379fda76-afdf-4ff6-8d4a-98565ff1319c"}
{"task_type": "cypher_generation", "user_query": "市场部的具体员工名单是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部的具体员工名单是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:03.692348+00:00", "interaction_id": "2813c3eb-5c76-4b70-93e2-e1c5d1231a60"}
{"task_type": "cypher_generation", "user_query": "市场部员工的年龄分布情况如何？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的年龄分布情况如何？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:04.970062+00:00", "interaction_id": "4be3541f-8449-46a7-b2e7-3175243c9f4e"}
{"task_type": "cypher_generation", "user_query": "市场部员工的平均薪资是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的平均薪资是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:07.159752+00:00", "interaction_id": "041933be-e137-4bca-b66f-9f049d164914"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:10.173523+00:00", "interaction_id": "93d7a204-d5e0-4eee-99b9-a9a4838c3029"}
{"task_type": "intent_classification", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有类型为TASK的实体。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:11.158357+00:00", "interaction_id": "8fe707bb-9ad3-4aeb-8345-a82a9844e5cd"}
{"task_type": "clarification_question_generation", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有类型为TASK的实体。\n不确定性原因: 缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "列出所有类型为TASK的实体还是特定项目的TASK？", "processed_llm_output": "列出所有类型为TASK的实体还是特定项目的TASK？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:11.523957+00:00", "interaction_id": "d8441d04-bb4f-4a13-bbba-285c86c52b2f"}
{"task_type": "intent_classification", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查询所有在创新科技公司工作的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:12.337677+00:00", "interaction_id": "a2f44823-9abe-40d2-ba2a-aab4fadc9b7e"}
{"task_type": "clarification_question_generation", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查询所有在创新科技公司工作的员工。\n不确定性原因: 缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查询哪家创新科技公司的员工？是所有员工还是特定部门或职位的员工？", "processed_llm_output": "请问您想查询哪家创新科技公司的员工？是所有员工还是特定部门或职位的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:12.856121+00:00", "interaction_id": "aab3225d-8524-441f-9042-506ee4475d6a"}
{"task_type": "intent_classification", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查找所有人员的名称。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:13.776839+00:00", "interaction_id": "205400bf-67dd-4434-8744-f0d3df08ab6e"}
{"task_type": "clarification_question_generation", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查找所有人员的名称。\n不确定性原因: 缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查找哪个组织或数据库中的人员名称？以及这些人员是员工、客户还是合作伙伴？", "processed_llm_output": "请问您想查找哪个组织或数据库中的人员名称？以及这些人员是员工、客户还是合作伙伴？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:14.317388+00:00", "interaction_id": "307fa37d-64ab-4506-9dfb-4118f1ec02dc"}
{"task_type": "intent_classification", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 有多少个组织类型的实体？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的组织类型或上下文信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的组织类型或上下文信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:14.921477+00:00", "interaction_id": "0207ec55-ec61-456e-aee2-be356cace5bd"}
{"task_type": "clarification_question_generation", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 有多少个组织类型的实体？\n不确定性原因: 缺少具体的组织类型或上下文信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪些具体的组织类型？", "processed_llm_output": "请问您指的是哪些具体的组织类型？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:15.167197+00:00", "interaction_id": "bca5dcb2-bf81-4f52-a190-3c17908fd56b"}
{"task_type": "intent_classification", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:15.556032+00:00", "interaction_id": "1aa5e5cf-d82d-4ffe-802d-44b33f25f5a2"}
{"task_type": "query_expansion", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"王五是否在A公司工作？\",\n  \"王五是否负责项目B？\",\n  \"王五是否既在A公司工作，又负责了项目B？\"\n]", "processed_llm_output": "[\n  \"王五是否在A公司工作？\",\n  \"王五是否负责项目B？\",\n  \"王五是否既在A公司工作，又负责了项目B？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:16.487761+00:00", "interaction_id": "fcd270d4-887f-43f9-b1f6-4d68e6ef67bd"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:19.377077+00:00", "interaction_id": "47d0e9f6-8be7-46e0-a332-3cb985dbcfd7"}
{"task_type": "cypher_generation", "user_query": "王五是否在A公司工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否在A公司工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:21.828596+00:00", "interaction_id": "a3a83b08-e912-4141-affb-221f6e39b29b"}
{"task_type": "cypher_generation", "user_query": "王五是否负责项目B？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否负责项目B？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:24.128116+00:00", "interaction_id": "a26278a5-9f87-4f9c-9e86-a6430bc4821a"}
{"task_type": "cypher_generation", "user_query": "王五是否既在A公司工作，又负责了项目B？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否既在A公司工作，又负责了项目B？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nRETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nRETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:27.032392+00:00", "interaction_id": "d5ce5f4e-e290-4061-9fa8-0098a59d8192"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:30.014468+00:00", "interaction_id": "278be25a-67e7-4219-b621-0368234fcbec"}
{"task_type": "answer_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:31.543796+00:00", "interaction_id": "e04c0c5f-90e2-48e4-8882-722a2c8fd3bb"}
{"timestamp_utc": "2025-05-31T07:39:31.545897+00:00", "interaction_id": "680fd6a1-db26-4b9d-ae35-dfde63f26a45", "task_type": "rag_query_processing_success", "user_query": "王五既在A公司工作，又负责了项目B吗？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -6.48046875, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -6.48046875, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "王五既在A公司工作，又负责了项目B吗？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有被分配了任务的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:32.390985+00:00", "interaction_id": "58a55056-c962-444f-b657-6460c12986a9"}
{"task_type": "clarification_question_generation", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有被分配了任务的员工。\n不确定性原因: 缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请提供具体项目或团队名称，以及员工列表的范围（如所有部门或特定部门）。", "processed_llm_output": "请提供具体项目或团队名称，以及员工列表的范围（如所有部门或特定部门）。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:32.912685+00:00", "interaction_id": "d111bde1-a85c-4896-b800-13fdb5438096"}
{"task_type": "intent_classification", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:33.596199+00:00", "interaction_id": "0cc737fa-f9fa-4c00-861b-f395e844a45d"}
{"task_type": "clarification_question_generation", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n不确定性原因: 缺少具体的PERSON名称，以及任务分配的上下文信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "“市场调研报告”的任务具体分配给了谁？", "processed_llm_output": "“市场调研报告”的任务具体分配给了谁？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:33.901010+00:00", "interaction_id": "13b0f616-dc66-4d84-a1b7-c844c6414ebd"}
{"task_type": "intent_classification", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，以及需要明确哪些PERSON在‘战略规划部’工作。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，以及需要明确哪些PERSON在‘战略规划部’工作。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:34.768034+00:00", "interaction_id": "42c71c37-c9f9-4dc6-a2fd-a5e057ab5920"}
{"task_type": "clarification_question_generation", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n不确定性原因: 缺少具体的企业名称或组织架构信息，以及需要明确哪些PERSON在‘战略规划部’工作。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪家具体的企业或组织？", "processed_llm_output": "请问您指的是哪家具体的企业或组织？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:35.040872+00:00", "interaction_id": "bd25013c-442a-447a-8603-9bf25a1482f5"}
{"task_type": "intent_classification", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 告诉我关于张三和他的工作单位的信息。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:35.749352+00:00", "interaction_id": "0386d09e-920b-4ec3-acbb-54e1d03efe13"}
{"task_type": "clarification_question_generation", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 告诉我关于张三和他的工作单位的信息。\n不确定性原因: 缺少张三的工作单位信息，需要明确他是哪家公司的员工。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "张三的工作单位是哪家公司？", "processed_llm_output": "张三的工作单位是哪家公司？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:35.992076+00:00", "interaction_id": "57723808-220f-4bfc-afb9-9a4ac9249266"}
{"task_type": "intent_classification", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:36.611736+00:00", "interaction_id": "b9bc2a80-bdff-4b36-860a-4464973edefd"}
{"task_type": "clarification_question_generation", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n不确定性原因: 缺少具体的人名和项目Alpha的相关信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请提供具体的人名和项目Alpha的相关信息。", "processed_llm_output": "请提供具体的人名和项目Alpha的相关信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:36.917416+00:00", "interaction_id": "1c591a9f-fbd5-4ffc-821b-65c6452aada9"}
{"task_type": "intent_classification", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:37.309223+00:00", "interaction_id": "cf5469cf-6a62-463d-a31a-2185238db8e5"}
{"task_type": "query_expansion", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三现在的具体年龄是多少岁？\",\n  \"张三从出生到现在已经过了多少个生日？\",\n  \"张三的年龄在同一年龄段中处于什么范围？\"\n]", "processed_llm_output": "[\n  \"张三现在的具体年龄是多少岁？\",\n  \"张三从出生到现在已经过了多少个生日？\",\n  \"张三的年龄在同一年龄段中处于什么范围？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:38.304096+00:00", "interaction_id": "bfe4ef9a-ecc3-4d2b-adcf-9d21274df5f9"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:39.586719+00:00", "interaction_id": "ef39311e-74c6-421c-b4e9-4fc635694320"}
{"task_type": "cypher_generation", "user_query": "张三现在的具体年龄是多少岁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三现在的具体年龄是多少岁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:41.763924+00:00", "interaction_id": "eea213c4-94a4-4d79-9ed1-fe86194846ce"}
{"task_type": "cypher_generation", "user_query": "张三从出生到现在已经过了多少个生日？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三从出生到现在已经过了多少个生日？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:43.897816+00:00", "interaction_id": "47f6daa7-e075-45fe-9ce3-aa9f4a15a1d8"}
{"task_type": "cypher_generation", "user_query": "张三的年龄在同一年龄段中处于什么范围？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄在同一年龄段中处于什么范围？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:46.036609+00:00", "interaction_id": "c919da49-3b03-4890-87cb-39027d5e169b"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:48.119294+00:00", "interaction_id": "b14b1283-1e38-4a7c-a2b8-014d01335075"}
{"task_type": "answer_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:50.482846+00:00", "interaction_id": "5df71922-cb65-4976-966a-b925a3504a95"}
{"timestamp_utc": "2025-05-31T07:39:50.484838+00:00", "interaction_id": "038a80b4-563e-4a00-bb88-1cc4ec501c17", "task_type": "rag_query_processing_success", "user_query": "张三的年龄是多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三的年龄是多少？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:50.874870+00:00", "interaction_id": "460004f8-3ec7-4921-9717-fd5e6bafc875"}
{"task_type": "query_expansion", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的总预算是多少？\",\n  \"项目Alpha的预算分配明细是什么？\",\n  \"与项目Alpha相关的预算调整历史有哪些？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的总预算是多少？\",\n  \"项目Alpha的预算分配明细是什么？\",\n  \"与项目Alpha相关的预算调整历史有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:51.708014+00:00", "interaction_id": "f683e680-b93d-4699-8465-ce2bd3bcaae2"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:52.977917+00:00", "interaction_id": "43e26f9e-9162-4cff-838c-6323922d607b"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的总预算是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的总预算是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:55.088757+00:00", "interaction_id": "cf755b33-c3c1-476f-9e9e-aaeaf6576690"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算分配明细是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算分配明细是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:57.337186+00:00", "interaction_id": "14111804-2df4-4ad5-8d9b-0e34bb811543"}
{"task_type": "cypher_generation", "user_query": "与项目Alpha相关的预算调整历史有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 与项目Alpha相关的预算调整历史有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:39:59.467683+00:00", "interaction_id": "80239c1e-e022-4cd4-9e4c-2316a309d810"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:01.563160+00:00", "interaction_id": "c38b1c85-fbd0-4e58-b4af-32896e5cee63"}
{"task_type": "answer_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:03.884581+00:00", "interaction_id": "9389b944-09bf-4594-abe3-001e00208138"}
{"timestamp_utc": "2025-05-31T07:40:03.886390+00:00", "interaction_id": "6461d4af-1fd9-4e26-8dc7-f3285a1cca2c", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的预算有多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": -7.51171875, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -7.51171875, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的预算分配明细是什么？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:04.277585+00:00", "interaction_id": "f3412f65-11cf-4a68-ad93-60230f5d92e5"}
{"task_type": "query_expansion", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四和王五在同一家公司工作吗？\",\n  \"李四和王五的工作职位是否相同？\",\n  \"李四和王五是否有共同的上级领导？\"\n]", "processed_llm_output": "[\n  \"李四和王五在同一家公司工作吗？\",\n  \"李四和王五的工作职位是否相同？\",\n  \"李四和王五是否有共同的上级领导？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:05.272888+00:00", "interaction_id": "5563610d-9f65-4e38-880a-4542031a0e2d"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:06.557959+00:00", "interaction_id": "6c40e379-da12-4e4a-bc2f-f5ebc8716796"}
{"task_type": "cypher_generation", "user_query": "李四和王五在同一家公司工作吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五在同一家公司工作吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:08.761794+00:00", "interaction_id": "4bc68498-6eac-4de9-8312-129f5b7fb1a1"}
{"task_type": "cypher_generation", "user_query": "李四和王五的工作职位是否相同？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五的工作职位是否相同？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:10.801514+00:00", "interaction_id": "49384197-230a-43cf-8e92-70b2f59413e9"}
{"task_type": "cypher_generation", "user_query": "李四和王五是否有共同的上级领导？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是否有共同的上级领导？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:12.990403+00:00", "interaction_id": "8e535890-345b-4526-8539-a7cb25a0cbf9"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:15.094218+00:00", "interaction_id": "57d05043-95b8-4118-b35a-514caf6785db"}
{"task_type": "intent_classification", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:15.488163+00:00", "interaction_id": "2420f8d7-3c8a-4168-a5dc-deb4c2877ecc"}
{"task_type": "query_expansion", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"谷歌公司的创办人是谁？\",\n  \"谷歌公司的总部位于哪个城市？\",\n  \"谷歌公司成立初期的主要业务是什么？\"\n]", "processed_llm_output": "[\n  \"谷歌公司的创办人是谁？\",\n  \"谷歌公司的总部位于哪个城市？\",\n  \"谷歌公司成立初期的主要业务是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:16.228041+00:00", "interaction_id": "ed4fecda-056a-454b-8a29-8cabd0413b8e"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:17.511638+00:00", "interaction_id": "93162172-d114-4117-a47b-d2ab6df50618"}
{"task_type": "cypher_generation", "user_query": "谷歌公司的创办人是谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司的创办人是谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:19.610951+00:00", "interaction_id": "6ce296a2-03c9-4db5-874d-49baf5783685"}
{"task_type": "cypher_generation", "user_query": "谷歌公司的总部位于哪个城市？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司的总部位于哪个城市？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:21.782848+00:00", "interaction_id": "ca92d7cf-e577-4e6d-97a9-a2a2608f8f6b"}
{"task_type": "cypher_generation", "user_query": "谷歌公司成立初期的主要业务是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司成立初期的主要业务是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:23.906084+00:00", "interaction_id": "b23e3b11-7659-4153-8ef0-60df0c464469"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:26.022481+00:00", "interaction_id": "3b31953f-f7fa-4582-9202-d22d1719078f"}
{"task_type": "answer_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T07:40:28.346351+00:00", "interaction_id": "6e8a3f76-e166-48d6-8a21-43f8511beccf"}
{"timestamp_utc": "2025-05-31T07:40:28.348233+00:00", "interaction_id": "eece30eb-7099-4367-b930-ed69ca27ccb4", "task_type": "rag_query_processing_success", "user_query": "谷歌公司是什么时候成立的？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "谷歌公司的创办人是谁？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:23.087146+00:00", "interaction_id": "665c0c75-bbba-4665-a8fd-9bf4e17623ea"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三目前的工作地点是哪里？\",\n  \"张三最近一次的工作变动是何时？\",\n  \"张三所在公司的主要业务范围是什么？\"\n]", "processed_llm_output": "[\n  \"张三目前的工作地点是哪里？\",\n  \"张三最近一次的工作变动是何时？\",\n  \"张三所在公司的主要业务范围是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:23.931583+00:00", "interaction_id": "4df1bdab-217f-4840-a276-69cbac1b09d9"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:26.084091+00:00", "interaction_id": "77e788c7-dd96-4501-b1d3-bb78aa0b87c0"}
{"task_type": "cypher_generation", "user_query": "张三目前的工作地点是哪里？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三目前的工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:28.223909+00:00", "interaction_id": "934894f5-2f43-49dc-ace5-1110dfc97c89"}
{"task_type": "cypher_generation", "user_query": "张三最近一次的工作变动是何时？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三最近一次的工作变动是何时？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:29.550861+00:00", "interaction_id": "460d8e61-b647-48aa-b75b-660a744d126e"}
{"task_type": "cypher_generation", "user_query": "张三所在公司的主要业务范围是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三所在公司的主要业务范围是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:31.749483+00:00", "interaction_id": "2a879c40-bd8a-4e75-8d69-774625d41f3e"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:34.708229+00:00", "interaction_id": "20301335-be93-48a4-8c39-284ebaff4d49"}
{"task_type": "answer_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:36.221562+00:00", "interaction_id": "3b3bd7fc-7a76-4472-8ccb-77aad53d3f3c"}
{"timestamp_utc": "2025-05-31T08:59:36.223219+00:00", "interaction_id": "7a3f41ae-928e-4995-be0d-ff15c82ffe0e", "task_type": "rag_query_processing_success", "user_query": "张三在哪里工作？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": 6.6953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 6.6953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三目前的工作地点是哪里？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:36.623918+00:00", "interaction_id": "68a02749-9b61-45e7-abd4-2ffaee7b4dba"}
{"task_type": "query_expansion", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的文档编写任务具体分配给谁了？\",\n  \"谁负责项目Alpha的文档编写工作？\",\n  \"项目Alpha文档编写任务的负责人是谁？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的文档编写任务具体分配给谁了？\",\n  \"谁负责项目Alpha的文档编写工作？\",\n  \"项目Alpha文档编写任务的负责人是谁？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:37.578880+00:00", "interaction_id": "f0d8436c-3db7-4474-83e5-e7298eeb30a0"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:39.774921+00:00", "interaction_id": "a4d38215-fb7a-4f08-86ca-5f24d4efc148"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务具体分配给谁了？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务具体分配给谁了？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:41.957129+00:00", "interaction_id": "0deb93e4-ca54-4d03-adae-e18eacc83179"}
{"task_type": "cypher_generation", "user_query": "谁负责项目Alpha的文档编写工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谁负责项目Alpha的文档编写工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:44.149513+00:00", "interaction_id": "6ccfb9bb-004d-4649-92bd-738301ba1c15"}
{"task_type": "cypher_generation", "user_query": "项目Alpha文档编写任务的负责人是谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha文档编写任务的负责人是谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:46.348320+00:00", "interaction_id": "fe6efc80-c9c4-4f0c-94b1-e5babd2f5d53"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:48.528127+00:00", "interaction_id": "a381344e-7e3a-4bbc-9fc8-27712f0cb54c"}
{"task_type": "answer_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:50.046970+00:00", "interaction_id": "3eb65baa-4b46-43c7-94c2-b44955e39a6a"}
{"timestamp_utc": "2025-05-31T08:59:50.048628+00:00", "interaction_id": "72dba0e1-4b77-462b-99d2-afa48c396dd9", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的文档编写任务分配给了谁？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "5af962307c33de17029190bba9ffd195", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": 9.2578125, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}, {"source": "keyword_bm25s", "score": -10.1953125, "id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "content_preview": "第二个文档讨论了自然语言处理技术。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 9.2578125, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}, {"source_type": "keyword_bm25s", "content": "第二个文档讨论了自然语言处理技术。", "score": -10.1953125, "metadata": {"chunk_id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}], "final_context_docs_count": 2, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:50.453451+00:00", "interaction_id": "851c2200-93d5-4ba8-87d6-1f5e766f2875"}
{"task_type": "query_expansion", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四目前负责的具体任务有哪些？\",\n  \"李四在过去的一年中承担了哪些主要任务？\",\n  \"李四在未来的工作计划中负责哪些任务？\"\n]", "processed_llm_output": "[\n  \"李四目前负责的具体任务有哪些？\",\n  \"李四在过去的一年中承担了哪些主要任务？\",\n  \"李四在未来的工作计划中负责哪些任务？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:51.407353+00:00", "interaction_id": "1b1e74b0-a127-4d14-a129-de9c5f097110"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:53.522010+00:00", "interaction_id": "5218591f-61a2-41af-8d21-2e3b9b06c598"}
{"task_type": "cypher_generation", "user_query": "李四目前负责的具体任务有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四目前负责的具体任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:55.651282+00:00", "interaction_id": "29716e00-067c-40d6-9e8c-89a153eacb9a"}
{"task_type": "cypher_generation", "user_query": "李四在过去的一年中承担了哪些主要任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在过去的一年中承担了哪些主要任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(t:Task) WHERE t.period CONTAINS '过去的一年' RETURN t.text AS taskName", "processed_llm_output": "MATCH (l:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(t:Task) WHERE t.period CONTAINS '过去的一年' RETURN t.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:57.770889+00:00", "interaction_id": "9685a994-af85-440d-a5ef-2cf7f3172c3d"}
{"task_type": "cypher_generation", "user_query": "李四在未来的工作计划中负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在未来的工作计划中负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T08:59:59.909666+00:00", "interaction_id": "c8016117-0695-4c06-8624-50cc9df8a823"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:02.065352+00:00", "interaction_id": "54525f07-aa85-4148-96e5-c515238e964e"}
{"task_type": "intent_classification", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:02.470423+00:00", "interaction_id": "4087a71d-9464-4750-a313-c2af6eaea236"}
{"task_type": "query_expansion", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"市场部具体负责哪些工作？\",\n  \"市场部员工的年龄分布如何？\",\n  \"市场部员工的平均工作经验是多少？\"\n]", "processed_llm_output": "[\n  \"市场部具体负责哪些工作？\",\n  \"市场部员工的年龄分布如何？\",\n  \"市场部员工的平均工作经验是多少？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:03.269512+00:00", "interaction_id": "8ab931db-e02a-4d30-a354-ad12812ebacd"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:05.457615+00:00", "interaction_id": "bd58e6a8-a183-466b-90bf-85d44b94f21d"}
{"task_type": "cypher_generation", "user_query": "市场部具体负责哪些工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部具体负责哪些工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:06.753554+00:00", "interaction_id": "aa99a0c5-da04-4a5e-ba0f-1dbb3ff2855c"}
{"task_type": "cypher_generation", "user_query": "市场部员工的年龄分布如何？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的年龄分布如何？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:08.948744+00:00", "interaction_id": "50e8ab96-99a8-475f-aa61-dcf2b46fdd5e"}
{"task_type": "cypher_generation", "user_query": "市场部员工的平均工作经验是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的平均工作经验是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:10.979834+00:00", "interaction_id": "33b28c4a-1ef5-4fb4-bffd-d5ba0fcf7b7d"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:14.048467+00:00", "interaction_id": "31183d55-4ba5-45dc-b6fa-c68366a19a1f"}
{"task_type": "intent_classification", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有类型为TASK的实体。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体）\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体）\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:15.082978+00:00", "interaction_id": "dd2436d8-7cc6-46a5-b8d2-582ec48c2a45"}
{"task_type": "clarification_question_generation", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有类型为TASK的实体。\n不确定性原因: 缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体）\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请指定列出TASK实体的具体范围，例如数据库名或文件名。", "processed_llm_output": "请指定列出TASK实体的具体范围，例如数据库名或文件名。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:15.480217+00:00", "interaction_id": "d7dec075-1d94-4739-955e-9cf5d6c79254"}
{"task_type": "intent_classification", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查询所有在创新科技公司工作的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:16.335100+00:00", "interaction_id": "b61a2e9b-51d3-4738-8b66-9024f33d4b08"}
{"task_type": "clarification_question_generation", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查询所有在创新科技公司工作的员工。\n不确定性原因: 缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查询哪家创新科技公司的员工？以及是想查询所有员工还是特定部门或职位的员工？", "processed_llm_output": "请问您想查询哪家创新科技公司的员工？以及是想查询所有员工还是特定部门或职位的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:16.936214+00:00", "interaction_id": "55d5eac6-b813-4d43-bd78-5ce91731d622"}
{"task_type": "intent_classification", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查找所有人员的名称。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:17.874020+00:00", "interaction_id": "492fb946-ef6d-435d-8a41-36b3a92a8087"}
{"task_type": "clarification_question_generation", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查找所有人员的名称。\n不确定性原因: 缺少具体组织或数据库的名称，以及需要查找人员的类型（例如：员工、客户、合作伙伴等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查找哪个组织或数据库中的哪些人员的名称？", "processed_llm_output": "请问您想查找哪个组织或数据库中的哪些人员的名称？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:18.256610+00:00", "interaction_id": "a0fe017b-ea32-457a-9e7d-a3ec225f5296"}
{"task_type": "intent_classification", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 有多少个组织类型的实体？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:19.059877+00:00", "interaction_id": "6efc4075-46ea-43fa-bbda-d0f6f74577f3"}
{"task_type": "clarification_question_generation", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 有多少个组织类型的实体？\n不确定性原因: 缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪一类组织类型的实体数量？", "processed_llm_output": "请问您指的是哪一类组织类型的实体数量？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:19.352776+00:00", "interaction_id": "9979c797-4517-4d33-9c76-af4ff34e53b8"}
{"task_type": "intent_classification", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:19.752891+00:00", "interaction_id": "6a6fb424-f1f8-48bd-9ba5-03db9424e883"}
{"task_type": "query_expansion", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"王五在A公司具体担任什么职位？\",\n  \"项目B是由王五直接负责的吗？\",\n  \"王五是否同时在A公司负责多个项目？\"\n]", "processed_llm_output": "[\n  \"王五在A公司具体担任什么职位？\",\n  \"项目B是由王五直接负责的吗？\",\n  \"王五是否同时在A公司负责多个项目？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:20.723600+00:00", "interaction_id": "2238f574-7b7a-4b44-ac6b-2e51f90a7603"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:23.752467+00:00", "interaction_id": "84d085a1-d163-447d-b125-aafc89a92335"}
{"task_type": "cypher_generation", "user_query": "王五在A公司具体担任什么职位？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五在A公司具体担任什么职位？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:25.027462+00:00", "interaction_id": "2a69b74e-732f-46a7-8681-3dcffabee43a"}
{"task_type": "cypher_generation", "user_query": "项目B是由王五直接负责的吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目B是由王五直接负责的吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text AS responsiblePersonName", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text AS responsiblePersonName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:28.282220+00:00", "interaction_id": "3c1e9067-85b5-4d9f-81c1-dca66983fe98"}
{"task_type": "cypher_generation", "user_query": "王五是否同时在A公司负责多个项目？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否同时在A公司负责多个项目？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:29.568908+00:00", "interaction_id": "050e59c0-3635-4c0d-90b4-6cbad897ad7c"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:33.464686+00:00", "interaction_id": "31ce4a2b-e439-44d4-930c-b801352b8266"}
{"task_type": "answer_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:34.954400+00:00", "interaction_id": "393a757a-01a7-47f9-8ba1-3c187677c5d6"}
{"timestamp_utc": "2025-05-31T09:00:34.956206+00:00", "interaction_id": "862f0388-1a3f-4691-93f7-e13eea24aeca", "task_type": "rag_query_processing_success", "user_query": "王五既在A公司工作，又负责了项目B吗？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -6.48046875, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -6.48046875, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "项目B是由王五直接负责的吗？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有被分配了任务的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:35.823993+00:00", "interaction_id": "f1e24783-0de2-4358-a96c-7e79af08d082"}
{"task_type": "clarification_question_generation", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有被分配了任务的员工。\n不确定性原因: 缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请指定是哪个项目或团队的员工被分配了任务，以及需要列出所有部门还是特定部门的员工？", "processed_llm_output": "请指定是哪个项目或团队的员工被分配了任务，以及需要列出所有部门还是特定部门的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:36.444186+00:00", "interaction_id": "d920518c-6e5c-4148-9d41-b05e861b0090"}
{"task_type": "intent_classification", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:37.151746+00:00", "interaction_id": "c0531e25-a8c3-483a-a333-4a0a0b4b2fd8"}
{"task_type": "clarification_question_generation", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n不确定性原因: 缺少具体的PERSON名称，以及任务分配的上下文信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "“市场调研报告”这个任务具体分配给了谁？", "processed_llm_output": "“市场调研报告”这个任务具体分配给了谁？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:37.491033+00:00", "interaction_id": "1dd22151-1939-4621-a38d-ff1230f0927c"}
{"task_type": "intent_classification", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:38.339896+00:00", "interaction_id": "542c860e-add8-4209-a54b-4c0fe568d328"}
{"task_type": "clarification_question_generation", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n不确定性原因: 缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查询哪家企业的“战略规划部”？", "processed_llm_output": "请问您想查询哪家企业的“战略规划部”？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:38.679803+00:00", "interaction_id": "af3b08d0-bb3d-4266-a690-89e8510a8953"}
{"task_type": "intent_classification", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 告诉我关于张三和他的工作单位的信息。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:39.402230+00:00", "interaction_id": "0f1acdfa-60d6-4c1e-82f5-f0956764241a"}
{"task_type": "clarification_question_generation", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 告诉我关于张三和他的工作单位的信息。\n不确定性原因: 缺少张三的工作单位信息，需要明确他是哪家公司的员工。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "张三的工作单位是哪家公司？", "processed_llm_output": "张三的工作单位是哪家公司？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:39.651543+00:00", "interaction_id": "44c9ad06-b531-4a39-ad28-4be648f9ea63"}
{"task_type": "intent_classification", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:40.273371+00:00", "interaction_id": "6c930258-b867-4eef-a335-81eb481ff0a0"}
{"task_type": "clarification_question_generation", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n不确定性原因: 缺少具体的人名和项目Alpha的相关信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问具体是哪位员工以及项目Alpha是什么项目？", "processed_llm_output": "请问具体是哪位员工以及项目Alpha是什么项目？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:40.598532+00:00", "interaction_id": "7dd9d646-198a-4378-8869-a7888e3a82e5"}
{"task_type": "intent_classification", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:40.991980+00:00", "interaction_id": "d9673441-fed1-45b5-9dfa-fd793828a9ad"}
{"task_type": "query_expansion", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三现在的具体年龄是多少岁？\",\n  \"张三出生于哪一年？\",\n  \"张三的年龄增长趋势如何？\"\n]", "processed_llm_output": "[\n  \"张三现在的具体年龄是多少岁？\",\n  \"张三出生于哪一年？\",\n  \"张三的年龄增长趋势如何？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:41.770868+00:00", "interaction_id": "aa789ddf-4e46-4708-b6fe-7991437398e9"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:43.110533+00:00", "interaction_id": "c1b1475b-e4e9-438f-a3e9-28c1cfc25b98"}
{"task_type": "cypher_generation", "user_query": "张三现在的具体年龄是多少岁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三现在的具体年龄是多少岁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:00:45.316281+00:00", "interaction_id": "0672cc4b-c59d-4eec-8192-c1183ea82873"}
{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:01:51.630518+00:00", "interaction_id": "57ec9ca5-f5a8-47cb-8862-285b6dec5606"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三的当前工作地点是哪里？\",\n  \"张三最近一次工作变动是在什么时候？\",\n  \"张三所属公司的主要业务领域是什么？\"\n]", "processed_llm_output": "[\n  \"张三的当前工作地点是哪里？\",\n  \"张三最近一次工作变动是在什么时候？\",\n  \"张三所属公司的主要业务领域是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:01:52.511322+00:00", "interaction_id": "8ff6efe9-e9a5-45d0-920f-408b1a7b1629"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:01:54.645419+00:00", "interaction_id": "a6de9cbf-d6d0-4b4d-8062-82d2c047ec9f"}
{"task_type": "cypher_generation", "user_query": "张三的当前工作地点是哪里？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的当前工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "processed_llm_output": "MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:01:56.792512+00:00", "interaction_id": "85906735-4c02-420f-9e0b-7af45368a73d"}
{"task_type": "cypher_generation", "user_query": "张三最近一次工作变动是在什么时候？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三最近一次工作变动是在什么时候？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:01:58.092762+00:00", "interaction_id": "50e3c15a-6cd3-4d60-8447-302b85bb7bdc"}
{"task_type": "cypher_generation", "user_query": "张三所属公司的主要业务领域是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三所属公司的主要业务领域是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:02:00.316617+00:00", "interaction_id": "e8a15e25-dd91-4e2c-b54b-683a486b797f"}
{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:02.674155+00:00", "interaction_id": "d09a0dcd-9549-4483-a930-3ae124239294"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三当前的工作地点是哪里？\",\n  \"张三的工作单位是哪家公司？\",\n  \"张三最近一次工作变动的具体信息是什么？\"\n]", "processed_llm_output": "[\n  \"张三当前的工作地点是哪里？\",\n  \"张三的工作单位是哪家公司？\",\n  \"张三最近一次工作变动的具体信息是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:03.546703+00:00", "interaction_id": "2d1f5460-69ed-476a-b580-473edac9af62"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:05.675853+00:00", "interaction_id": "cd29ca22-a55c-41c5-9e7e-79bf99798e84"}
{"task_type": "cypher_generation", "user_query": "张三当前的工作地点是哪里？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三当前的工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:07.772362+00:00", "interaction_id": "44ce61cf-176b-4273-b344-c471465849f8"}
{"task_type": "cypher_generation", "user_query": "张三的工作单位是哪家公司？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的工作单位是哪家公司？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:09.909456+00:00", "interaction_id": "0d306b27-ecc8-4139-a8f3-98bcd4303c86"}
{"task_type": "cypher_generation", "user_query": "张三最近一次工作变动的具体信息是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三最近一次工作变动的具体信息是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:11.219763+00:00", "interaction_id": "bde265e6-3811-4376-ba8a-6f3c331ea0c6"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:14.334565+00:00", "interaction_id": "ba6eaafd-d93b-4a3c-911b-32d6abf751e9"}
{"task_type": "answer_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:15.940045+00:00", "interaction_id": "f72d37c4-fada-4a00-8b34-f6aef57fd58f"}
{"timestamp_utc": "2025-05-31T09:16:15.942452+00:00", "interaction_id": "3297dc69-0e2b-4ca2-a335-58def3fab834", "task_type": "rag_query_processing_success", "user_query": "张三在哪里工作？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": 6.6953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 6.6953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三在哪里工作？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:16.370567+00:00", "interaction_id": "4001213e-b070-474f-8e08-c9a1e5dc1872"}
{"task_type": "query_expansion", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的文档编写任务分配给的是哪位团队成员？\",\n  \"项目Alpha的文档编写任务是否有时间表或截止日期？\",\n  \"项目Alpha的文档编写任务是否包含任何特定的要求或标准？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的文档编写任务分配给的是哪位团队成员？\",\n  \"项目Alpha的文档编写任务是否有时间表或截止日期？\",\n  \"项目Alpha的文档编写任务是否包含任何特定的要求或标准？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:17.616480+00:00", "interaction_id": "320008e4-5594-428d-9cbd-0d838c7658e6"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:19.861889+00:00", "interaction_id": "dcca28b1-e1cc-4383-990e-08fd2d2c158b"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给的是哪位团队成员？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给的是哪位团队成员？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(member:ExtractedEntity {label: 'PERSON'}) RETURN member.text AS teamMemberName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(member:ExtractedEntity {label: 'PERSON'}) RETURN member.text AS teamMemberName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:22.135067+00:00", "interaction_id": "55d63536-2528-46f8-807d-4b18db2bec08"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务是否有时间表或截止日期？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务是否有时间表或截止日期？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:23.431887+00:00", "interaction_id": "cfc71e15-6420-45ac-8f43-cf33596b364b"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务是否包含任何特定的要求或标准？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务是否包含任何特定的要求或标准？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:25.637263+00:00", "interaction_id": "3834f5b4-7e6a-42ad-95ec-76436572901e"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:28.760404+00:00", "interaction_id": "af4ba42f-c904-4090-bf47-440229fc7d1a"}
{"task_type": "answer_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:30.369650+00:00", "interaction_id": "36635f84-b1d3-4509-8fce-0bf95ac1bb62"}
{"timestamp_utc": "2025-05-31T09:16:30.371438+00:00", "interaction_id": "62391b69-eb93-40d4-a1da-328f7f9b15b8", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的文档编写任务分配给了谁？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "5af962307c33de17029190bba9ffd195", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": 9.2578125, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}, {"source": "keyword_bm25s", "score": -10.1953125, "id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "content_preview": "第二个文档讨论了自然语言处理技术。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 9.2578125, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的文档编写任务分配给的是哪位团队成员？"}}, {"source_type": "keyword_bm25s", "content": "第二个文档讨论了自然语言处理技术。", "score": -10.1953125, "metadata": {"chunk_id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}], "final_context_docs_count": 2, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:30.793792+00:00", "interaction_id": "e002f78d-a360-496d-baf8-ee43b1702c40"}
{"task_type": "query_expansion", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四目前负责哪些具体任务？\",\n  \"李四在过去一年中完成了哪些重要任务？\",\n  \"李四的任务分配和职责范围是什么？\"\n]", "processed_llm_output": "[\n  \"李四目前负责哪些具体任务？\",\n  \"李四在过去一年中完成了哪些重要任务？\",\n  \"李四的任务分配和职责范围是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:31.742558+00:00", "interaction_id": "e7e16f9d-dc6b-4b09-b121-78d00d05b7a3"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:34.056834+00:00", "interaction_id": "ae338d74-4e5e-4fd7-af89-77fe4d62ec1f"}
{"task_type": "cypher_generation", "user_query": "李四目前负责哪些具体任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四目前负责哪些具体任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:36.377895+00:00", "interaction_id": "0539ec25-a451-43b1-ad88-dc1159518ae7"}
{"task_type": "cypher_generation", "user_query": "李四在过去一年中完成了哪些重要任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在过去一年中完成了哪些重要任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) WHERE task.period CONTAINS '过去一年' RETURN task.text AS taskName", "processed_llm_output": "MATCH (l:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) WHERE task.period CONTAINS '过去一年' RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:38.701694+00:00", "interaction_id": "604dfe3b-cab7-4574-8b42-1e6911c309fa"}
{"task_type": "cypher_generation", "user_query": "李四的任务分配和职责范围是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四的任务分配和职责范围是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName, l4.text AS assignerName", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName, l4.text AS assignerName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:40.910339+00:00", "interaction_id": "30bf5cb2-b9d2-491b-93c9-6ac2872b4e2c"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:43.108827+00:00", "interaction_id": "2dd4b74b-8e6b-44ba-a895-b4b97c7d3e8a"}
{"task_type": "intent_classification", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:43.524337+00:00", "interaction_id": "6dd4ac96-da2f-421b-aaa9-6b5bb01ab139"}
{"task_type": "query_expansion", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"市场部的具体员工构成是怎样的？\",\n  \"市场部的员工数量是多少？\",\n  \"市场部员工的工作职责有哪些？\"\n]", "processed_llm_output": "[\n  \"市场部的具体员工构成是怎样的？\",\n  \"市场部的员工数量是多少？\",\n  \"市场部员工的工作职责有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:44.365365+00:00", "interaction_id": "65c316a1-bf34-4f71-9c61-f29a2ae3b195"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:46.669715+00:00", "interaction_id": "567d810a-f69b-4c27-8b01-26f48e1daeae"}
{"task_type": "cypher_generation", "user_query": "市场部的具体员工构成是怎样的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部的具体员工构成是怎样的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:48.939829+00:00", "interaction_id": "c4ca3506-547c-4470-b95f-af53aea9a359"}
{"task_type": "cypher_generation", "user_query": "市场部的员工数量是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部的员工数量是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:50.278771+00:00", "interaction_id": "8765bf4d-fd34-4f86-a0cd-fdca4d1f73e3"}
{"task_type": "cypher_generation", "user_query": "市场部员工的工作职责有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的工作职责有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:52.562101+00:00", "interaction_id": "2e40dcf0-589f-4fec-8c8b-b2654c82e6f2"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:55.698589+00:00", "interaction_id": "d3a17376-5419-4bcf-9637-2faa3f829c73"}
{"task_type": "intent_classification", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有类型为TASK的实体。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:56.750902+00:00", "interaction_id": "73b7a9a7-2716-45d0-8efb-a5c1682dbe3e"}
{"task_type": "clarification_question_generation", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有类型为TASK的实体。\n不确定性原因: 缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请确认您想列出所有类型为TASK的项目还是文档？", "processed_llm_output": "请确认您想列出所有类型为TASK的项目还是文档？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:57.142356+00:00", "interaction_id": "68e92b7e-ab3e-43d1-a17b-66de69987e17"}
{"task_type": "intent_classification", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查询所有在创新科技公司工作的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:58.005882+00:00", "interaction_id": "c431ae78-b331-43ac-95c1-108a4c94cb66"}
{"task_type": "clarification_question_generation", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查询所有在创新科技公司工作的员工。\n不确定性原因: 缺少具体公司名称，以及查询范围（所有员工还是特定部门或职位的员工）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪家创新科技公司，以及是想查询所有员工还是特定部门或职位的员工？", "processed_llm_output": "请问您指的是哪家创新科技公司，以及是想查询所有员工还是特定部门或职位的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:58.573872+00:00", "interaction_id": "eff857b9-3518-4796-b239-9d0aab1611dd"}
{"task_type": "intent_classification", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查找所有人员的名称。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:59.275622+00:00", "interaction_id": "1725a7e0-27dd-45c2-a22c-e27757d2f1f2"}
{"task_type": "clarification_question_generation", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查找所有人员的名称。\n不确定性原因: 缺少具体需要查询的人员类别或部门等信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "您是想查询公司人员的名称还是学校师生的名称？或者有特定的部门或项目？", "processed_llm_output": "您是想查询公司人员的名称还是学校师生的名称？或者有特定的部门或项目？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:16:59.862273+00:00", "interaction_id": "333bbaf8-d52f-445b-aacf-e9a644e13763"}
{"task_type": "intent_classification", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 有多少个组织类型的实体？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:00.657026+00:00", "interaction_id": "e0ba90c0-b3de-4858-815b-df2f7feb7d9b"}
{"task_type": "clarification_question_generation", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 有多少个组织类型的实体？\n不确定性原因: 缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪一类组织类型的实体数量？", "processed_llm_output": "请问您指的是哪一类组织类型的实体数量？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:00.940659+00:00", "interaction_id": "67a518a9-60f0-4010-b47a-76643371cb39"}
{"task_type": "intent_classification", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:01.331244+00:00", "interaction_id": "e12e1f13-d7df-4489-b824-0b30b0750c50"}
{"task_type": "query_expansion", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"王五是否在A公司工作？\",\n  \"王五是否负责了项目B？\",\n  \"王五在A公司工作期间是否也负责了项目B？\"\n]", "processed_llm_output": "[\n  \"王五是否在A公司工作？\",\n  \"王五是否负责了项目B？\",\n  \"王五在A公司工作期间是否也负责了项目B？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:02.273946+00:00", "interaction_id": "c4f7f579-972e-47ec-8bd8-e5ae4046013b"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:05.520130+00:00", "interaction_id": "ec45121a-8cf8-4b7d-b5eb-95a24c3bbd30"}
{"task_type": "cypher_generation", "user_query": "王五是否在A公司工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否在A公司工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}) RETURN w5.text AS personName, a_company.text AS companyName", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}) RETURN w5.text AS personName, a_company.text AS companyName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:08.083350+00:00", "interaction_id": "7953371a-1125-46bf-8488-b3cd597174b6"}
{"task_type": "cypher_generation", "user_query": "王五是否负责了项目B？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否负责了项目B？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:10.529381+00:00", "interaction_id": "a8a101c6-8bf6-46db-ac33-bd06a9f4782c"}
{"task_type": "cypher_generation", "user_query": "王五在A公司工作期间是否也负责了项目B？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五在A公司工作期间是否也负责了项目B？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nRETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nRETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:13.720343+00:00", "interaction_id": "2e82667f-14a0-4dd8-a1e2-81095f989841"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:17.235254+00:00", "interaction_id": "60e99dcf-af7b-467a-a1de-e12c34219286"}
{"task_type": "answer_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:18.943665+00:00", "interaction_id": "14993180-cd0b-4ab9-8bb8-2e0c818067ea"}
{"timestamp_utc": "2025-05-31T09:17:18.945406+00:00", "interaction_id": "2b8d2635-2036-45e5-b1b4-ccf921de4687", "task_type": "rag_query_processing_success", "user_query": "王五既在A公司工作，又负责了项目B吗？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -6.48046875, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -6.48046875, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "王五既在A公司工作，又负责了项目B吗？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有被分配了任务的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:19.927559+00:00", "interaction_id": "bdce1b11-452e-42d7-9b1e-cc7cf33a7282"}
{"task_type": "clarification_question_generation", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有被分配了任务的员工。\n不确定性原因: 缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请指定是哪个项目或团队的任务，以及希望查看所有部门还是特定部门的员工列表？", "processed_llm_output": "请指定是哪个项目或团队的任务，以及希望查看所有部门还是特定部门的员工列表？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:20.529837+00:00", "interaction_id": "4e939c49-4f1d-4da2-8aa9-ce9e4ec12f4c"}
{"task_type": "intent_classification", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:21.310157+00:00", "interaction_id": "82232ebc-0939-44bf-a622-7be1fcd39505"}
{"task_type": "clarification_question_generation", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n不确定性原因: 缺少具体的PERSON名称，以及任务分配的上下文信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "“市场调研报告”的任务具体分配给了谁？", "processed_llm_output": "“市场调研报告”的任务具体分配给了谁？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:21.656988+00:00", "interaction_id": "2f472c03-eb7c-4530-95e6-1b4051f85881"}
{"task_type": "intent_classification", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:22.620403+00:00", "interaction_id": "f1917161-5b67-41ac-981a-1c480fe5f9c8"}
{"task_type": "clarification_question_generation", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n不确定性原因: 缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查询哪个具体企业的“战略规划部”？", "processed_llm_output": "请问您想查询哪个具体企业的“战略规划部”？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:23.042151+00:00", "interaction_id": "cebbb6b4-79fb-41ef-a834-ec079a3153d1"}
{"task_type": "intent_classification", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 告诉我关于张三和他的工作单位的信息。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:23.830460+00:00", "interaction_id": "294f77cc-2efa-458f-9a08-f200b75143d9"}
{"task_type": "clarification_question_generation", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 告诉我关于张三和他的工作单位的信息。\n不确定性原因: 缺少张三的工作单位信息，需要明确他是哪家公司的员工。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "张三的工作单位是哪家公司？", "processed_llm_output": "张三的工作单位是哪家公司？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:24.098302+00:00", "interaction_id": "dda3ed59-9deb-4255-9938-cb4e04e9d845"}
{"task_type": "intent_classification", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:24.814548+00:00", "interaction_id": "c36f0a9a-20fd-47f9-a925-0306a4276f9a"}
{"task_type": "clarification_question_generation", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n不确定性原因: 缺少具体的人名和项目Alpha的相关信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问具体是哪位员工负责了项目Alpha的文档编写任务？", "processed_llm_output": "请问具体是哪位员工负责了项目Alpha的文档编写任务？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:25.272235+00:00", "interaction_id": "a1661be4-0943-4ff6-bcf4-271cf4fbd980"}
{"task_type": "intent_classification", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:25.711401+00:00", "interaction_id": "7d94578b-f560-48e3-a8c8-aa933b3308f5"}
{"task_type": "query_expansion", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三现在的具体年龄是多少？\",\n  \"张三的年龄变化趋势如何？\",\n  \"张三的年龄在不同年龄段的比例是多少？\"\n]", "processed_llm_output": "[\n  \"张三现在的具体年龄是多少？\",\n  \"张三的年龄变化趋势如何？\",\n  \"张三的年龄在不同年龄段的比例是多少？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:26.646764+00:00", "interaction_id": "c588bfd1-b6ea-4107-943e-aea62de2d0fb"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:28.081385+00:00", "interaction_id": "04994f6f-e3a7-4a1b-b266-814f9bca97d4"}
{"task_type": "cypher_generation", "user_query": "张三现在的具体年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三现在的具体年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:30.273825+00:00", "interaction_id": "91ebd417-3ef0-4327-97b4-44727fbb1a67"}
{"task_type": "cypher_generation", "user_query": "张三的年龄变化趋势如何？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄变化趋势如何？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:32.558185+00:00", "interaction_id": "caf59657-91a0-499b-804a-5b0d4bd2a1ea"}
{"task_type": "cypher_generation", "user_query": "张三的年龄在不同年龄段的比例是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄在不同年龄段的比例是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:34.747727+00:00", "interaction_id": "031ec9d4-9ca4-4171-a7c5-0b7dbc6ab29f"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:36.867673+00:00", "interaction_id": "f7f6b145-923f-474a-9f9b-1a4cf6c4be28"}
{"task_type": "answer_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:39.275679+00:00", "interaction_id": "929f9b33-efd6-4427-8cfe-5cb83ed211b3"}
{"timestamp_utc": "2025-05-31T09:17:39.278918+00:00", "interaction_id": "9996d9dc-0907-40b7-86ae-cbde26be5923", "task_type": "rag_query_processing_success", "user_query": "张三的年龄是多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三的年龄是多少？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:39.707740+00:00", "interaction_id": "4a558b3d-100d-4209-92fb-c4260bd35c65"}
{"task_type": "query_expansion", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的具体预算是多少？\",\n  \"项目Alpha的预算分配在哪些具体领域？\",\n  \"项目Alpha的预算与去年同期相比有何变化？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的具体预算是多少？\",\n  \"项目Alpha的预算分配在哪些具体领域？\",\n  \"项目Alpha的预算与去年同期相比有何变化？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:40.654051+00:00", "interaction_id": "27072168-35da-43e0-b78a-2c095a3b0f85"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:42.055286+00:00", "interaction_id": "1e7e915f-2589-43e0-91fc-b2ea1943f262"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的具体预算是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的具体预算是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:44.277902+00:00", "interaction_id": "9adf6bee-1e40-457b-be66-2e23cd05f300"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算分配在哪些具体领域？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算分配在哪些具体领域？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:46.555556+00:00", "interaction_id": "64088a32-d9b3-4d00-ae4d-199da82bbd22"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算与去年同期相比有何变化？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算与去年同期相比有何变化？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:48.680365+00:00", "interaction_id": "d3180153-e0f5-4f25-a3fe-085cd4170adc"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:50.973608+00:00", "interaction_id": "de696837-cac7-4e2f-b1b4-4da0e5c526ea"}
{"task_type": "answer_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:53.380720+00:00", "interaction_id": "133a2378-d8ba-4d19-86ba-4eabcbaed173"}
{"timestamp_utc": "2025-05-31T09:17:53.382723+00:00", "interaction_id": "d76c45c1-ae69-4511-928c-b33544a75639", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的预算有多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": -7.51171875, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -7.51171875, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的预算分配在哪些具体领域？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:53.814947+00:00", "interaction_id": "76bf7817-54de-41f3-8df4-636e99de8943"}
{"task_type": "query_expansion", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四和王五的工作部门相同吗？\",\n  \"李四和王五是否在同一团队工作？\",\n  \"李四和王五之间的合作经历是什么？\"\n]", "processed_llm_output": "[\n  \"李四和王五的工作部门相同吗？\",\n  \"李四和王五是否在同一团队工作？\",\n  \"李四和王五之间的合作经历是什么？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:54.837827+00:00", "interaction_id": "fb5bf1c7-47cc-4bc8-ae53-7c1be3a58dc0"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:56.265039+00:00", "interaction_id": "bd6e4d48-baac-46c9-9bd1-35a31e19d0f5"}
{"task_type": "cypher_generation", "user_query": "李四和王五的工作部门相同吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五的工作部门相同吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:17:58.437650+00:00", "interaction_id": "780793ea-7636-4b50-8556-3329754fe2a3"}
{"task_type": "cypher_generation", "user_query": "李四和王五是否在同一团队工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是否在同一团队工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:00.670816+00:00", "interaction_id": "f9b5ac1f-b5a7-4911-8a54-c85bb9565a22"}
{"task_type": "cypher_generation", "user_query": "李四和王五之间的合作经历是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五之间的合作经历是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:02.850870+00:00", "interaction_id": "e900bce7-d3f3-4f03-8063-69dcc840357d"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:05.001743+00:00", "interaction_id": "c9f0fc3d-b9e6-4ddb-b619-b9eba9d4b928"}
{"task_type": "intent_classification", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:05.390836+00:00", "interaction_id": "f4a460b4-af79-4e95-9850-15a0900c006f"}
{"task_type": "query_expansion", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"谷歌公司第一台搜索引擎是在哪一年上线的？\",\n  \"谷歌公司的创始人是谁？\",\n  \"谷歌公司在成立后最初几年内有哪些重要的里程碑或事件？\"\n]", "processed_llm_output": "[\n  \"谷歌公司第一台搜索引擎是在哪一年上线的？\",\n  \"谷歌公司的创始人是谁？\",\n  \"谷歌公司在成立后最初几年内有哪些重要的里程碑或事件？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:06.357026+00:00", "interaction_id": "64f9d184-b80f-4bb7-b449-12a58b39b45d"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:07.714212+00:00", "interaction_id": "99e85054-f6cc-4b30-b41a-57cdd67297dd"}
{"task_type": "cypher_generation", "user_query": "谷歌公司第一台搜索引擎是在哪一年上线的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司第一台搜索引擎是在哪一年上线的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:09.961412+00:00", "interaction_id": "d139f908-bc4d-4a1b-b0c4-ba5532a2ab25"}
{"task_type": "cypher_generation", "user_query": "谷歌公司的创始人是谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司的创始人是谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:12.078256+00:00", "interaction_id": "50b8f993-0ed7-4729-af36-dfab0baf0ffc"}
{"task_type": "cypher_generation", "user_query": "谷歌公司在成立后最初几年内有哪些重要的里程碑或事件？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司在成立后最初几年内有哪些重要的里程碑或事件？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:14.246583+00:00", "interaction_id": "22a95853-e810-44c5-9c70-577dfdd7f1f2"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:16.483729+00:00", "interaction_id": "1a6ccc37-db7d-4d74-afd3-47527bd6ef8b"}
{"task_type": "answer_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:18:18.848478+00:00", "interaction_id": "b2be109d-116b-43fa-ac12-68895364e767"}
{"timestamp_utc": "2025-05-31T09:18:18.850873+00:00", "interaction_id": "456306ee-51e3-4117-a68b-259dfe192ff9", "task_type": "rag_query_processing_success", "user_query": "谷歌公司是什么时候成立的？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "谷歌公司的创始人是谁？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:21.474013+00:00", "interaction_id": "03cc05fd-d080-47fa-865f-f67423e395f7"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三目前工作的公司名称是什么？\",\n  \"张三的当前职位是什么？\",\n  \"张三所在公司的主要业务领域有哪些？\"\n]", "processed_llm_output": "[\n  \"张三目前工作的公司名称是什么？\",\n  \"张三的当前职位是什么？\",\n  \"张三所在公司的主要业务领域有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:22.277871+00:00", "interaction_id": "6cb665fd-54cb-4d16-8d1e-267c37cd22ba"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:24.441406+00:00", "interaction_id": "d1266d1c-488b-4924-9004-1ad3b094d973"}
{"task_type": "cypher_generation", "user_query": "张三目前工作的公司名称是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三目前工作的公司名称是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS companyName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS companyName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:26.583115+00:00", "interaction_id": "ce306865-69ea-496d-83a2-cdddccdc9119"}
{"task_type": "cypher_generation", "user_query": "张三的当前职位是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的当前职位是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:27.969034+00:00", "interaction_id": "885fa60f-5d0d-464a-b176-56a0f7bf065b"}
{"task_type": "cypher_generation", "user_query": "张三所在公司的主要业务领域有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三所在公司的主要业务领域有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:30.217500+00:00", "interaction_id": "198e2ea7-b809-4b0f-ab3c-72f315da3adc"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:33.200464+00:00", "interaction_id": "54a62d14-fbab-43d9-bfc3-510d994a652c"}
{"task_type": "answer_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:34.754630+00:00", "interaction_id": "5d548760-160a-4dd1-aec9-2dc32f4ed0c5"}
{"timestamp_utc": "2025-05-31T09:25:34.757269+00:00", "interaction_id": "d1c206c2-a376-458a-8ffb-791e67fcac32", "task_type": "rag_query_processing_success", "user_query": "张三在哪里工作？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": 6.6953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 6.6953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三目前工作的公司名称是什么？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:35.140672+00:00", "interaction_id": "9662765e-ae1c-427d-a03a-afa63a1cd0be"}
{"task_type": "query_expansion", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"谁负责项目Alpha的文档编写任务？\",\n  \"项目Alpha的文档编写任务分配的时间是什么？\",\n  \"项目Alpha的文档编写任务完成的进度如何？\"\n]", "processed_llm_output": "[\n  \"谁负责项目Alpha的文档编写任务？\",\n  \"项目Alpha的文档编写任务分配的时间是什么？\",\n  \"项目Alpha的文档编写任务完成的进度如何？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:36.068371+00:00", "interaction_id": "96c6da17-47ac-4843-9993-4dc2e74b0ae0"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:38.281430+00:00", "interaction_id": "8aa744a5-cff9-44fc-b031-1195e088e405"}
{"task_type": "cypher_generation", "user_query": "谁负责项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谁负责项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:40.486229+00:00", "interaction_id": "15149b33-9477-4a4f-b6b0-25d0aec39389"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配的时间是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配的时间是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:41.815943+00:00", "interaction_id": "1a1d76c8-c22e-41e2-822e-3f93be1756c5"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务完成的进度如何？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务完成的进度如何？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:COMPLETED_IN]->(progress:ExtractedEntity) RETURN progress.percent_complete AS progressPercentage", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:COMPLETED_IN]->(progress:ExtractedEntity) RETURN progress.percent_complete AS progressPercentage", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:44.842900+00:00", "interaction_id": "f16daf69-64d6-4261-9cc6-1968720d6646"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:47.092791+00:00", "interaction_id": "a03ffc9d-e32d-41a5-bb36-893ea1a254d8"}
{"task_type": "answer_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:48.656469+00:00", "interaction_id": "a323809e-c0f8-435e-84d9-1c9bbdc1db94"}
{"timestamp_utc": "2025-05-31T09:25:48.658155+00:00", "interaction_id": "b6e4a433-1a3a-44a5-ba98-98f226a2f8ae", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的文档编写任务分配给了谁？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "5af962307c33de17029190bba9ffd195", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": 9.2578125, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}, {"source": "keyword_bm25s", "score": -10.1953125, "id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "content_preview": "第二个文档讨论了自然语言处理技术。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 9.2578125, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}, {"source_type": "keyword_bm25s", "content": "第二个文档讨论了自然语言处理技术。", "score": -10.1953125, "metadata": {"chunk_id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}], "final_context_docs_count": 2, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:49.047412+00:00", "interaction_id": "45017c46-952c-43f6-a03d-d1a9e253ca40"}
{"task_type": "query_expansion", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四的具体工作任务包括哪些？\",\n  \"李四在公司中承担的主要职责是什么？\",\n  \"李四负责的项目或任务有哪些？\"\n]", "processed_llm_output": "[\n  \"李四的具体工作任务包括哪些？\",\n  \"李四在公司中承担的主要职责是什么？\",\n  \"李四负责的项目或任务有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:49.896657+00:00", "interaction_id": "c4c75977-3749-4d9f-bd2d-15014d41a129"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:52.051005+00:00", "interaction_id": "0ce99789-7510-4d8f-bde5-a7fb310f7bbe"}
{"task_type": "cypher_generation", "user_query": "李四的具体工作任务包括哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四的具体工作任务包括哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:54.053594+00:00", "interaction_id": "f424c901-7e2c-4cca-9bde-4475dbceeb3a"}
{"task_type": "cypher_generation", "user_query": "李四在公司中承担的主要职责是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在公司中承担的主要职责是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:55.562758+00:00", "interaction_id": "f847411f-1a24-4f09-8adf-459e124ec3bf"}
{"task_type": "cypher_generation", "user_query": "李四负责的项目或任务有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责的项目或任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(proj_or_task:ExtractedEntity) RETURN proj_or_task.text AS projOrTaskName", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(proj_or_task:ExtractedEntity) RETURN proj_or_task.text AS projOrTaskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:25:58.605683+00:00", "interaction_id": "4fa88f3c-e2a7-4b9a-9314-63bdc453f37c"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:00.785918+00:00", "interaction_id": "5f33f568-c0dc-4249-9f3c-2c827d5e0ccf"}
{"task_type": "intent_classification", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:01.190006+00:00", "interaction_id": "6ca17755-10d4-40c6-b983-017d1aa92637"}
{"task_type": "query_expansion", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"市场部具体有哪些员工？\",\n  \"市场部员工的职位有哪些？\",\n  \"市场部员工的工作年限如何？\"\n]", "processed_llm_output": "[\n  \"市场部具体有哪些员工？\",\n  \"市场部员工的职位有哪些？\",\n  \"市场部员工的工作年限如何？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:01.920193+00:00", "interaction_id": "1a333ce7-4780-49ae-92a2-2bb4762ee7de"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:04.151293+00:00", "interaction_id": "d94f4797-67bb-424e-b20d-0a81694c33ac"}
{"task_type": "cypher_generation", "user_query": "市场部具体有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部具体有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:06.347146+00:00", "interaction_id": "1f34d1c2-9835-47aa-8b24-94692e9b0f8f"}
{"task_type": "cypher_generation", "user_query": "市场部员工的职位有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的职位有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (m:Person)-[:WORKS_AT]->(d:Organization {name: '市场部'}) RETURN d.label AS departmentLabel, m.label AS positionLabel", "processed_llm_output": "MATCH (m:Person)-[:WORKS_AT]->(d:Organization {name: '市场部'}) RETURN d.label AS departmentLabel, m.label AS positionLabel", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:08.304855+00:00", "interaction_id": "4366180f-a9f2-4dc0-b7f5-22d48e2e1ab1"}
{"task_type": "cypher_generation", "user_query": "市场部员工的工作年限如何？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的工作年限如何？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:09.851323+00:00", "interaction_id": "d82cdfc3-0957-4a7b-8eac-0493b30a821c"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:12.956726+00:00", "interaction_id": "e03c8bf0-9146-45e6-8b45-8cdc7fbcb548"}
{"task_type": "intent_classification", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有类型为TASK的实体。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:13.960216+00:00", "interaction_id": "f6d9f63e-35dc-4431-abe8-817bd9fa66c6"}
{"task_type": "clarification_question_generation", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有类型为TASK的实体。\n不确定性原因: 缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体范围（所有项目、所有文档等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "列出所有类型为TASK的实体还是特定项目或文档？", "processed_llm_output": "列出所有类型为TASK的实体还是特定项目或文档？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:14.310241+00:00", "interaction_id": "d4196197-bd98-4650-84d4-f925437316d9"}
{"task_type": "intent_classification", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查询所有在创新科技公司工作的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:15.150341+00:00", "interaction_id": "328aef12-c62c-49fb-9ef5-682451451e88"}
{"task_type": "clarification_question_generation", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查询所有在创新科技公司工作的员工。\n不确定性原因: 缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请提供具体公司名称以及是查询所有员工还是特定部门/职位的员工？", "processed_llm_output": "请提供具体公司名称以及是查询所有员工还是特定部门/职位的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:15.608926+00:00", "interaction_id": "43739f96-0098-47f6-9d9b-0f1d2ce7a3c6"}
{"task_type": "intent_classification", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查找所有人员的名称。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:16.276219+00:00", "interaction_id": "936f4cc0-da0b-4c5c-9faf-2cb36c734767"}
{"task_type": "clarification_question_generation", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查找所有人员的名称。\n不确定性原因: 缺少具体需要查询的人员类别或部门等信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "您是想查询公司员工的名称还是某个特定部门的名称？", "processed_llm_output": "您是想查询公司员工的名称还是某个特定部门的名称？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:16.672703+00:00", "interaction_id": "cc2249ff-ff7f-405e-b608-54faf8d65f41"}
{"task_type": "intent_classification", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 有多少个组织类型的实体？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:17.445572+00:00", "interaction_id": "ae8751fc-8ac8-4e15-925f-fbf75cabbbe7"}
{"task_type": "clarification_question_generation", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 有多少个组织类型的实体？\n不确定性原因: 缺少具体组织类型或上下文信息，无法确定需要统计的组织类型。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您指的是哪些类型的组织实体？", "processed_llm_output": "请问您指的是哪些类型的组织实体？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:17.689870+00:00", "interaction_id": "fbdc23b6-4649-4445-b607-373443cacbfd"}
{"task_type": "intent_classification", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:18.081546+00:00", "interaction_id": "16f8816b-bbd1-48be-af39-d494f770de8d"}
{"task_type": "query_expansion", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"王五在A公司负责了项目B的哪些具体工作内容？\",\n  \"A公司其他员工中，是否有人同时负责项目B？\",\n  \"王五在A公司工作期间，是否曾负责过其他项目？\"\n]", "processed_llm_output": "[\n  \"王五在A公司负责了项目B的哪些具体工作内容？\",\n  \"A公司其他员工中，是否有人同时负责项目B？\",\n  \"王五在A公司工作期间，是否曾负责过其他项目？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:19.291494+00:00", "interaction_id": "e4e6e369-8c3b-487c-86b5-caa5711d44dd"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:22.334419+00:00", "interaction_id": "2db206a5-580e-4f66-88fc-fc90bf2ad74c"}
{"task_type": "cypher_generation", "user_query": "王五在A公司负责了项目B的哪些具体工作内容？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五在A公司负责了项目B的哪些具体工作内容？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'})-[:HAS_PROGRESS]->(details:ExtractedEntity) RETURN details.text AS workContent", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'})-[:HAS_PROGRESS]->(details:ExtractedEntity) RETURN details.text AS workContent", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:24.872441+00:00", "interaction_id": "fabe4db5-093f-4b8b-ac81-c86f8e7451f9"}
{"task_type": "cypher_generation", "user_query": "A公司其他员工中，是否有人同时负责项目B？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: A公司其他员工中，是否有人同时负责项目B？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:WORKS_AT]->(p:ExtractedEntity {label: 'PERSON'}), (p)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nWHERE p.text IS NOT NULL\nRETURN p.text AS personName", "processed_llm_output": "MATCH (a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:WORKS_AT]->(p:ExtractedEntity {label: 'PERSON'}), (p)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'})\nWHERE p.text IS NOT NULL\nRETURN p.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:27.844972+00:00", "interaction_id": "5b90b58f-6b2a-437c-a271-d83f1b053018"}
{"task_type": "cypher_generation", "user_query": "王五在A公司工作期间，是否曾负责过其他项目？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五在A公司工作期间，是否曾负责过其他项目？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})\nMATCH (w5)-[:ASSIGNED_TO]->(proj:ExtractedEntity {label: 'TASK'})\nRETURN COUNT(DISTINCT proj.text) > 0 AS hasOtherProjects", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})\nMATCH (w5)-[:ASSIGNED_TO]->(proj:ExtractedEntity {label: 'TASK'})\nRETURN COUNT(DISTINCT proj.text) > 0 AS hasOtherProjects", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:30.893553+00:00", "interaction_id": "4fc204d4-3199-4f93-a175-7e4b5d18689f"}
{"task_type": "cypher_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "processed_llm_output": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:34.083217+00:00", "interaction_id": "33afb4a6-ccde-4500-913d-0be416623208"}
{"task_type": "answer_generation", "user_query": "王五既在A公司工作，又负责了项目B吗？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:35.612146+00:00", "interaction_id": "92198c81-1caa-4535-9487-43d9df52f357"}
{"timestamp_utc": "2025-05-31T09:26:35.613947+00:00", "interaction_id": "83cb63e8-3afc-445f-8a99-d70f6305a20c", "task_type": "rag_query_processing_success", "user_query": "王五既在A公司工作，又负责了项目B吗？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": -6.48046875, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -6.48046875, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "王五在A公司负责了项目B的哪些具体工作内容？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有被分配了任务的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:36.463662+00:00", "interaction_id": "9c77b903-ea7c-468a-a7e1-0966978e1f16"}
{"task_type": "clarification_question_generation", "user_query": "列出所有被分配了任务的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有被分配了任务的员工。\n不确定性原因: 缺少具体项目或团队名称，以及员工列表的范围（如所有部门、特定部门等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请提供具体项目或团队名称，以及员工列表的范围（如所有部门或特定部门）。", "processed_llm_output": "请提供具体项目或团队名称，以及员工列表的范围（如所有部门或特定部门）。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:36.996891+00:00", "interaction_id": "12eda509-70db-4c53-8083-337b750a75ea"}
{"task_type": "intent_classification", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的PERSON名称，以及任务分配的上下文信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:37.684136+00:00", "interaction_id": "e4cf17b2-a0c4-4e94-a81d-c8c0d2ee70c8"}
{"task_type": "clarification_question_generation", "user_query": "名为“市场调研报告”的任务分配给了哪个PERSON？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“市场调研报告”的任务分配给了哪个PERSON？\n不确定性原因: 缺少具体的PERSON名称，以及任务分配的上下文信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "“市场调研报告”的任务具体分配给了谁？", "processed_llm_output": "“市场调研报告”的任务具体分配给了谁？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:37.998081+00:00", "interaction_id": "e3a31fb5-bcf2-4f0e-ae99-dd40de510739"}
{"task_type": "intent_classification", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:38.852831+00:00", "interaction_id": "af8b6fd4-c6a9-4024-9c2f-6659a8f3659e"}
{"task_type": "clarification_question_generation", "user_query": "名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 名为“战略规划部”的ORGANIZATION有哪些PERSON在里面工作？\n不确定性原因: 缺少具体的企业名称或组织架构信息，无法确定‘战略规划部’所属的组织。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "您提到的“战略规划部”是哪家公司的部门？", "processed_llm_output": "您提到的“战略规划部”是哪家公司的部门？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:39.226662+00:00", "interaction_id": "5ed28bc8-2c7a-4097-aa79-ea7082b3b6f1"}
{"task_type": "intent_classification", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 告诉我关于张三和他的工作单位的信息。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少张三的工作单位信息，需要明确他是哪家公司的员工。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:40.003721+00:00", "interaction_id": "8f412ba4-89c3-4ede-9422-1c62babd9288"}
{"task_type": "clarification_question_generation", "user_query": "告诉我关于张三和他的工作单位的信息。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 告诉我关于张三和他的工作单位的信息。\n不确定性原因: 缺少张三的工作单位信息，需要明确他是哪家公司的员工。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "张三的工作单位是哪家公司？", "processed_llm_output": "张三的工作单位是哪家公司？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:40.244955+00:00", "interaction_id": "404f2483-67d3-4575-8d26-b8ecf94a403f"}
{"task_type": "intent_classification", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体的人名和项目Alpha的相关信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:40.859587+00:00", "interaction_id": "9e3d9142-8b72-4a2c-a3b6-ff0bdbb58669"}
{"task_type": "clarification_question_generation", "user_query": "谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 谁在谷歌工作，并且也负责了项目Alpha的文档编写任务？\n不确定性原因: 缺少具体的人名和项目Alpha的相关信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问具体是指哪个员工以及项目Alpha是什么？", "processed_llm_output": "请问具体是指哪个员工以及项目Alpha是什么？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:41.161384+00:00", "interaction_id": "0995c90f-0d20-45b5-82ff-b2f0c120755f"}
{"task_type": "intent_classification", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:41.585505+00:00", "interaction_id": "ab7fe029-bc8a-4f97-8845-c4c0d6fdcb90"}
{"task_type": "query_expansion", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三现在的具体年龄是多少？\",\n  \"张三从出生到现在是多少岁？\",\n  \"张三的年龄在最近的十年里有何变化？\"\n]", "processed_llm_output": "[\n  \"张三现在的具体年龄是多少？\",\n  \"张三从出生到现在是多少岁？\",\n  \"张三的年龄在最近的十年里有何变化？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:42.512143+00:00", "interaction_id": "8909caed-9d31-4dbe-89a0-9a545d4834db"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:43.837403+00:00", "interaction_id": "cea2b530-371c-411e-9303-263c27d6d9d4"}
{"task_type": "cypher_generation", "user_query": "张三现在的具体年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三现在的具体年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:46.048483+00:00", "interaction_id": "7211e475-6a42-4cab-b5e6-565081ec33c4"}
{"task_type": "cypher_generation", "user_query": "张三从出生到现在是多少岁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三从出生到现在是多少岁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:48.242972+00:00", "interaction_id": "e6bd26bd-1764-4fe5-b631-77ff2dd0bd16"}
{"task_type": "cypher_generation", "user_query": "张三的年龄在最近的十年里有何变化？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄在最近的十年里有何变化？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:50.441110+00:00", "interaction_id": "0273a9c2-770b-4f89-a268-44094ec9f221"}
{"task_type": "cypher_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的年龄是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:52.605605+00:00", "interaction_id": "2d8baba1-6d99-46fd-aa58-1a4150b6ab26"}
{"task_type": "answer_generation", "user_query": "张三的年龄是多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:55.023936+00:00", "interaction_id": "ddf52dbf-50d0-498f-b474-08e964657cee"}
{"timestamp_utc": "2025-05-31T09:26:55.025906+00:00", "interaction_id": "a7d4ce5d-2068-49ba-9c27-42a8e9ef81dd", "task_type": "rag_query_processing_success", "user_query": "张三的年龄是多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三的年龄是多少？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:55.414689+00:00", "interaction_id": "5098765d-d45a-47d1-9a52-656d80c0fd28"}
{"task_type": "query_expansion", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的具体预算是多少？\",\n  \"项目Alpha的预算分配是如何确定的？\",\n  \"项目Alpha预算中的每项开支占比是多少？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的具体预算是多少？\",\n  \"项目Alpha的预算分配是如何确定的？\",\n  \"项目Alpha预算中的每项开支占比是多少？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:56.245666+00:00", "interaction_id": "7589fb9b-42fe-41ef-a39d-dd2f8d90d054"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:57.575194+00:00", "interaction_id": "0f5c1b1b-d64c-4fae-9a34-3a686797c4d5"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的具体预算是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的具体预算是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:26:59.815050+00:00", "interaction_id": "bbb46151-f6ef-4a17-aa8e-8fac6aa75da7"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算分配是如何确定的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算分配是如何确定的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:02.010531+00:00", "interaction_id": "1b231cb3-2e21-4831-8055-f64118c8245c"}
{"task_type": "cypher_generation", "user_query": "项目Alpha预算中的每项开支占比是多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha预算中的每项开支占比是多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:04.171704+00:00", "interaction_id": "4b4b3a87-fc00-4bbd-8b84-2ead1f2626a1"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的预算有多少？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:06.334913+00:00", "interaction_id": "037628ee-c7e2-405a-ab47-ae98bd95c0ca"}
{"task_type": "answer_generation", "user_query": "项目Alpha的预算有多少？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:08.751581+00:00", "interaction_id": "77c78022-cdbc-48f2-8a71-2fe26e061c05"}
{"timestamp_utc": "2025-05-31T09:27:08.755945+00:00", "interaction_id": "09472dd9-8ecd-417f-8988-cb9413489271", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的预算有多少？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": -7.51171875, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -7.51171875, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的预算分配是如何确定的？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:09.151174+00:00", "interaction_id": "3c7235c6-46b1-4912-968f-7a64f546028f"}
{"task_type": "query_expansion", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四和王五的工作单位是什么？\",\n  \"李四和王五是否在同一部门工作？\",\n  \"李四和王五的职位级别是否相同？\"\n]", "processed_llm_output": "[\n  \"李四和王五的工作单位是什么？\",\n  \"李四和王五是否在同一部门工作？\",\n  \"李四和王五的职位级别是否相同？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:10.090049+00:00", "interaction_id": "2be3b4ac-7caf-4ad5-8f49-7803b26a0768"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:11.429405+00:00", "interaction_id": "f23edbd8-5bd7-4c8c-a27d-88ffe40ab58e"}
{"task_type": "cypher_generation", "user_query": "李四和王五的工作单位是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五的工作单位是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:13.645843+00:00", "interaction_id": "584a5f57-83cf-452e-ac3e-590911826fef"}
{"task_type": "cypher_generation", "user_query": "李四和王五是否在同一部门工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是否在同一部门工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:15.828300+00:00", "interaction_id": "73e6bc5c-e33a-49e0-990c-19b74faaedda"}
{"task_type": "cypher_generation", "user_query": "李四和王五的职位级别是否相同？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五的职位级别是否相同？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:18.020875+00:00", "interaction_id": "d0a00ae9-8ee0-4462-ac08-68dfe7a1f54b"}
{"task_type": "cypher_generation", "user_query": "李四和王五是同事吗？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四和王五是同事吗？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:20.193235+00:00", "interaction_id": "cddf3543-d954-4647-8d8d-7d39aa181d13"}
{"task_type": "intent_classification", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:20.593714+00:00", "interaction_id": "e1785576-2d02-4267-8236-c8947575785a"}
{"task_type": "query_expansion", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"谷歌公司成立的具体年份是什么？\",\n  \"谷歌公司成立时的创始人是谁？\",\n  \"谷歌公司成立后的主要发展里程碑有哪些？\"\n]", "processed_llm_output": "[\n  \"谷歌公司成立的具体年份是什么？\",\n  \"谷歌公司成立时的创始人是谁？\",\n  \"谷歌公司成立后的主要发展里程碑有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:21.436132+00:00", "interaction_id": "7c84f1cd-1648-40e3-b85d-83e7cdb4ba9e"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:22.763691+00:00", "interaction_id": "a60ef4ce-873b-42d4-82d1-550648351a31"}
{"task_type": "cypher_generation", "user_query": "谷歌公司成立的具体年份是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司成立的具体年份是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:25.019828+00:00", "interaction_id": "c7f8d91d-b63e-402f-ab2c-61c488aaf1d3"}
{"task_type": "cypher_generation", "user_query": "谷歌公司成立时的创始人是谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司成立时的创始人是谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:27.123018+00:00", "interaction_id": "94c84a04-9f12-4ea1-b91b-a44b48018c98"}
{"task_type": "cypher_generation", "user_query": "谷歌公司成立后的主要发展里程碑有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司成立后的主要发展里程碑有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:29.366188+00:00", "interaction_id": "533113be-92bb-4a63-92f5-0a42241119a4"}
{"task_type": "cypher_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 谷歌公司是什么时候成立的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:31.550229+00:00", "interaction_id": "d09765b8-f7ac-4bb1-9319-1f7e55553bd4"}
{"task_type": "answer_generation", "user_query": "谷歌公司是什么时候成立的？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:27:33.951131+00:00", "interaction_id": "d1fca0d7-dc51-4d19-847e-5c16eeeabea2"}
{"timestamp_utc": "2025-05-31T09:27:33.953069+00:00", "interaction_id": "0a2df111-465a-4fcd-97b8-733d697fea6b", "task_type": "rag_query_processing_success", "user_query": "谷歌公司是什么时候成立的？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": -10.1953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": -10.1953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "谷歌公司成立后的主要发展里程碑有哪些？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:22.770573+00:00", "interaction_id": "80e9fac5-4ae7-4bda-92ec-7b3c019ea18e"}
{"task_type": "query_expansion", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"张三目前的工作地点是哪里？\",\n  \"张三最近一次工作地点变更是什么时候？\",\n  \"张三过去五年的工作单位有哪些？\"\n]", "processed_llm_output": "[\n  \"张三目前的工作地点是哪里？\",\n  \"张三最近一次工作地点变更是什么时候？\",\n  \"张三过去五年的工作单位有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:23.645279+00:00", "interaction_id": "f10bc5b9-2222-404b-ad9c-238393c61600"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:25.817651+00:00", "interaction_id": "11a8725c-9573-43ab-bf76-9520eff8d8c1"}
{"task_type": "cypher_generation", "user_query": "张三目前的工作地点是哪里？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三目前的工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:27.974511+00:00", "interaction_id": "dd94781e-f353-46db-963d-3a3c81a3e45f"}
{"task_type": "cypher_generation", "user_query": "张三最近一次工作地点变更是什么时候？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三最近一次工作地点变更是什么时候？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:29.332313+00:00", "interaction_id": "05421bec-c96b-49c4-9976-bec5ff6ce75a"}
{"task_type": "cypher_generation", "user_query": "张三过去五年的工作单位有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三过去五年的工作单位有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org.label = 'ORGANIZATION' AND org.text NOT IN collect(distinct nodes((p)-[:WORKS_AT]->()-[:WORKS_AT]->(org2:ExtractedEntity {label: 'ORGANIZATION'} WHERE org2.year < year(node) - 5))) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org.label = 'ORGANIZATION' AND org.text NOT IN collect(distinct nodes((p)-[:WORKS_AT]->()-[:WORKS_AT]->(org2:ExtractedEntity {label: 'ORGANIZATION'} WHERE org2.year < year(node) - 5))) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:33.683361+00:00", "interaction_id": "c49b1567-17af-4b84-a6db-07703851fa30"}
{"task_type": "cypher_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "processed_llm_output": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:35.892321+00:00", "interaction_id": "3862b288-7695-4f3b-91b0-c71c2da5ab26"}
{"task_type": "answer_generation", "user_query": "张三在哪里工作？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:37.473756+00:00", "interaction_id": "3b0d3d1c-fff6-4d0d-b716-fabade0dc2e9"}
{"timestamp_utc": "2025-05-31T09:44:37.475300+00:00", "interaction_id": "c6d265c1-fce8-4c25-ac55-75263e67f5eb", "task_type": "rag_query_processing_success", "user_query": "张三在哪里工作？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "391bc951a2906b739c1754b050b7420c", "retrieved_documents_summary": [{"source": "vector_chroma", "score": 6.6953125, "id": null, "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}], "retrieved_context_docs": [{"source_type": "vector_chroma", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 6.6953125, "metadata": {"chunk_char_length": 29, "chunk_number": 1, "chunk_text": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "filename": "doc1.txt", "size_bytes": 77, "source_directory": "/home/zhz/zhz_agent/zhz_agent_data_source", "total_chunks_for_doc": 1, "original_query_part": "张三目前的工作地点是哪里？"}}], "final_context_docs_count": 1, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:37.862343+00:00", "interaction_id": "4650b32f-a8af-452f-85b2-56bc9e38de3c"}
{"task_type": "query_expansion", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"项目Alpha的文档编写任务是什么时候分配的？\",\n  \"项目Alpha的文档编写任务最终由谁完成？\",\n  \"项目Alpha的文档编写任务是否有人被指定为负责人？\"\n]", "processed_llm_output": "[\n  \"项目Alpha的文档编写任务是什么时候分配的？\",\n  \"项目Alpha的文档编写任务最终由谁完成？\",\n  \"项目Alpha的文档编写任务是否有人被指定为负责人？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:38.926237+00:00", "interaction_id": "213b0c07-e5e2-4999-91a5-fed50d483f59"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:41.159915+00:00", "interaction_id": "e912a20d-3140-4ca4-9e1b-7f1612cd7656"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务是什么时候分配的？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务是什么时候分配的？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName, task.assigned_date AS assignedDate", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName, task.assigned_date AS assignedDate", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:43.537269+00:00", "interaction_id": "cf9c9da9-665b-40f4-8c15-a0c891c4cf95"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务最终由谁完成？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务最终由谁完成？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'})-[:FINISHED_BY]->(completed_by:ExtractedEntity {label: 'PERSON'}) RETURN completed_by.text AS completedPersonName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'})-[:FINISHED_BY]->(completed_by:ExtractedEntity {label: 'PERSON'}) RETURN completed_by.text AS completedPersonName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:46.305060+00:00", "interaction_id": "a3c3a82d-240d-4740-ad9d-1043ae9145e5"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务是否有人被指定为负责人？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务是否有人被指定为负责人？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName IS NOT NULL AS hasResponsible人员被指定为负责人", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName IS NOT NULL AS hasResponsible人员被指定为负责人", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:48.859722+00:00", "interaction_id": "9fb58f21-7e47-497a-a6b7-03c4668da544"}
{"task_type": "cypher_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "processed_llm_output": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:51.125620+00:00", "interaction_id": "8f2938e5-5bc8-4393-bcc8-9be7bca73364"}
{"task_type": "answer_generation", "user_query": "项目Alpha的文档编写任务分配给了谁？", "llm_input_prompt": "\n<|im_start|>system\n你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。\n\n**核心指令：**\n\n1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。\n2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。\n3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：\n    \"根据目前提供的资料，我无法找到关于您问题的明确信息。\"\n    **不要添加任何其他解释、建议或反问。**\n\n**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**\n<|im_start|>user\n用户问题: {USER_QUESTION}\n\n上下文信息:\n{CONTEXT}\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.05, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>", "<|im_endofunable|>"]}, "raw_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "processed_llm_output": "根据目前提供的资料，我无法找到关于您问题的明确信息。", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:52.688597+00:00", "interaction_id": "67136014-966b-444e-92a2-319a86ce5c06"}
{"timestamp_utc": "2025-05-31T09:44:52.691084+00:00", "interaction_id": "dca7b802-f993-4189-986f-66c39b2294ff", "task_type": "rag_query_processing_success", "user_query": "项目Alpha的文档编写任务分配给了谁？", "processed_llm_output": "根据您提供的信息，我暂时无法给出明确的回答。", "retrieved_context_hash": "5af962307c33de17029190bba9ffd195", "retrieved_documents_summary": [{"source": "keyword_bm25s", "score": 9.2578125, "id": "093784c0-6712-4f28-9ec7-633423b74d07", "content_preview": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。..."}, {"source": "keyword_bm25s", "score": -10.1953125, "id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "content_preview": "第二个文档讨论了自然语言处理技术。..."}], "retrieved_context_docs": [{"source_type": "keyword_bm25s", "content": "项目Alpha的文档编写任务分配给了张三。张三在谷歌工作。", "score": 9.2578125, "metadata": {"chunk_id": "093784c0-6712-4f28-9ec7-633423b74d07", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}, {"source_type": "keyword_bm25s", "content": "第二个文档讨论了自然语言处理技术。", "score": -10.1953125, "metadata": {"chunk_id": "9ea0d0aa-94c9-40c4-a39e-2a8b842cc4df", "original_query_part": "项目Alpha的文档编写任务分配给了谁？"}}], "final_context_docs_count": 2, "application_version": "0.1.0"}
{"task_type": "intent_classification", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:53.099883+00:00", "interaction_id": "5d40ef40-d0b2-4fc6-ad12-481f44d71713"}
{"task_type": "query_expansion", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"李四具体承担了哪些工作任务？\",\n  \"李四在过去一年中完成的任务有哪些？\",\n  \"李四目前负责的项目或任务有哪些？\"\n]", "processed_llm_output": "[\n  \"李四具体承担了哪些工作任务？\",\n  \"李四在过去一年中完成的任务有哪些？\",\n  \"李四目前负责的项目或任务有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:54.019252+00:00", "interaction_id": "f6ee8f5f-a228-4a9e-889a-4eddc5940b36"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:56.199444+00:00", "interaction_id": "04362dbd-0829-4e92-958e-91b4c124107d"}
{"task_type": "cypher_generation", "user_query": "李四具体承担了哪些工作任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四具体承担了哪些工作任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:44:58.204434+00:00", "interaction_id": "bc00c7e3-fee3-43ae-a7f3-98bef349e9ed"}
{"task_type": "cypher_generation", "user_query": "李四在过去一年中完成的任务有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在过去一年中完成的任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task)-[:COMPLETED_IN]->(year:Year {text: '过去一年', label: 'YEAR'}) RETURN task.text AS taskName, year.text AS completionYear", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task)-[:COMPLETED_IN]->(year:Year {text: '过去一年', label: 'YEAR'}) RETURN task.text AS taskName, year.text AS completionYear", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:00.946560+00:00", "interaction_id": "02cae75d-35e9-435b-a451-4862d2cfa636"}
{"task_type": "cypher_generation", "user_query": "李四目前负责的项目或任务有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四目前负责的项目或任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:02.972850+00:00", "interaction_id": "861ab6c5-2d71-4cc9-9ad6-6aa298aae3f0"}
{"task_type": "cypher_generation", "user_query": "李四负责哪些任务？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "processed_llm_output": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:05.335576+00:00", "interaction_id": "6a81098d-790e-478e-bd4f-53b373d1d3ba"}
{"task_type": "intent_classification", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:05.758019+00:00", "interaction_id": "92e5c086-564b-4056-bcc6-24371289760c"}
{"task_type": "query_expansion", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是一个专家查询分析师。根据用户提供的查询，生成3个不同但相关的子问题，以探索原始查询的不同方面。这些子问题将用于检索更全面的信息。\n你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（子问题）。\n只输出JSON数组，不要包含任何其他解释、对话标记或代码块。\n\n示例:\n用户查询: \"公司年度财务报告和未来一年的预算规划\"\n助手:\n[\n  \"公司最近的年度财务报告总结是什么？\",\n  \"未来一年的详细预算规划有哪些主要构成？\",\n  \"对比往年，公司财务状况有何显著变化？\"\n]\n<|im_end|>\n<|im_start|>user\n原始查询: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.7, "max_new_tokens": 512, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "[\n  \"市场部具体有哪些员工？\",\n  \"市场部员工的岗位职责是什么？\",\n  \"市场部员工的招聘和晋升政策有哪些？\"\n]", "processed_llm_output": "[\n  \"市场部具体有哪些员工？\",\n  \"市场部员工的岗位职责是什么？\",\n  \"市场部员工的招聘和晋升政策有哪些？\"\n]", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:06.605153+00:00", "interaction_id": "f15259c6-8a29-4c6a-b0fa-95533221627b"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:08.873537+00:00", "interaction_id": "f1c02071-183a-4db8-961a-5b8e50c0d82a"}
{"task_type": "cypher_generation", "user_query": "市场部具体有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部具体有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:11.130407+00:00", "interaction_id": "03ceebf1-ebbf-4b33-9680-e9e0e57aa41c"}
{"task_type": "cypher_generation", "user_query": "市场部员工的岗位职责是什么？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的岗位职责是什么？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:12.456683+00:00", "interaction_id": "7c5b21ac-62b9-4637-af82-3e785ff5d268"}
{"task_type": "cypher_generation", "user_query": "市场部员工的招聘和晋升政策有哪些？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的招聘和晋升政策有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "", "processed_llm_output": "", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:14.664165+00:00", "interaction_id": "4734c97c-25c8-480e-9867-ad4d14aa43a1"}
{"task_type": "cypher_generation", "user_query": "市场部有哪些员工？", "llm_input_prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.0, "max_new_tokens": 400, "stop_sequences": ["<|im_end|>", "无法生成Cypher查询。"]}, "raw_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "processed_llm_output": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text = '市场部' RETURN e.text AS employeeName", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:17.755947+00:00", "interaction_id": "bd592fa2-1995-4f8c-8356-817bda842306"}
{"task_type": "intent_classification", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 列出所有类型为TASK的实体。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体、特定文档中的TASK实体等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体、特定文档中的TASK实体等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:18.968136+00:00", "interaction_id": "6c6c1c4a-6fd8-4f27-b22a-241e0da0f03b"}
{"task_type": "clarification_question_generation", "user_query": "列出所有类型为TASK的实体。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 列出所有类型为TASK的实体。\n不确定性原因: 缺少具体实体类型（如TASK）的明确上下文，以及需要列出的实体的具体范围（如数据库中的所有TASK实体、特定文档中的TASK实体等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "在哪个数据库或文档中列出所有类型为TASK的实体？", "processed_llm_output": "在哪个数据库或文档中列出所有类型为TASK的实体？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:19.355413+00:00", "interaction_id": "d997e87b-9b27-470f-9b05-099f3d0db1e3"}
{"task_type": "intent_classification", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查询所有在创新科技公司工作的员工。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:20.229448+00:00", "interaction_id": "0daebb2f-3fb3-4695-b420-856dddd6a398"}
{"task_type": "clarification_question_generation", "user_query": "查询所有在创新科技公司工作的员工。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查询所有在创新科技公司工作的员工。\n不确定性原因: 缺少具体公司名称，以及查询范围（所有员工还是特定部门/职位的员工等）。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您想查询哪家创新科技公司的员工？是所有员工还是特定部门/职位的员工？", "processed_llm_output": "请问您想查询哪家创新科技公司的员工？是所有员工还是特定部门/职位的员工？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:20.768946+00:00", "interaction_id": "9e691355-ecc4-4765-ae90-26589322f61c"}
{"task_type": "intent_classification", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 查找所有人员的名称。\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体需要查询的人员类别或部门等信息。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:21.453423+00:00", "interaction_id": "4bd9cd0b-d028-4a8f-9334-8e013b41791f"}
{"task_type": "clarification_question_generation", "user_query": "查找所有人员的名称。", "llm_input_prompt": "<|im_start|>system\n你是一个智能助手，擅长在理解用户查询时识别歧义并请求澄清。\n你的任务是根据用户原始查询和系统检测到的不确定性原因，生成一个简洁、明确的澄清问题。\n澄清问题应该帮助用户选择正确的意图，或者提供更多必要的信息。\n只输出澄清问题，不要包含任何额外解释、对话标记或代码块。\n<|im_end|>\n<|im_start|>user\n用户原始查询: 查找所有人员的名称。\n不确定性原因: 缺少具体需要查询的人员类别或部门等信息。\n\n请生成一个澄清问题:\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.5, "max_new_tokens": 128, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "请问您是想查询全体员工的名称还是某特定部门的人员名称？", "processed_llm_output": "请问您是想查询全体员工的名称还是某特定部门的人员名称？", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:21.883563+00:00", "interaction_id": "e677aedc-3aaf-4550-b2f4-087e00adb276"}
{"task_type": "intent_classification", "user_query": "有多少个组织类型的实体？", "llm_input_prompt": "<|im_start|>system\n你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。\n如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。\n只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。\n\n如果查询需要澄清，请说明原因。\n你的回答必须是一个JSON对象，包含两个字段：\n1. \"clarification_needed\": 布尔值，如果需要澄清则为 true，否则为 false。\n2. \"reason\": 字符串，如果需要澄清，请简要说明原因；如果不需要，则为空字符串。\n\n示例1 (需要澄清 - 信息不足):\n用户查询: \"帮我预定明天去上海的机票。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。\"\n}\n\n示例2 (不需要澄清 - 清晰):\n用户查询: \"公司最新的销售额报告在哪里可以找到？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例3 (需要澄清 - 实体不明确):\n用户查询: \"关于项目进展的文档。\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"项目名称不明确，文档类型（报告、计划、会议纪要等）不明确。\"\n}\n\n示例4 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"张三参与了哪个项目？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例5 (不需要澄清 - 包含具体实体和明确问题):\n用户查询: \"华东区域2024年第一季度的销售额是多少？\"\n助手:\n{\n  \"clarification_needed\": false,\n  \"reason\": \"\"\n}\n\n示例6 (需要澄清 - “公司”指默认上下文，但其余部分仍模糊):\n用户查询: \"公司的政策\"\n助手:\n{\n  \"clarification_needed\": true,\n  \"reason\": \"未能明确指出是关于哪方面的公司政策（例如：人力资源、IT安全、财务等）。\"\n}\n<|im_end|>\n<|im_start|>user\n用户查询: 有多少个组织类型的实体？\n<|im_end|>\n<|im_start|>assistant\n", "llm_parameters": {"model": "qwen2.5-3b-instruct", "temperature": 0.01, "max_new_tokens": 256, "stop_sequences": ["<|im_end|>"]}, "raw_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "processed_llm_output": "{\n  \"clarification_needed\": true,\n  \"reason\": \"缺少具体组织类型或上下文信息，无法确定需要统计的组织类型数量。\"\n}", "application_version": "0.1.0", "timestamp_utc": "2025-05-31T09:45:22.727144+00:00", "interaction_id": "77ea5d9a-7fad-44e9-85f5-7aa27b659a4d"}
