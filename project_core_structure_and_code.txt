# Core Directories Structure and Code for Project: /home/zhz/zhz_agent

--- Structure and Code for: zhz_rag_pipeline_dagster/ ---
|-- zhz_rag_pipeline/
|-- zhz_rag_pipeline_dagster_project.egg-info/
|-- pyproject.toml
|-- setup.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/setup.py
from setuptools import find_packages, setup

setup(
    name="zhz_rag_pipeline_dagster_project", # 给一个包名
    version="0.0.1",
    packages=find_packages(), # 会找到 zhz_rag_pipeline 这个包
    install_requires=[
        "dagster",
        "dagster-webserver",
        # 添加其他 zhz_rag_pipeline_dagster 项目直接依赖的库
        # 例如 kuzu, dagster-pydantic (如果之后还要用) 等
        # 但核心的 zhz_rag 包的依赖不在这里列出，它应该是独立安装的
    ],
)
```

    |-- parsers/
    |-- __init__.py

``` py
# zhz_rag_pipeline/__init__.py
# This file makes Python treat the directory as a package.
# You can also define a __version__ or import key modules here if needed.
```

    |-- custom_io_managers.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/custom_io_managers.py
import json
import os
from typing import List, Type, Union, get_args, get_origin, Any, Optional 
from dagster import UPathIOManager, InputContext, OutputContext, DagsterInvariantViolationError
from pydantic import BaseModel as PydanticBaseModel
from upath import UPath

class PydanticListJsonIOManager(UPathIOManager):
    extension: str = ".jsonl"

    def __init__(self, base_dir: Optional[str] = None): # Changed base_path to base_dir for clarity
        resolved_base_dir: UPath
        if base_dir:
            resolved_base_dir = UPath(base_dir).resolve() # Resolve to absolute path
        else:
            # Default to <DAGSTER_HOME>/storage/pydantic_jsonl_io
            # DAGSTER_HOME defaults to ~/.dagster, but can be overridden by env var
            dagster_home_str = os.getenv("DAGSTER_HOME", os.path.join(os.path.expanduser("~"), ".dagster"))
            resolved_base_dir = UPath(dagster_home_str) / "storage" / "pydantic_jsonl_io"
        
        # Ensure the directory exists
        try:
            resolved_base_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            # Log this error appropriately, perhaps using a direct print if logger isn't set up yet
            # or re-raise as a Dagster-specific error.
            print(f"[PydanticListJsonIOManager __init__] ERROR: Could not create bafef __init__(self, base_dir: Optse directory {resolved_base_dir}: {e}")
            # Depending on Dagster's init sequence, context.log might not be available here.
            # It's safer to let UPathIOManager handle its own base_path or ensure dir exists before.
            # For now, we proceed, UPathIOManager might handle it or fail later.

        super().__init__(base_path=resolved_base_dir)
        # Log the final base path used by the UPathIOManager instance
        # self.log available after super().__init__() in ConfigurableIOManager context
        # For direct instantiation, we might need to pass a logger or use a global one.
        # print(f"[PydanticListJsonIOManager __init__] Initialized with resolved base_path: {self.base_path}")


    def dump_to_path(self, context: OutputContext, obj: List[PydanticBaseModel], path: UPath):
        context.log.info(f"[PydanticListJsonIOManager dump_to_path] Attempting to dump to resolved path: {path.resolve()}")
        
        if not isinstance(obj, list):
            msg = f"Expected a list of Pydantic models, got {type(obj)}"
            context.log.error(msg)
            raise TypeError(msg)
        
        # Optional: More robust type checking for list items if needed, using context.dagster_type
        # For now, assume obj is List[PydanticBaseModel] based on upstream asset's type hint.

        try:
            with path.open("w", encoding="utf-8") as f:
                for model_instance in obj:
                    if not isinstance(model_instance, PydanticBaseModel):
                        context.log.warning(f"Item in list is not a Pydantic model: {type(model_instance)}. Skipping.")
                        continue
                    json_str = model_instance.json() # Pydantic V1
                    f.write(json_str + "\n")
            context.log.info(f"[PydanticListJsonIOManager dump_to_path] Successfully dumped {len(obj)} items to {path.resolve()}")
        except Exception as e:
            context.log.error(f"[PydanticListJsonIOManager dump_to_path] Failed to dump object to {path.resolve()}: {e}", exc_info=True)
            raise

    def load_from_path(self, context: InputContext, path: UPath) -> List[PydanticBaseModel]:
        context.log.info(f"[PydanticListJsonIOManager load_from_path] Attempting to load from resolved path: {path.resolve()}")
        
        list_typing_type = context.dagster_type.typing_type
        origin = get_origin(list_typing_type)
        args = get_args(list_typing_type)

        if not (origin is list and args and issubclass(args[0], PydanticBaseModel)):
            msg = (
                f"PydanticListJsonIOManager can only handle inputs of type List[PydanticModel], "
                f"but got {list_typing_type} for input '{context.name}'."
            )
            context.log.error(msg)
            raise DagsterInvariantViolationError(msg) # Use Dagster specific error
        
        model_type: Type[PydanticBaseModel] = args[0]
        context.log.info(f"[PydanticListJsonIOManager load_from_path] Target model type for list items: {model_type.__name__}")

        loaded_models: List[PydanticBaseModel] = []
        if not path.exists():
            context.log.warning(f"[PydanticListJsonIOManager load_from_path] File not found at {path.resolve()}, returning empty list for input '{context.name}'.")
            return loaded_models

        try:
            with path.open("r", encoding="utf-8") as f:
                for line_number, line in enumerate(f, 1):
                    line_content = line.strip()
                    if not line_content:
                        continue
                    try:
                        model_instance = model_type.parse_raw(line_content) # Pydantic V1
                        loaded_models.append(model_instance)
                    except Exception as e_parse:
                        context.log.error(
                            f"[PydanticListJsonIOManager load_from_path] Failed to parse JSON line {line_number} "
                            f"into {model_type.__name__} from {path.resolve()}: {e_parse}. "
                            f"Line content (first 100 chars): '{line_content[:100]}...'",
                            exc_info=True
                        )
                        # Optionally re-raise or decide to skip problematic lines
                        # For now, we'll skip
            context.log.info(f"[PydanticListJsonIOManager load_from_path] Successfully loaded {len(loaded_models)} instances of {model_type.__name__} from {path.resolve()}")
        except Exception as e_read:
            context.log.error(f"[PydanticListJsonIOManager load_from_path] Failed to read or process file {path.resolve()}: {e_read}", exc_info=True)
            raise # Re-raise if file reading itself fails catastrophically
            
        return loaded_models
```

    |-- definitions.py

``` py
import dagster as dg
import os
from dagster import Definitions

from zhz_rag_pipeline_dagster.zhz_rag_pipeline.ingestion_assets import all_ingestion_assets
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.processing_assets import all_processing_assets

from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import (
    GGUFEmbeddingResource,
    ChromaDBResource,
    LocalLLMAPIResource,
    DuckDBResource,
    GeminiAPIResource,
    SystemResource
)
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.custom_io_managers import PydanticListJsonIOManager

# --- 根据官方文档，将所有资产组合在一起 ---
all_assets = all_ingestion_assets + all_processing_assets

# --- 根据官方文档，定义一个包含所有资源的字典 ---
# Dagster 会自动为每个资产提供它所需要的资源
all_resources = {
    # IO 管理器，键名必须是 "io_manager" 才能被默认使用
    "io_manager": PydanticListJsonIOManager(),
    
    # 其他应用级资源
    "embedder": GGUFEmbeddingResource(
        api_url=os.getenv("EMBEDDING_API_URL", "http://127.0.0.1:8089")
    ),
    "chroma_db": ChromaDBResource(
        collection_name=os.getenv("CHROMA_COLLECTION_NAME", "zhz_rag_collection"),
        persist_directory=os.path.join(os.getenv("ZHZ_AGENT_PROJECT_ROOT", "/home/zhz/zhz_agent"), "zhz_rag", "stored_data", "chromadb_index")
    ),
    "LocalLLM_api": LocalLLMAPIResource(
        api_url="http://127.0.0.1:8088/v1/chat/completions",
        default_temperature=0.1,
        default_max_new_tokens=2048
    ),
    "duckdb_kg": DuckDBResource(
        db_file_path=os.path.join(os.getenv("ZHZ_AGENT_PROJECT_ROOT", "/home/zhz/zhz_agent"), "zhz_rag", "stored_data", "duckdb_knowledge_graph.db")
    ),
    "gemini_api": GeminiAPIResource(
        model_name="gemini/gemini-1.5-flash-latest",
        proxy_url=os.getenv("LITELLM_PROXY_URL"),
        default_temperature=0.1,
        default_max_tokens=2048
    ),
    "system_resource": SystemResource()
}

# --- 创建最终的、简洁的 Definitions 对象 ---
defs = Definitions(
    assets=all_assets,
    resources=all_resources
)
```

    |-- document_parsers.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/document_parsers.py
import os
from markdown_it import MarkdownIt
import logging
from typing import List, Dict, Any, Optional, Union, Literal 
from bs4 import BeautifulSoup
import pandas as pd

# --- 添加 Unstructured 的导入 ---
try:
    from unstructured.partition.docx import partition_docx
    from unstructured.documents.elements import Element as UnstructuredElement, Title, NarrativeText, ListItem, Table, Image, Header, Footer
    _UNSTRUCTURED_AVAILABLE = True
    print("INFO (document_parsers.py): Successfully imported Unstructured for DOCX.")
except ImportError:
    print("WARNING (document_parsers.py): Unstructured library not found. DOCX parsing will be a placeholder.")
    _UNSTRUCTURED_AVAILABLE = False
    class UnstructuredElement: pass # Dummy
# --- 结束添加 ---

# --- 导入我们定义的Pydantic模型 ---
# 假设这个文件和 pydantic_models_dagster.py 在同一个包下或能通过PYTHONPATH找到
try:
    from .pydantic_models_dagster import ( # 使用相对导入
        ParsedDocumentOutput,
        DocumentElementType, 
        TitleElement,
        NarrativeTextElement,
        ListItemElement,
        TableElement,
        CodeBlockElement,
        PageBreakElement,
        DocumentElementMetadata 
    )
    _PYDANTIC_MODELS_AVAILABLE_PARSERS = True
except ImportError:
    print("WARNING (document_parsers.py): Could not import Pydantic models. Using fallback Any/dict.")
    _PYDANTIC_MODELS_AVAILABLE_PARSERS = False
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class TitleElement(BaseModel): element_type:str="title"; text:str; level:int; metadata: Optional[DocumentElementMetadata] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class ListItemElement(BaseModel): element_type:str="list_item"; text:str; level:int=0; ordered:bool=False; item_number:Optional[Union[int, str]]=None; metadata: Optional[DocumentElementMetadata] = None
    class TableElement(BaseModel): element_type:str="table"; markdown_representation:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class CodeBlockElement(BaseModel): element_type:str="code_block"; code:str; language:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class PageBreakElement(BaseModel): element_type:str="page_break"; metadata: Optional[DocumentElementMetadata] = None
    DocumentElementType = Any


logger = logging.getLogger(__name__) # 每个模块用自己的logger

# --- Markdown 解析逻辑 (从 poc_md_markdown_it.py 迁移并封装) ---



def _get_text_from_md_inline(inline_tokens: Optional[List[Any]]) -> str:
    # (这里是 get_text_from_inline_tokens 函数的完整代码)
    text_content = ""
    if inline_tokens is None: return ""
    for token in inline_tokens:
        if token.type == 'text':
            text_content += token.content
        elif token.type == 'code_inline':
            text_content += f"`{token.content}`"
        elif token.type == 'softbreak':
            text_content += ' ' 
        elif token.type == 'hardbreak':
            text_content += '\n'
        elif token.children: 
            text_content += _get_text_from_md_inline(token.children)
    return text_content

def _convert_md_tokens_to_elements_internal(tokens: list) -> List[Any]:
    # (这里是 convert_md_tokens_to_elements 函数的完整代码，但将其重命名为内部函数)
    # (并确保它在 _PYDANTIC_MODELS_AVAILABLE_PARSERS 为True时创建Pydantic实例，否则创建字典)
    elements: List[Any] = []
    idx = 0
    list_level_stack = [] 

    while idx < len(tokens):
        token = tokens[idx]

        if token.type == 'heading_open':
            level = int(token.tag[1:])
            idx_content = idx + 1
            text = ""
            if idx_content < len(tokens) and tokens[idx_content].type == 'inline':
                text = _get_text_from_md_inline(tokens[idx_content].children).strip()
            if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(TitleElement(text=text, level=level))
            else: elements.append({"element_type": "title", "text": text, "level": level})
            idx = idx_content + 2 
            continue

        elif token.type == 'paragraph_open':
            is_list_item_para = False
            if list_level_stack and token.level >= list_level_stack[-1]["level"]:
                pass 
            if not is_list_item_para or not list_level_stack: 
                idx_content = idx + 1
                text = ""
                if idx_content < len(tokens) and tokens[idx_content].type == 'inline':
                    text = _get_text_from_md_inline(tokens[idx_content].children).strip()
                if text:
                    if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(NarrativeTextElement(text=text))
                    else: elements.append({"element_type": "narrative_text", "text": text})
            idx = idx + 2 
            if idx < len(tokens) and tokens[idx-1].type == 'inline': 
                idx +=1 
            continue
        
        elif token.type == 'bullet_list_open':
            list_level_stack.append({"ordered": False, "level": token.level})
            idx += 1
            continue
        elif token.type == 'ordered_list_open':
            start_num = token.attrs.get('start', 1)
            list_level_stack.append({"ordered": True, "current_num": start_num, "level": token.level})
            idx += 1
            continue
        
        elif token.type == 'list_item_open':
            item_text = ""
            li_level = token.level
            next_token_idx = idx + 1
            if next_token_idx < len(tokens):
                next_token = tokens[next_token_idx]
                if next_token.type == 'paragraph_open' and next_token.level == li_level + 1 :
                    inline_idx = next_token_idx + 1
                    if inline_idx < len(tokens) and tokens[inline_idx].type == 'inline':
                        item_text = _get_text_from_md_inline(tokens[inline_idx].children).strip()
                elif next_token.type == 'inline' and next_token.level == li_level +1 :
                    item_text = _get_text_from_md_inline(next_token.children).strip()
            
            if list_level_stack:
                list_info = list_level_stack[-1]
                item_num_val = None
                if list_info["ordered"]:
                    item_num_val = list_info["current_num"]
                    list_info["current_num"] += 1
                
                if _PYDANTIC_MODELS_AVAILABLE_PARSERS:
                    elements.append(ListItemElement(
                        text=item_text, level=token.level, ordered=list_info["ordered"],
                        item_number=str(item_num_val) if item_num_val is not None else None))
                else:
                    elements.append({"element_type": "list_item", "text": item_text, "level":token.level, 
                                     "ordered":list_info["ordered"], "item_number":str(item_num_val) if item_num_val is not None else None})

            temp_idx = idx + 1; nesting_count = 0
            while temp_idx < len(tokens):
                if tokens[temp_idx].type == 'list_item_open' and tokens[temp_idx].level == li_level:
                    if nesting_count == 0: idx = temp_idx; break
                if tokens[temp_idx].type == 'list_item_open': nesting_count +=1
                if tokens[temp_idx].type == 'list_item_close':
                    if nesting_count == 0 and tokens[temp_idx].level == li_level: idx = temp_idx + 1; break
                    nesting_count -=1
                temp_idx += 1
            else: idx = temp_idx
            continue

        elif token.type in ['bullet_list_close', 'ordered_list_close']:
            if list_level_stack: list_level_stack.pop()
            idx += 1
            continue

        elif token.type == 'table_open':
            header_content = []; body_rows_cells = []; current_row_cells = []; in_thead = False
            temp_idx = idx + 1
            while temp_idx < len(tokens) and tokens[temp_idx].type != 'table_close':
                t_token = tokens[temp_idx]
                if t_token.type == 'thead_open': in_thead = True
                elif t_token.type == 'thead_close': in_thead = False
                elif t_token.type == 'tr_open': current_row_cells = []
                elif t_token.type in ['th_open', 'td_open']:
                    content_idx = temp_idx + 1
                    if content_idx < len(tokens) and tokens[content_idx].type == 'inline':
                        current_row_cells.append(_get_text_from_md_inline(tokens[content_idx].children).strip())
                elif t_token.type == 'tr_close':
                    if current_row_cells:
                        if in_thead or (not header_content and not body_rows_cells): header_content.append(list(current_row_cells))
                        else: body_rows_cells.append(list(current_row_cells))
                temp_idx += 1
            md_table_str = ""
            if header_content:
                md_table_str += "| " + " | ".join(header_content[0]) + " |\n"
                md_table_str += "| " + " | ".join(["---"] * len(header_content[0])) + " |\n"
            for row_data_list in body_rows_cells: md_table_str += "| " + " | ".join(row_data_list) + " |\n"
            if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(TableElement(markdown_representation=md_table_str.strip()))
            else: elements.append({"element_type": "table", "markdown_representation": md_table_str.strip()})
            idx = temp_idx + 1 
            continue

        elif token.type == 'fence' or token.type == 'code_block':
            code_content = token.content.strip(); lang = token.info.strip() if token.info else None
            if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(CodeBlockElement(code=code_content, language=lang))
            else: elements.append({"element_type": "code_block", "code": code_content, "language": lang})
            idx += 1
            continue
        
        elif token.type == 'hr':
            if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(PageBreakElement())
            else: elements.append({"element_type": "page_break"})
            idx += 1
            continue
        
        elif token.type == 'blockquote_open':
            blockquote_text_parts = []; temp_idx = idx + 1; start_level = token.level
            while temp_idx < len(tokens):
                bq_token = tokens[temp_idx]
                if bq_token.type == 'blockquote_close' and bq_token.level == start_level: idx = temp_idx; break
                if bq_token.type == 'paragraph_open':
                    para_content_idx = temp_idx + 1
                    if para_content_idx < len(tokens) and tokens[para_content_idx].type == 'inline':
                        blockquote_text_parts.append(_get_text_from_md_inline(tokens[para_content_idx].children).strip())
                    temp_idx = para_content_idx + 1 
                    if temp_idx < len(tokens) and tokens[temp_idx].type == 'paragraph_close': temp_idx +=1
                    else: temp_idx -=1
                temp_idx +=1
            else: idx = temp_idx
            if blockquote_text_parts:
                full_text = "\n".join(blockquote_text_parts)
                if _PYDANTIC_MODELS_AVAILABLE_PARSERS: elements.append(NarrativeTextElement(text=full_text)) 
                else: elements.append({"element_type": "narrative_text", "text": full_text, "_is_blockquote": True})
            idx +=1
            continue
        idx += 1 
    return elements

def _generate_parsed_text_from_elements_internal(elements: List[Any]) -> str:
    # (这里是 generate_parsed_text_from_elements 函数的完整代码)
    # (确保它在 _PYDANTIC_MODELS_AVAILABLE_PARSERS 为True时能处理Pydantic实例，否则处理字典)
    text_parts = []
    for el_data_any in elements:
        el_data = {}
        if _PYDANTIC_MODELS_AVAILABLE_PARSERS and hasattr(el_data_any, 'model_dump'):
            el_data = el_data_any.model_dump() 
        elif isinstance(el_data_any, dict):
            el_data = el_data_any
        else: continue

        el_type = el_data.get("element_type")
        if el_type == "title": text_parts.append(f"\n{'#' * el_data.get('level',1)} {el_data.get('text','')}\n")
        elif el_type == "narrative_text": text_parts.append(el_data.get('text','') + "\n")
        elif el_type == "list_item":
            prefix = f"{el_data.get('item_number','')}. " if el_data.get('ordered') and el_data.get('item_number') else "- "
            indent = "  " * el_data.get('level',0)
            text_parts.append(f"{indent}{prefix}{el_data.get('text','')}\n")
        elif el_type == "table":
            if el_data.get('markdown_representation'): text_parts.append(f"\n[Table: {el_data.get('caption','Unnamed Table')}]\n{el_data['markdown_representation']}\n")
            elif el_data.get('text_representation'): text_parts.append(f"\n[Table: {el_data.get('caption','Unnamed Table')}]\n{el_data['text_representation']}\n")
        elif el_type == "code_block":
            lang = el_data.get('language', "") or ""
            text_parts.append(f"\n```{lang}\n{el_data.get('code','')}\n```\n")
        elif el_type == "page_break": text_parts.append("\n---\n")
        text_parts.append("\n") 
    return "".join(text_parts).strip().replace("\n\n\n", "\n\n").replace("\n\n\n", "\n\n")

def _convert_unstructured_to_pydantic(elements: List[UnstructuredElement]) -> List[DocumentElementType]:  # type: ignore
    """Converts a list of Unstructured elements to our internal Pydantic models."""
    pydantic_elements = []
    for el in elements:
        meta = DocumentElementMetadata(page_number=getattr(el.metadata, 'page_number', None))
        
        if isinstance(el, Title):
            pydantic_elements.append(TitleElement(text=el.text, level=getattr(el.metadata, 'category_depth', 1), metadata=meta))
        elif isinstance(el, NarrativeText):
            pydantic_elements.append(NarrativeTextElement(text=el.text, metadata=meta))
        elif isinstance(el, ListItem):
            pydantic_elements.append(ListItemElement(text=el.text, metadata=meta))
        elif isinstance(el, Table):
            # Unstructured v0.12+ has built-in markdown conversion
            pydantic_elements.append(TableElement(markdown_representation=getattr(el, 'text_as_html', str(el)), metadata=meta))
        elif isinstance(el, (Header, Footer, Image)):
             # We can choose to ignore headers, footers, and images for now
             continue
        else:
            # Fallback for any other element types
            if el.text.strip():
                 pydantic_elements.append(NarrativeTextElement(text=el.text, metadata=meta))
                 
    return pydantic_elements


def parse_markdown_to_structured_output(md_content_str: str, original_metadata: Dict[str, Any]) -> Optional[ParsedDocumentOutput]:
    """
    Top-level function to parse markdown string and return ParsedDocumentOutput.
    """
    logger.info(f"Parsing Markdown content (length: {len(md_content_str)} chars)...")
    try:
        md_parser = MarkdownIt("commonmark").enable("table") # Removed "breaks":True based on last log
        tokens = md_parser.parse(md_content_str)
        
        structured_elements = _convert_md_tokens_to_elements_internal(tokens)
        linear_text = _generate_parsed_text_from_elements_internal(structured_elements)

        if _PYDANTIC_MODELS_AVAILABLE_PARSERS:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=structured_elements,
                original_metadata=original_metadata
            )
        else: # Fallback if Pydantic models aren't available (e.g. PoC context)
            return {
                 "parsed_text": linear_text,
                 "elements": structured_elements,
                 "original_metadata": original_metadata
            } # type: ignore 
    except Exception as e:
        logger.error(f"Error in parse_markdown_to_structured_output: {e}", exc_info=True)
        return None

# --- Placeholder for other parsers ---
def parse_docx_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[ParsedDocumentOutput]:
    """
    Parses a DOCX file using Unstructured.io, extracts rich metadata,
    and converts elements to our internal Pydantic models.
    """
    if not _UNSTRUCTURED_AVAILABLE:
        logger.error("Unstructured library is not available. Cannot parse DOCX files.")
        return None
        
    logger.info(f"Parsing DOCX with Unstructured: {file_path}")
    
    try:
        # 使用 Unstructured 解析文档，设置策略以获取更干净的数据
        unstructured_elements = partition_docx(
            filename=file_path,
            strategy="hi_res",  # 使用高分辨率策略以更好地处理布局
            infer_table_structure=True, # 开启表格结构推断
        )
        
        # --- 关键：合并 Unstructured 提取的元数据 ---
        # partition_docx 返回的第一个元素通常包含文档级别的元数据
        doc_level_meta = {}
        if unstructured_elements:
             # Unstructured v0.12+ 将元数据附加到每个元素上
             # 我们从第一个元素获取通用元数据
             doc_level_meta = unstructured_elements[0].metadata.to_dict()

        # 将 Unstructured 的元数据与我们传入的原始元数据合并
        # Unstructured 的元数据优先级更高，因为它更具体
        combined_metadata = {**original_metadata, **doc_level_meta}
        # 移除一些不需要的内部键
        combined_metadata.pop('parent_id', None)
        combined_metadata.pop('category_depth', None)

        # 将 Unstructured 元素转换为我们自己的 Pydantic 模型
        pydantic_elements = _convert_unstructured_to_pydantic(unstructured_elements)
        
        if not pydantic_elements:
            logger.warning(f"No content elements were extracted from DOCX file: {file_path}")
            return None

        # 从转换后的元素生成线性文本表示
        linear_text = _generate_parsed_text_from_elements_internal(pydantic_elements)

        if _PYDANTIC_MODELS_AVAILABLE_PARSERS:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=pydantic_elements,
                original_metadata=combined_metadata # <--- 使用合并后的元数据
            )
        else:
            # Fallback for non-pydantic environment (should not happen in production)
            return {
                "parsed_text": linear_text,
                "elements": pydantic_elements,
                "original_metadata": combined_metadata
            } # type: ignore
            
    except Exception as e:
        logger.error(f"Error parsing DOCX file '{file_path}' with Unstructured: {e}", exc_info=True)
        return None
    
def parse_pdf_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[ParsedDocumentOutput]:
    logger.info(f"Parsing PDF: {file_path} (Not yet fully implemented in document_parsers.py)")
    # Here you would integrate the PyMuPDF logic from your PoC
    text_content = f"[Placeholder: PDF content for {os.path.basename(file_path)}]"
    elements = []
    if _PYDANTIC_MODELS_AVAILABLE_PARSERS:
        elements.append(NarrativeTextElement(text=text_content))
        return ParsedDocumentOutput(parsed_text=text_content, elements=elements, original_metadata=original_metadata)
    else:
        elements.append({"element_type":"narrative_text", "text":text_content})
        return {"parsed_text":text_content, "elements":elements, "original_metadata":original_metadata} # type: ignore

def parse_xlsx_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[ParsedDocumentOutput]:
    """
    Parses an XLSX file using pandas, converts each sheet to a Markdown table,
    and enriches metadata with filename and sheet name.
    """
    logger.info(f"Parsing XLSX with pandas: {file_path}")
    
    try:
        xls = pd.ExcelFile(file_path)
        all_elements: List[DocumentElementType] = [] # type: ignore
        full_text_representation = ""

        # --- 核心修正：确保filename在元数据中 ---
        # 无论上游是否提供，我们在这里都以文件路径为准，强制添加/覆盖
        base_metadata = original_metadata.copy()
        base_metadata['filename'] = os.path.basename(file_path)

        for sheet_name in xls.sheet_names:
            try:
                df = pd.read_excel(xls, sheet_name=sheet_name)
                # 过滤掉完全为空的行和列，避免无效的Markdown输出
                df.dropna(how='all', axis=0, inplace=True)
                df.dropna(how='all', axis=1, inplace=True)

                if df.empty:
                    logger.info(f"  Skipping empty sheet: {sheet_name}")
                    continue
                
                # 将DataFrame转换为Markdown格式的字符串
                markdown_table = df.to_markdown(index=False)
                
                # 为每个工作表创建一个标题和一个表格元素
                sheet_title_text = f"Sheet: {sheet_name}"
                full_text_representation += f"## {sheet_title_text}\n\n{markdown_table}\n\n"
                
                # 为工作表标题创建元素
                all_elements.append(TitleElement(
                    text=sheet_title_text,
                    level=2,
                    metadata=DocumentElementMetadata(page_number=xls.sheet_names.index(sheet_name) + 1)
                ))
                
                # 为表格本身创建元素
                sheet_meta = base_metadata.copy()
                sheet_meta['sheet_name'] = sheet_name
                
                all_elements.append(TableElement(
                    markdown_representation=markdown_table,
                    metadata=DocumentElementMetadata(**sheet_meta) # 传递特定于工作表的元数据
                ))
                logger.info(f"  Successfully parsed sheet: {sheet_name}")

            except Exception as e_sheet:
                logger.error(f"  Failed to parse sheet '{sheet_name}' in file '{file_path}': {e_sheet}", exc_info=True)
                continue

        if not all_elements:
            logger.warning(f"No data parsed from any sheet in XLSX file: {file_path}")
            return None
        
        # 返回包含所有工作表内容的单个 ParsedDocumentOutput
        return ParsedDocumentOutput(
            parsed_text=full_text_representation,
            elements=all_elements,
            original_metadata=base_metadata # 返回包含正确filename的文档级元数据
        )

    except Exception as e:
        logger.error(f"Error parsing XLSX file '{file_path}': {e}", exc_info=True)
        return None

def parse_html_to_structured_output(html_content_str: str, original_metadata: Dict[str, Any]) -> Optional[ParsedDocumentOutput]:
    """
    Parses an HTML string using BeautifulSoup, extracts meaningful elements,
    and converts them to our internal Pydantic models.
    """
    logger.info(f"Parsing HTML content with BeautifulSoup (length: {len(html_content_str)} chars)...")
    if not html_content_str.strip():
        return None

    try:
        soup = BeautifulSoup(html_content_str, 'lxml')
        
        for script_or_style in soup(["script", "style"]):
            script_or_style.decompose()

        elements: List[DocumentElementType] = [] # type: ignore
        
        for tag in soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'li', 'pre']):
            text = tag.get_text(separator=' ', strip=True)
            if text:
                if tag.name.startswith('h'):
                    level = int(tag.name[1:])
                    elements.append(TitleElement(text=text, level=level))
                elif tag.name == 'li':
                    elements.append(ListItemElement(text=text))
                elif tag.name == 'pre':
                    elements.append(CodeBlockElement(code=text))
                else:
                    elements.append(NarrativeTextElement(text=text))
        
        for table in soup.find_all('table'):
            header = [th.get_text(strip=True) for th in table.find_all('th')]
            rows = []
            for tr in table.find_all('tr'):
                cells = [td.get_text(strip=True) for td in tr.find_all('td')]
                if cells:
                    rows.append(cells)
            
            if header or rows:
                md_table_parts = []
                if header:
                    md_table_parts.append(f"| {' | '.join(header)} |")
                    md_table_parts.append(f"|{'---|' * len(header)}")
                for row in rows:
                    md_table_parts.append(f"| {' | '.join(row)} |")
                
                elements.append(TableElement(markdown_representation='\n'.join(md_table_parts)))

        if not elements:
            logger.warning("No structured elements found in HTML content after parsing.")
            return None

        linear_text = _generate_parsed_text_from_elements_internal(elements)

        return ParsedDocumentOutput(
            parsed_text=linear_text,
            elements=elements,
            original_metadata=original_metadata
        )
    except Exception as e:
        logger.error(f"Error parsing HTML content with BeautifulSoup: {e}", exc_info=True)
        return None
```

    |-- evaluation_assets.py

``` py
import dagster as dg
import os
from typing import Dict, List, Any # Optional 可能之后会用到

# 从项目中导入我们重构的批量评估函数和相关工具/常量
from zhz_rag.evaluation.batch_eval_cypher import run_cypher_batch_evaluation
from zhz_rag.evaluation.batch_eval_answer import run_answer_batch_evaluation
from zhz_rag.evaluation.analyze_cypher import perform_cypher_evaluation_analysis
from zhz_rag.evaluation.analyze_answer import perform_answer_evaluation_analysis
from zhz_rag.utils.common_utils import (
    find_latest_rag_interaction_log,
    RAG_INTERACTION_LOGS_DIR,
    EVALUATION_RESULTS_LOGS_DIR,
    get_evaluation_result_log_filepath
)
# 导入 GeminiAPIResource 以声明资源依赖
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import GeminiAPIResource

# --- 资产定义 ---

@dg.asset(
    name="latest_rag_interaction_log_for_evaluation",
    description="Provides the filepath of the latest RAG interaction log to be used for evaluation.",
    group_name="evaluation_pipeline",
    compute_kind="python" # 可选，指明计算类型
)
def latest_rag_interaction_log_for_evaluation_asset(context: dg.AssetExecutionContext) -> str:
    """
    Finds and returns the path to the latest RAG interaction log file.
    """
    log_filepath = find_latest_rag_interaction_log(RAG_INTERACTION_LOGS_DIR)
    if not log_filepath or not os.path.exists(log_filepath):
        error_msg = f"No RAG interaction log file found in directory: {RAG_INTERACTION_LOGS_DIR}"
        context.log.error(error_msg)
        raise dg.Failure(description=error_msg)
    
    context.log.info(f"Using RAG interaction log for evaluation: {log_filepath}")
    context.add_output_metadata({"log_filepath": log_filepath, "filename": os.path.basename(log_filepath)})
    return log_filepath

@dg.asset(
    name="batch_cypher_evaluations_log", # 资产名称最好能反映它产出的是日志文件
    description="Runs batch evaluation of Cypher queries and produces an evaluation log file.",
    group_name="evaluation_pipeline",
    compute_kind="python",
    # deps=[latest_rag_interaction_log_for_evaluation_asset] # 通过函数参数自动推断依赖
)
async def batch_cypher_evaluation_log_asset(
    context: dg.AssetExecutionContext,
    gemini_api: GeminiAPIResource,
    latest_rag_interaction_log_for_evaluation: str # <--- 修改参数名
) -> dg.Output[str]:
    context.log.info(f"Starting batch Cypher evaluation using log file: {latest_rag_interaction_log_for_evaluation}") # <--- 使用新参数名
    
    # 从 Dagster 配置中获取参数，或使用默认/环境变量
    # 这里我们先用之前脚本中的方式，未来可以转为 Dagster run_config
    app_version = os.getenv("APP_VERSION_TAG", "dagster_cypher_eval_0.2")
    # 对于 use_simulated_api，在 Dagster 中通常会通过资源配置或 op_config 来控制，
    # 而不是直接依赖环境变量，这样更灵活。但为了保持与脚本一致，暂时保留。
    use_simulated = os.getenv("USE_SIMULATED_GEMINI_CYPHER_EVAL", "false").lower() == "true"
    api_delay = float(os.getenv("GEMINI_API_CALL_DELAY_SECONDS", "4.1"))

    if use_simulated:
        context.log.warning("Cypher evaluation asset is using SIMULATED Gemini API calls.")

    # 调用我们重构的、现在接受 gemini_resource 的批量评估函数
    eval_stats = await run_cypher_batch_evaluation(
        gemini_resource_for_evaluator=gemini_api, # 传递注入的 Dagster 资源
        rag_interaction_log_filepath=latest_rag_interaction_log_for_evaluation,
        app_version=app_version,
        use_simulated_api=use_simulated, # 这个参数现在由 run_cypher_batch_evaluation 内部处理
        api_call_delay=api_delay
    )
    context.log.info(f"Batch Cypher evaluation completed. Statistics: {eval_stats}")

    # 确定输出的评估结果日志文件名 (与 evaluator.py 中一致)
    output_log_filepath = get_evaluation_result_log_filepath(evaluation_name="cypher_gemini_flash")
    
    # 确保目录存在 (get_evaluation_result_log_filepath 内部的 log_interaction_data 会处理)
    # 但这里我们也可以提前确保，或者依赖 log_interaction_data
    os.makedirs(os.path.dirname(output_log_filepath), exist_ok=True)
            
    metadata = {"evaluation_stats": eval_stats, "output_filepath": output_log_filepath}
    if eval_stats.get("cypher_queries_evaluated", 0) == 0:
        metadata["warning"] = "No Cypher queries were evaluated. Output log might be empty."
        context.log.warning(metadata["warning"])

    return dg.Output(output_log_filepath, metadata=metadata)


@dg.asset(
    name="batch_answer_evaluations_log", # 资产名称
    description="Runs batch evaluation of generated answers from RAG logs using Gemini.",
    group_name="evaluation_pipeline",
    compute_kind="python",
    # deps=[latest_rag_interaction_log_for_evaluation_asset] # 通过函数参数自动推断依赖
)
async def batch_answer_evaluation_log_asset(
    context: dg.AssetExecutionContext,
    gemini_api: GeminiAPIResource,
    latest_rag_interaction_log_for_evaluation: str # <--- 修改参数名
) -> dg.Output[str]:
    context.log.info(f"Starting batch Answer evaluation using log file: {latest_rag_interaction_log_for_evaluation}") # <--- 使用新参数名
    app_version = os.getenv("APP_VERSION_TAG", "dagster_answer_eval_0.2")
    use_simulated = os.getenv("USE_SIMULATED_GEMINI_ANSWER_EVAL", "false").lower() == "true"
    api_delay = float(os.getenv("GEMINI_API_CALL_DELAY_SECONDS", "4.1"))

    if use_simulated:
        context.log.warning("Answer evaluation asset is using SIMULATED Gemini API calls.")

    eval_stats = await run_answer_batch_evaluation(
        gemini_resource_for_evaluator=gemini_api, # 传递注入的 Dagster 资源
        rag_interaction_log_filepath=latest_rag_interaction_log_for_evaluation,
        app_version=app_version,
        use_simulated_api=use_simulated, # 这个参数现在由 run_answer_batch_evaluation 内部处理
        api_call_delay=api_delay
    )
    context.log.info(f"Batch Answer evaluation completed. Statistics: {eval_stats}")

    output_log_filepath = get_evaluation_result_log_filepath(evaluation_name="answer_gemini_flash")
    os.makedirs(os.path.dirname(output_log_filepath), exist_ok=True)

    metadata = {"evaluation_stats": eval_stats, "output_filepath": output_log_filepath}
    if eval_stats.get("answers_evaluated", 0) == 0:
        metadata["warning"] = "No answers were evaluated. Output log might be empty."
        context.log.warning(metadata["warning"])
        
    return dg.Output(output_log_filepath, metadata=metadata)

@dg.asset(
    name="cypher_evaluation_analysis_report", # 资产名称
    description="Generates a CSV analysis report from Cypher evaluation results.",
    group_name="evaluation_pipeline",
    compute_kind="python",
    # deps=[batch_cypher_evaluation_log_asset] # 通过函数参数自动推断依赖
)
def cypher_analysis_report_asset(
    context: dg.AssetExecutionContext,
    batch_cypher_evaluations_log: str # 上游资产的输出 (即 cypher 评估日志文件的路径)
) -> dg.Output[str]: # 输出 CSV 报告文件的路径
    """
    Analyzes Cypher evaluation logs and produces a CSV report.
    """
    context.log.info(f"Starting Cypher evaluation analysis using log file: {batch_cypher_evaluations_log}")

    if not os.path.exists(batch_cypher_evaluations_log):
        error_msg = f"Input Cypher evaluation log file not found: {batch_cypher_evaluations_log}"
        context.log.error(error_msg)
        raise dg.Failure(description=error_msg)

    # 构建输出CSV文件的路径
    # 我们希望CSV文件也存储在 EVALUATION_RESULTS_LOGS_DIR 目录下
    # 文件名可以基于输入日志名或固定一个模式
    base_input_log_name = os.path.basename(batch_cypher_evaluations_log)
    # 从 "eval_results_cypher_gemini_flash_YYYYMMDD.jsonl" 生成 "analysis_cypher_gemini_flash_YYYYMMDD.csv"
    if base_input_log_name.startswith("eval_results_") and base_input_log_name.endswith(".jsonl"):
        analysis_file_name = "analysis_" + base_input_log_name[len("eval_results_"):-len(".jsonl")] + ".csv"
    else: # Fallback naming
        analysis_file_name = f"analysis_cypher_report_{context.run_id[:8]}.csv"
    
    output_csv_filepath = os.path.join(EVALUATION_RESULTS_LOGS_DIR, analysis_file_name)
    
    success = perform_cypher_evaluation_analysis(
        evaluation_log_filepath=batch_cypher_evaluations_log,
        output_csv_filepath=output_csv_filepath
    )

    if success:
        context.log.info(f"Cypher evaluation analysis report generated: {output_csv_filepath}")
        return dg.Output(output_csv_filepath, metadata={"output_csv_filepath": output_csv_filepath, "source_log": base_input_log_name})
    else:
        error_msg = f"Cypher evaluation analysis failed for log file: {batch_cypher_evaluations_log}"
        context.log.error(error_msg)
        raise dg.Failure(description=error_msg)


@dg.asset(
    name="answer_evaluation_analysis_report", # 资产名称
    description="Generates a CSV analysis report from Answer evaluation results.",
    group_name="evaluation_pipeline",
    compute_kind="python",
    # deps=[batch_answer_evaluations_log_asset] # 通过函数参数自动推断依赖
)
def answer_analysis_report_asset(
    context: dg.AssetExecutionContext,
    batch_answer_evaluations_log: str # 上游资产的输出 (即 answer 评估日志文件的路径)
) -> dg.Output[str]: # 输出 CSV 报告文件的路径
    """
    Analyzes Answer evaluation logs and produces a CSV report.
    """
    context.log.info(f"Starting Answer evaluation analysis using log file: {batch_answer_evaluations_log}")

    if not os.path.exists(batch_answer_evaluations_log):
        error_msg = f"Input Answer evaluation log file not found: {batch_answer_evaluations_log}"
        context.log.error(error_msg)
        raise dg.Failure(description=error_msg)

    base_input_log_name = os.path.basename(batch_answer_evaluations_log)
    if base_input_log_name.startswith("eval_results_") and base_input_log_name.endswith(".jsonl"):
        analysis_file_name = "analysis_" + base_input_log_name[len("eval_results_"):-len(".jsonl")] + ".csv"
    else: # Fallback naming
        analysis_file_name = f"analysis_answer_report_{context.run_id[:8]}.csv"
        
    output_csv_filepath = os.path.join(EVALUATION_RESULTS_LOGS_DIR, analysis_file_name)

    success = perform_answer_evaluation_analysis(
        evaluation_log_filepath=batch_answer_evaluations_log,
        output_csv_filepath=output_csv_filepath
    )

    if success:
        context.log.info(f"Answer evaluation analysis report generated: {output_csv_filepath}")
        return dg.Output(output_csv_filepath, metadata={"output_csv_filepath": output_csv_filepath, "source_log": base_input_log_name})
    else:
        error_msg = f"Answer evaluation analysis failed for log file: {batch_answer_evaluations_log}"
        context.log.error(error_msg)
        raise dg.Failure(description=error_msg)

# 将所有评估相关的资产收集到一个列表中，方便在 definitions.py 中引用
all_evaluation_assets = [
    latest_rag_interaction_log_for_evaluation_asset,
    batch_cypher_evaluation_log_asset,
    batch_answer_evaluation_log_asset,
    cypher_analysis_report_asset, # <--- 新增
    answer_analysis_report_asset, # <--- 新增
]
```

    |-- ingestion_assets.py

``` py
# zhz_rag_pipeline/ingestion_assets.py
import dagster as dg
import os
from typing import List, Dict, Any, Union, Optional
from datetime import datetime, timezone

# --- 修改：导入分发器并设置Pydantic可用性标志 ---
# 尝试导入Pydantic模型，并设置一个标志，以便在模型不可用时代码可以优雅地降级。
try:
    from .pydantic_models_dagster import LoadedDocumentOutput, ParsedDocumentOutput, NarrativeTextElement
    _PYDANTIC_AVAILABLE = True
except ImportError:
    LoadedDocumentOutput = dict  # type: ignore
    ParsedDocumentOutput = dict  # type: ignore
    NarrativeTextElement = dict  # type: ignore
    _PYDANTIC_AVAILABLE = False

from .parsers import dispatch_parsing # <--- 修改导入路径
# --- 修改结束 ---

class LoadDocumentsConfig(dg.Config):
    documents_directory: str = "/home/zhz/zhz_agent/data/raw_documents/" # 更新后的原始文档目录
    allowed_extensions: List[str] = [".txt", ".md", ".docx", ".pdf", ".xlsx", ".html", ".htm"] # 扩大允许范围以测试所有解析器

@dg.asset(
    name="raw_documents",
    description="Loads raw documents from a specified directory.",
    group_name="ingestion"
)
def load_documents_asset(
    context: dg.AssetExecutionContext, 
    config: LoadDocumentsConfig
) -> List[LoadedDocumentOutput]:  # type: ignore
    
    loaded_docs: List[LoadedDocumentOutput] = []  # type: ignore
    target_directory = config.documents_directory
    allowed_exts = tuple(config.allowed_extensions) 

    context.log.info(f"Scanning directory: {target_directory} for files with extensions: {allowed_exts}")

    if not os.path.isdir(target_directory):
        context.log.error(f"Directory not found: {target_directory}")
        return loaded_docs

    for filename in os.listdir(target_directory):
        file_path = os.path.join(target_directory, filename)
        if os.path.isfile(file_path):
            file_name_lower = filename.lower()
            file_extension = os.path.splitext(file_name_lower)[1]

            if file_extension in allowed_exts:
                context.log.info(f"Found matching file: {file_path}")
                try:
                    file_stat = os.stat(file_path)
                    
                    # --- VITAL FIX: Do not pass raw_content ---
                    # The downstream parser will handle reading the file from the path.
                    doc_output_data = {
                        "document_path": file_path,
                        "file_type": file_extension,
                        # raw_content is intentionally omitted
                        "metadata": {
                            "filename": filename,
                            "source_directory": target_directory,
                            "size_bytes": file_stat.st_size,
                            "creation_time_utc": datetime.fromtimestamp(file_stat.st_ctime, tz=timezone.utc).isoformat(),
                            "modified_time_utc": datetime.fromtimestamp(file_stat.st_mtime, tz=timezone.utc).isoformat()
                        }
                    }

                    if _PYDANTIC_AVAILABLE:
                        loaded_docs.append(LoadedDocumentOutput(**doc_output_data))
                    else:
                        loaded_docs.append(doc_output_data)

                    context.log.info(f"Successfully created LoadedDocumentOutput for: {file_path}")
                except Exception as e:
                    context.log.error(f"Failed to process file {file_path}: {e}")
            else:
                context.log.debug(f"Skipping file with non-allowed extension: {file_path}")
        else:
            context.log.debug(f"Skipping non-file item: {file_path}")
            
    if not loaded_docs:
        context.log.warning(f"No matching documents found in {target_directory}")

    if loaded_docs:
        first_doc_path = loaded_docs[0].document_path if _PYDANTIC_AVAILABLE and loaded_docs else "N/A"
        context.add_output_metadata(
            metadata={
                "num_documents_loaded": len(loaded_docs),
                "first_document_path": first_doc_path
            }
        )
    return loaded_docs



@dg.asset(
    name="parsed_documents",
    description="Parses loaded documents into text and extracts basic structure using a dispatcher.",
    group_name="ingestion"
)
def parse_document_asset(
    context: dg.AssetExecutionContext,
    raw_documents: List[LoadedDocumentOutput] # type: ignore
) -> List[ParsedDocumentOutput]: # type: ignore
    
    parsed_docs_output_list: List[ParsedDocumentOutput] = [] # type: ignore
    context.log.info(f"Received {len(raw_documents)} documents to parse.")

    for doc_input in raw_documents:
        doc_path = doc_input.document_path
        file_ext = doc_input.file_type.lower()
        original_metadata = doc_input.metadata.copy()
        original_metadata["source_file_path"] = doc_path

        context.log.info(f"Attempting to parse document: {doc_path} (Type: {file_ext})")

        try:
            # --- VITAL REFACTOR ---
            # 直接将文件路径传递给解析器，不再处理字节内容
            # 对于文本文件，解析器内部自己会用 'rt' 模式读取
            # 对于二进制文件(pdf, docx, xlsx)，解析器会用 'rb' 模式或相应库读取
            parsed_output = dispatch_parsing(file_ext, doc_path, original_metadata)

            if not parsed_output:
                context.log.warning(f"Parser for '{file_ext}' returned no output for {doc_path}. Creating a fallback.")
                fallback_text = f"[Content Not Parsed by Specific Parser: {doc_path}]"
                elements = [NarrativeTextElement(text=fallback_text)]
                parsed_output = ParsedDocumentOutput(
                    parsed_text=fallback_text,
                    elements=elements,
                    original_metadata=original_metadata
                )

            # 确保输出总是 Pydantic 模型
            if isinstance(parsed_output, dict):
                parsed_output = ParsedDocumentOutput(**parsed_output)
            
            parsed_docs_output_list.append(parsed_output)
            context.log.info(f"Successfully processed: {doc_path}")

        except Exception as e:
            context.log.error(f"Critical error during parsing asset for {doc_path}: {e}", exc_info=True)
            error_text = f"[Critical Parsing Exception for {doc_path}: {str(e)}]"
            elements = [NarrativeTextElement(text=error_text)]
            error_output = ParsedDocumentOutput(
                parsed_text=error_text,
                elements=elements,
                original_metadata=original_metadata
            )
            parsed_docs_output_list.append(error_output)

    if parsed_docs_output_list:
        context.add_output_metadata(
            metadata={
                "num_documents_processed_for_parsing": len(raw_documents),
                "num_parsed_document_outputs_generated": len(parsed_docs_output_list),
            }
        )
    return parsed_docs_output_list



all_ingestion_assets = [load_documents_asset, parse_document_asset]
```

    |-- processing_assets.py

``` py
#  文件: zhz_rag_pipeline_dagster/zhz_rag_pipeline/processing_assets.py

import json
import asyncio
import re
import dagster as dg
from typing import List, Dict, Any, Optional, Union
import uuid
from langchain_text_splitters import RecursiveCharacterTextSplitter
import hashlib
import pandas as pd
from zhz_rag.utils.common_utils import normalize_text_for_id
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.pydantic_models_dagster import (
    ChunkOutput,
    ParsedDocumentOutput,
    EmbeddingOutput,
    KGTripleSetOutput,
    ExtractedEntity,
    ExtractedRelation,
    # --- 添加导入我们需要的元素类型 ---
    TitleElement,
    NarrativeTextElement,
    ListItemElement,
    TableElement,
    CodeBlockElement,
    ImageElement,
    PageBreakElement,
    HeaderElement,
    FooterElement,
    DocumentElementMetadata
    # --- 结束添加 ---
)
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import (
    GGUFEmbeddingResource,
    ChromaDBResource,
    DuckDBResource,
    LocalLLMAPIResource,
    SystemResource  # <--- 添加这一行以导入 SystemResource
)
import jieba
import bm25s
import pickle
import numpy as np
import os
from zhz_rag.utils.common_utils import normalize_text_for_id

_PYDANTIC_AVAILABLE = False
try:
    from .pydantic_models_dagster import ( # 使用相对导入
        ChunkOutput,
        ParsedDocumentOutput,
        EmbeddingOutput,
        KGTripleSetOutput,
        ExtractedEntity,
        ExtractedRelation,
        TitleElement,
        NarrativeTextElement,
        ListItemElement,
        TableElement,
        CodeBlockElement,
        ImageElement,
        PageBreakElement,
        HeaderElement,
        FooterElement,
        DocumentElementMetadata # <--- 确保这里导入了 DocumentElementMetadata
    )
    _PYDANTIC_AVAILABLE = True
    # 如果 Pydantic 可用，我们也可以直接从模型中获取 DocumentElementType
    # from .pydantic_models_dagster import DocumentElementType # 如果需要更精确的类型提示
except ImportError:
    # 定义占位符
    class BaseModel: pass
    class ChunkOutput(BaseModel): pass
    class ParsedDocumentOutput(BaseModel): pass
    class EmbeddingOutput(BaseModel): pass
    class KGTripleSetOutput(BaseModel): pass
    class ExtractedEntity(BaseModel): pass
    class ExtractedRelation(BaseModel): pass
    class TitleElement(BaseModel): pass
    class NarrativeTextElement(BaseModel): pass
    class ListItemElement(BaseModel): pass
    class TableElement(BaseModel): pass
    class CodeBlockElement(BaseModel): pass
    class ImageElement(BaseModel): pass
    class PageBreakElement(BaseModel): pass
    class HeaderElement(BaseModel): pass
    class FooterElement(BaseModel): pass
    class DocumentElementMetadata(BaseModel): pass # <--- 定义占位符
    DocumentElementType = Any # type: ignore
# --- 结束 Pydantic 模型导入 ---

import logging
logger = logging.getLogger(__name__)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG) # <--- 确保是 DEBUG
    logger.info(f"Logger for {__name__} (processing_assets) configured with DEBUG level.")


class TextChunkerConfig(dg.Config):
    chunk_size: int = 1000 
    chunk_overlap: int = 100
    max_element_text_length_before_split: int = 1200 # 一个1200字符的段落如果语义连贯，可以考虑不切分。
    target_sentence_split_chunk_size: int = 600    # 略微增大子块的目标大小，使其包含更多上下文。
    sentence_split_chunk_overlap_sentences: int = 2  # 增加到2句重叠，以期在子块之间提供更好的语义连接。
    # --- 合并策略参数 ---
    min_chunk_length_to_avoid_merge: int = 250
    max_merged_chunk_size: int = 750


def split_text_into_sentences(text: str) -> List[str]:
    """
    Splits text into sentences using a regex-based approach.
    Handles common sentence terminators and aims to preserve meaningful units.
    """
    if not text:
        return []
    # 改进的句子分割正则表达式，考虑了中英文句号、问号、感叹号
    # 并尝试处理省略号和一些特殊情况。
    # (?<=[。？！\.!\?]) 会匹配这些标点符号后面的位置 (lookbehind)
    # \s* 匹配标点后的任意空格
    # (?!$) 确保不是字符串末尾 (避免在末尾标点后产生空句子)
    # 对于中文，句号、问号、感叹号通常直接结束句子。
    # 对于英文，. ! ? 后面通常有空格或换行。
    
    # 一个更简单的版本，直接按标点分割，然后清理
    sentences = re.split(r'([。？！\.!\?])', text)
    result = []
    current_sentence = ""
    for i in range(0, len(sentences), 2):
        part = sentences[i]
        terminator = sentences[i+1] if i+1 < len(sentences) else ""
        current_sentence = part + terminator
        if current_sentence.strip():
            result.append(current_sentence.strip())
    
    # 如果上面的分割不理想，可以尝试更复杂的，但这个简单版本通常够用
    # 例如：
    # sentences = re.split(r'(?<=[。？！\.!\?])\s*', text)
    # sentences = [s.strip() for s in sentences if s.strip()]
    return result if result else [text] # 如果无法分割，返回原文本作为一个句子


# --- START: 覆盖这个函数 ---
def split_markdown_table_by_rows(
    markdown_table_text: str,
    target_chunk_size: int,
    max_chunk_size: int,
    context: Optional[dg.AssetExecutionContext] = None
) -> List[Dict[str, Any]]:
    """
    Splits a Markdown table string by its data rows.
    It now tries to create smaller chunks, even for short tables, by grouping a few rows together.
    """
    sub_chunks_data: List[Dict[str, Any]] = []
    lines = markdown_table_text.strip().split('\n')
    
    if len(lines) < 2:
        if context: context.log.warning(f"Markdown table has less than 2 lines. Cannot process for row splitting.")
        return [{"text": markdown_table_text, "start_row_index": -1, "end_row_index": -1}]

    header_row = lines[0]
    separator_row = lines[1]
    data_rows = lines[2:]

    if not data_rows:
        if context: context.log.warning("Markdown table has no data rows. Returning header and separator as single chunk.")
        return [{"text": f"{header_row}\n{separator_row}", "start_row_index": -1, "end_row_index": -1}]

    # --- 新的、更激进的分割逻辑 ---
    current_sub_chunk_lines = []
    current_sub_chunk_start_row_idx = 0
    
    # 定义每个块的目标行数，例如 2-3 行，可以根据需要调整
    ROWS_PER_CHUNK = 2

    for i in range(0, len(data_rows), ROWS_PER_CHUNK):
        chunk_of_rows = data_rows[i:i + ROWS_PER_CHUNK]
        
        # 每个块都包含表头和分隔符，以保证上下文完整
        sub_chunk_text = "\n".join([header_row, separator_row] + chunk_of_rows)
        
        start_row_index = i
        end_row_index = i + len(chunk_of_rows) - 1

        sub_chunks_data.append({
            "text": sub_chunk_text,
            "start_row_index": start_row_index,
            "end_row_index": end_row_index
        })
        if context:
            context.log.debug(f"  Table sub-chunk created: data rows index {start_row_index}-{end_row_index}")
    
    return sub_chunks_data
# --- END: 覆盖结束 ---


def split_code_block_by_blank_lines(
    code_text: str,
    target_chunk_size: int, # 复用配置，但对于代码块，这个更像是一个上限指导
    max_chunk_size: int,    # 作为硬上限
    context: Optional[dg.AssetExecutionContext] = None
) -> List[str]:
    """
    Splits a code block string by blank lines (one or more empty lines).
    Tries to keep resulting chunks from exceeding max_chunk_size.
    """
    if not code_text.strip():
        return []

    # 使用正则表达式匹配一个或多个连续的空行作为分隔符
    # \n\s*\n 匹配一个换行符，后跟零或多个空白字符，再跟一个换行符
    potential_splits = re.split(r'(\n\s*\n)', code_text) # 保留分隔符以便后续处理
    
    sub_chunks = []
    current_chunk_lines = []
    current_chunk_char_count = 0

    # 第一个块总是从头开始
    if potential_splits:
        first_part = potential_splits.pop(0).strip()
        if first_part:
            current_chunk_lines.append(first_part)
            current_chunk_char_count += len(first_part)

    while potential_splits:
        delimiter = potential_splits.pop(0) # 这是分隔符 \n\s*\n
        if not potential_splits: # 没有更多内容了
            if delimiter.strip(): # 如果分隔符本身不是纯空白，也算内容
                 current_chunk_lines.append(delimiter.rstrip()) # 保留末尾的换行
                 current_chunk_char_count += len(delimiter.rstrip())
            break 
        
        next_part = potential_splits.pop(0).strip()
        if not next_part: # 如果下一个部分是空的，只处理分隔符
            if delimiter.strip():
                current_chunk_lines.append(delimiter.rstrip())
                current_chunk_char_count += len(delimiter.rstrip())
            continue

        # 检查加入 delimiter 和 next_part 是否会超长
        # 对于代码，我们通常希望在逻辑断点（空行）处分割，即使块较小
        # 但如果单个由空行分隔的块本身就超过 max_chunk_size，则需要进一步处理（目前简单截断或接受）
        
        # 简化逻辑：如果当前块非空，并且加入下一个部分（包括分隔的空行）会超过目标大小，
        # 或者严格超过最大大小，则结束当前块。
        # 这里的分隔符（空行）本身也应该被视为块的一部分，或者作为块的自然结束。

        # 更简单的策略：每个由 re.split 分割出来的非空部分（即代码段）自成一块
        # 如果代码段本身过长，则接受它，或者未来再细分
        if current_chunk_lines: # 如果当前块有内容
            # 检查如果加上 next_part 是否会超长（这里可以简化，因为空行分割通常意味着逻辑单元）
            # 我们先假设每个由空行分割的块都是一个独立的单元
            sub_chunks.append("\n".join(current_chunk_lines))
            if context: context.log.debug(f"  Code sub-chunk created (blank line split), len: {current_chunk_char_count}")
            current_chunk_lines = []
            current_chunk_char_count = 0
        
        if next_part: # 开始新的块
            current_chunk_lines.append(next_part)
            current_chunk_char_count += len(next_part)

    # 添加最后一个正在构建的子块
    if current_chunk_lines:
        sub_chunks.append("\n".join(current_chunk_lines))
        if context: context.log.debug(f"  Code sub-chunk created (blank line split, last), len: {current_chunk_char_count}")

    if not sub_chunks and code_text: # 如果完全没分割出任何东西（例如代码没有空行）
        if context: context.log.warning("Code block splitting by blank lines resulted in no sub-chunks. Returning original code block.")
        # 对于这种情况，我们可能需要一个字符分割器作为最终回退
        # 但为了简单起见，我们先返回原始代码块
        # 如果原始代码块 > max_chunk_size，它仍然会是一个大块
        if len(code_text) > max_chunk_size:
            if context: context.log.warning(f"  Original code block (len: {len(code_text)}) exceeds max_chunk_size ({max_chunk_size}) and was not split by blank lines. Consider character splitting as fallback.")
            # 这里可以插入 RecursiveCharacterTextSplitter 逻辑
            # from langchain_text_splitters import RecursiveCharacterTextSplitter
            # char_splitter = RecursiveCharacterTextSplitter(chunk_size=max_chunk_size, chunk_overlap=0, separators=["\n", " ", ""])
            # sub_chunks = char_splitter.split_text(code_text)
            # if context: context.log.info(f"    Fallback: Code block character split into {len(sub_chunks)} parts.")
            # return sub_chunks
        return [code_text] # 暂时返回原块

    # 过滤掉完全是空字符串的块 (re.split 可能产生)
    final_sub_chunks = [chunk for chunk in sub_chunks if chunk.strip()]
    return final_sub_chunks if final_sub_chunks else [code_text]


def _get_element_text(element: Any, context: dg.AssetExecutionContext) -> Optional[str]:
    """
    Extracts the text content from a DocumentElement, handling various types.
    """
    # 检查 element 是否有 text 属性
    if hasattr(element, 'text') and isinstance(element.text, str) and element.text.strip():
        return element.text.strip()
    
    # 对TableElement，它的markdown表示更有用
    if isinstance(element, TableElement) and hasattr(element, 'markdown_representation'):
        return element.markdown_representation
        
    # 对CodeBlockElement，它的code属性是内容
    if isinstance(element, CodeBlockElement) and hasattr(element, 'code'):
        return element.code

    # 最后的防线：尝试将元素转为字符串，但这通常表示有未处理的类型
    # context.log.warning(f"Element of type {type(element).__name__} has no direct text attribute. Falling back to str().")
    # return str(element)
    return None # 如果没有明确的文本内容，则返回None，避免注入描述性文字



@dg.asset(
    name="text_chunks",
    description="Cleans/chunks documents. Splits long elements, merges short ones, enriches with contextual metadata.",
    group_name="processing",
    deps=["parsed_documents"]
)
def clean_chunk_text_asset(
    context: dg.AssetExecutionContext,
    config: TextChunkerConfig,
    parsed_documents: List[ParsedDocumentOutput]
) -> List[ChunkOutput]:
    all_chunks: List[ChunkOutput] = []

    for doc_idx, parsed_doc in enumerate(parsed_documents):
        # --- START: 核心修正 - 统一提取并传递文档级元数据 ---
        doc_meta = parsed_doc.original_metadata
        # 兼容 "filename" 和 "file_name" 两种常见键名
        doc_filename = doc_meta.get("filename") or doc_meta.get("file_name") or f"doc_{doc_idx}"
        # 兼容多种可能的日期键名
        doc_creation_date = doc_meta.get("creation_date") or doc_meta.get("creation_datetime")
        doc_last_modified = doc_meta.get("last_modified") or doc_meta.get("last_modified_datetime")
        doc_author = doc_meta.get("author") or doc_meta.get("authors")

        # 将所有文档级别的元数据打包成一个字典
        document_level_metadata = {
            "filename": doc_filename,
            "creation_date": doc_creation_date,
            "last_modified": doc_last_modified,
            "author": doc_author,
        }
        # 清理掉值为None的键
        document_level_metadata = {k: v for k, v in document_level_metadata.items() if v is not None}
        
        context.log.info(f"Processing document for chunking: {doc_filename}")
        # --- END: 核心修正 ---

        current_title_hierarchy: Dict[int, str] = {}
        doc_internal_chunk_counter = 0

        for element_idx, element in enumerate(parsed_doc.elements):
            parent_id = str(uuid.uuid4())
            
            # 2. 准备基础元数据 - 现在从打包好的文档级元数据开始
            base_chunk_meta = document_level_metadata.copy() # 每个块都继承文档级元数据
            
            # 添加元素级元数据
            element_type_str = getattr(element, 'element_type', type(element).__name__)
            base_chunk_meta.update({
                "parent_id": parent_id,
                "paragraph_type": element_type_str,
                "source_element_index": element_idx,
            })

            if isinstance(element, TitleElement):
                 title_level = getattr(element, 'level', 1)
                 keys_to_remove = [lvl for lvl in current_title_hierarchy if lvl >= title_level]
                 for key in keys_to_remove:
                     del current_title_hierarchy[key]
                 current_title_hierarchy[title_level] = getattr(element, 'text', '').strip()
            
            for level, title in current_title_hierarchy.items():
                base_chunk_meta[f"title_hierarchy_{level}"] = title
            
            if hasattr(element, 'metadata') and element.metadata:
                page_num = getattr(element.metadata, 'page_number', None)
                if page_num is not None:
                    base_chunk_meta['page_number'] = page_num + 1

            # 3. 对不同类型的元素进行分块
            sub_chunks: List[Dict[str, Any]] = []
            
            text_content = _get_element_text(element, context)
            
            if not text_content:
                context.log.debug(f"Skipping element {element_idx} in {doc_filename} due to empty content.")
                continue

            # --- START: 对XLSX等文件解析出的Table文本进行特殊处理 ---
            # 假设非TableElement的表格内容会被解析为包含'|'和换行符的普通文本
            is_likely_table_text = '|' in text_content and '\n' in text_content

            if element_type_str == "TableElement" or is_likely_table_text:
                 # 无论元素类型是什么，只要内容像表格，就用表格分割器
                 base_chunk_meta["paragraph_type"] = "table" # 强制将类型标准化为'table'
                 sub_chunks = split_markdown_table_by_rows(text_content, config.target_sentence_split_chunk_size, config.max_merged_chunk_size, context)
            # --- END: 特殊处理 ---
            else:
                if len(text_content) > config.max_element_text_length_before_split:
                    sentences = split_text_into_sentences(text_content)
                    for sent in sentences:
                        if sent.strip():
                            sub_chunks.append({"text": sent.strip()})
                else:
                    sub_chunks.append({"text": text_content})

            # 4. 为所有生成的块创建 ChunkOutput 对象
            for sub_chunk_data in sub_chunks:
                doc_internal_chunk_counter += 1
                chunk_meta_final = base_chunk_meta.copy()
                chunk_meta_final["chunk_number_in_doc"] = doc_internal_chunk_counter
                
                if "start_row_index" in sub_chunk_data:
                    chunk_meta_final["table_original_start_row"] = sub_chunk_data["start_row_index"]
                    chunk_meta_final["table_original_end_row"] = sub_chunk_data["end_row_index"]

                all_chunks.append(ChunkOutput(
                    chunk_text=sub_chunk_data["text"],
                    source_document_id=doc_filename,
                    chunk_metadata=chunk_meta_final
                ))

    context.log.info(f"Chunking process finished. Total chunks generated: {len(all_chunks)}")
    if all_chunks:
        # 强制打印最后一个块的元数据，看filename是否存在
        context.log.info(f"Sample final chunk metadata: {all_chunks[-1].chunk_metadata}")
    
    context.add_output_metadata(metadata={"total_chunks_generated": len(all_chunks)})
    return all_chunks


@dg.asset(
    name="text_embeddings",
    description="Generates vector embeddings for text chunks.",
    group_name="processing",
    deps=["text_chunks"]
)
def generate_embeddings_asset( # <--- 保持同步，因为 GGUFEmbeddingResource.encode 是同步包装
    context: dg.AssetExecutionContext,
    text_chunks: List[ChunkOutput],
    embedder: GGUFEmbeddingResource
) -> List[EmbeddingOutput]:
    # +++ 新增打印语句 +++
    context.log.info(f"generate_embeddings_asset: Received {len(text_chunks)} text_chunks.")
    if text_chunks:
        context.log.info(f"generate_embeddings_asset: First chunk text (first 100 chars): '{text_chunks[0].chunk_text[:100]}'")
        context.log.info(f"generate_embeddings_asset: First chunk metadata: {text_chunks[0].chunk_metadata}")
    # +++ 结束新增打印语句 +++

    all_embeddings: List[EmbeddingOutput] = []
    if not text_chunks:
        context.log.warning("generate_embeddings_asset: No text chunks received, returning empty list.") # 添加一个明确的警告
        return all_embeddings
    
    # --- 确保 chunk_texts_to_encode 不为空才调用 embedder.encode ---
    chunk_texts_to_encode = [chunk.chunk_text for chunk in text_chunks if chunk.chunk_text and chunk.chunk_text.strip()]
    
    if not chunk_texts_to_encode:
        context.log.warning("generate_embeddings_asset: All received text chunks are empty or whitespace after filtering. Returning empty list.")
        # 即使原始 text_chunks 非空，但如果所有 chunk_text 都无效，也应该返回空 embedding 列表
        # 并且要确保下游知道期望的 EmbeddingOutput 数量可能是0
        return all_embeddings # 返回空列表是正确的

    vectors = embedder.encode(chunk_texts_to_encode)

    # --- 确保正确地将嵌入结果映射回原始的 text_chunks 列表（如果数量可能不一致）---
    # 当前的逻辑是假设 vectors 和 chunk_texts_to_encode 一一对应，并且 text_chunks 的顺序与 chunk_texts_to_encode 过滤前的顺序相关
    # 如果 chunk_texts_to_encode 进行了过滤，这里的循环需要更小心
    
    # 一个更安全的映射方式是，只为那些实际被编码的文本块创建 EmbeddingOutput
    # 但这要求下游能处理 EmbeddingOutput 列表长度可能小于 ChunkOutput 列表长度的情况，
    # 或者，我们应该为那些被过滤掉的 chunk 也创建一个带有零向量的 EmbeddingOutput。
    # 我们之前的 LocalModelHandler 修改是为了处理单个空文本，现在这里是资产层面的。

    # 保持与 LocalModelHandler 类似的健壮性：为所有传入的 text_chunks 生成 EmbeddingOutput，
    # 如果其文本为空或嵌入失败，则使用零向量。

    embedding_map = {text: vec for text, vec in zip(chunk_texts_to_encode, vectors)}

    for i, chunk_input in enumerate(text_chunks):
        model_name_for_log = os.getenv("EMBEDDING_MODEL_PATH", "API_Based_Embedder")
        embedding_vector_for_chunk = [0.0] * embedder.get_embedding_dimension() # 默认为零向量

        if chunk_input.chunk_text and chunk_input.chunk_text.strip() and chunk_input.chunk_text in embedding_map:
            embedding_vector_for_chunk = embedding_map[chunk_input.chunk_text]
        elif chunk_input.chunk_text and chunk_input.chunk_text.strip(): 
            # 文本有效但没有在 embedding_map 中找到 (可能因为 embedder.encode 内部的某些问题)
            context.log.warning(f"generate_embeddings_asset: Valid chunk text for chunk_id {chunk_input.chunk_id} was not found in embedding_map. Using zero vector.")
        else: # 文本本身就是空的
            context.log.info(f"generate_embeddings_asset: Chunk_id {chunk_input.chunk_id} has empty text. Using zero vector.")


        all_embeddings.append(EmbeddingOutput(
            chunk_id=chunk_input.chunk_id,
            chunk_text=chunk_input.chunk_text, # 存储原始文本，即使它是空的
            embedding_vector=embedding_vector_for_chunk,
            embedding_model_name=model_name_for_log,
            original_chunk_metadata=chunk_input.chunk_metadata
        ))
    
    context.add_output_metadata(metadata={"total_embeddings_generated": len(all_embeddings)})
    return all_embeddings


@dg.asset(
    name="vector_store_embeddings",
    description="Stores text embeddings into a ChromaDB vector store.",
    group_name="indexing",
    deps=["text_embeddings"]
)
def vector_storage_asset(
    context: dg.AssetExecutionContext,
    text_embeddings: List[EmbeddingOutput],
    chroma_db: ChromaDBResource
) -> None:
    if not text_embeddings:
        context.log.warning("vector_storage_asset: No embeddings received, nothing to store in ChromaDB.")
        context.add_output_metadata(metadata={"num_embeddings_stored": 0})
        return

    # --- START: 核心修复 ---
    # 筛选出那些拥有有效（非空）嵌入向量的条目
    valid_embeddings_to_store: List[EmbeddingOutput] = []
    for emb in text_embeddings:
        if emb.embedding_vector and len(emb.embedding_vector) > 0:
            valid_embeddings_to_store.append(emb)
        else:
            context.log.warning(f"Skipping storage for chunk_id {emb.chunk_id} due to empty embedding vector.")
    
    if not valid_embeddings_to_store:
        context.log.warning("vector_storage_asset: No valid embeddings found after filtering. Nothing to store.")
        context.add_output_metadata(metadata={"num_embeddings_stored": 0, "num_invalid_embeddings_skipped": len(text_embeddings)})
        return
        
    ids_to_store = [emb.chunk_id for emb in valid_embeddings_to_store]
    embeddings_to_store = [emb.embedding_vector for emb in valid_embeddings_to_store]
    documents_to_store = [emb.chunk_text for emb in valid_embeddings_to_store]
    cleaned_metadatas: List[Dict[str, Any]] = []

    for i, emb_output in enumerate(valid_embeddings_to_store):
    # --- END: 核心修复 ---
        original_meta = emb_output.original_chunk_metadata if isinstance(emb_output.original_chunk_metadata, dict) else {}
        meta = original_meta.copy()
        
        meta["chunk_text_in_meta"] = str(emb_output.chunk_text) if emb_output.chunk_text is not None else "[TEXT IS NULL]"

        cleaned_meta_item: Dict[str, Any] = {}
        for key, value in meta.items():
            if isinstance(value, dict):
                if key == "title_hierarchy" and not value: 
                    cleaned_meta_item[key] = "None"
                    context.log.debug(f"Metadata for chunk {emb_output.chunk_id}: Replaced empty title_hierarchy dict with 'None' string.")
                else:
                    try:
                        cleaned_meta_item[key] = json.dumps(value, ensure_ascii=False)
                    except TypeError:
                        cleaned_meta_item[key] = str(value)
                        context.log.warning(f"Metadata for chunk {emb_output.chunk_id}: Could not JSON serialize dict for key '{key}', used str(). Value: {str(value)[:100]}...")
            elif isinstance(value, list):
                try:
                    cleaned_meta_item[key] = json.dumps(value, ensure_ascii=False)
                except TypeError:
                    cleaned_meta_item[key] = str(value)
                    context.log.warning(f"Metadata for chunk {emb_output.chunk_id}: Could not JSON serialize list for key '{key}', used str(). Value: {str(value)[:100]}...")
            elif value is None:
                cleaned_meta_item[key] = "" 
            else: 
                cleaned_meta_item[key] = value
        cleaned_metadatas.append(cleaned_meta_item)

    # +++ 新增日志 +++
    if embeddings_to_store:
        context.log.info(f"vector_storage_asset: Sample embedding vector to be stored (first item, first 10 elements): {str(embeddings_to_store[0][:10]) if embeddings_to_store[0] else 'None'}")
        context.log.info(f"vector_storage_asset: Length of first embedding vector to be stored: {len(embeddings_to_store[0]) if embeddings_to_store[0] else 'N/A'}")
        is_first_all_zeros = all(v == 0.0 for v in embeddings_to_store[0]) if embeddings_to_store[0] else "N/A"
        context.log.info(f"vector_storage_asset: Is first sample embedding all zeros: {is_first_all_zeros}")
    # +++ 结束新增日志 +++

    context.log.info(f"vector_storage_asset: Preparing to add/update {len(ids_to_store)} items to ChromaDB collection '{chroma_db.collection_name}'.")
    if ids_to_store:
        context.log.info(f"vector_storage_asset: Sample ID to store: {ids_to_store[0]}")
        # 确保 documents_to_store 也有对应内容，并且不是 None
        sample_doc_text = "[EMPTY DOCUMENT]"
        if documents_to_store and documents_to_store[0] is not None:
            sample_doc_text = str(documents_to_store[0])[:100] # 显示前100字符
        elif documents_to_store and documents_to_store[0] is None:
            sample_doc_text = "[DOCUMENT IS NULL]"
        context.log.info(f"vector_storage_asset: Sample document to store (from documents_to_store, first 100 chars): '{sample_doc_text}'")
        
        sample_meta_text = "[NO METADATA]"
        if cleaned_metadatas:
            sample_meta_text = str(cleaned_metadatas[0])[:200] # 显示元数据摘要
        context.log.info(f"vector_storage_asset: Sample cleaned metadata for first item: {sample_meta_text}")

    try:
        chroma_db.add_embeddings(
            ids=ids_to_store, 
            embeddings=embeddings_to_store, 
            documents=documents_to_store, # 传递真实的文本内容给ChromaDB的documents字段
            metadatas=cleaned_metadatas
        )
        # 尝试获取并记录操作后的集合计数
        # 注意: chroma_db._collection 可能是私有属性，直接访问不推荐，但为了调试可以尝试
        # 更好的方式是 ChromaDBResource 提供一个 get_collection_count() 方法
        collection_count_after_add = -1 # 默认值
        try:
            if chroma_db._collection: # 确保 _collection 不是 None
                 collection_count_after_add = chroma_db._collection.count()
        except Exception as e_count:
            context.log.warning(f"vector_storage_asset: Could not get collection count after add: {e_count}")

        context.add_output_metadata(metadata={"num_embeddings_stored": len(ids_to_store), "collection_count_after_add": collection_count_after_add})
        context.log.info(f"vector_storage_asset: Successfully called add_embeddings. Stored {len(ids_to_store)} items. Collection count now: {collection_count_after_add}")
    except Exception as e_chroma_add:
        context.log.error(f"vector_storage_asset: Failed to add embeddings to ChromaDB: {e_chroma_add}", exc_info=True)
        raise

class BM25IndexConfig(dg.Config):
    index_file_path: str = "/home/zhz/zhz_agent/zhz_rag/stored_data/bm25_index/"


@dg.asset(
    name="keyword_index",
    description="Builds and persists a BM25 keyword index from text chunks.",
    group_name="indexing",
    deps=["text_chunks"]
)
def keyword_index_asset(
    context: dg.AssetExecutionContext,
    config: BM25IndexConfig, # 确保 BM25IndexConfig 在文件某处已定义
    text_chunks: List[ChunkOutput]
) -> None:
    if not text_chunks:
        context.log.warning("keyword_index_asset: No text chunks received, skipping BM25 index building.")
        context.add_output_metadata(metadata={"num_documents_indexed": 0, "index_directory_path": config.index_file_path})
        return

    # --- 新增：检查并记录空文本块 ---
    valid_chunks_for_indexing: List[ChunkOutput] = []
    for idx, chunk in enumerate(text_chunks):
        if chunk.chunk_text and chunk.chunk_text.strip():
            valid_chunks_for_indexing.append(chunk)
        else:
            context.log.warning(f"keyword_index_asset: Chunk {idx} (ID: {chunk.chunk_id}) has empty or whitespace-only text. Skipping for BM25 indexing.")
    
    if not valid_chunks_for_indexing:
        context.log.warning("keyword_index_asset: All received text chunks have empty or whitespace-only text after filtering. Skipping BM25 index building.")
        context.add_output_metadata(metadata={"num_documents_indexed": 0, "index_directory_path": config.index_file_path})
        return
    # --- 结束新增 ---

    # 使用过滤后的有效块
    corpus_texts = [chunk.chunk_text for chunk in valid_chunks_for_indexing]
    document_ids = [chunk.chunk_id for chunk in valid_chunks_for_indexing] # 确保ID与有效文本对应

    context.log.info(f"keyword_index_asset: Preparing to index {len(corpus_texts)} valid text chunks for BM25.")
    if corpus_texts: # 仅在有数据时打印样本
        context.log.info(f"keyword_index_asset: Sample document ID for BM25: {document_ids[0]}")
        context.log.info(f"keyword_index_asset: Sample document text for BM25 (first 50 chars): '{str(corpus_texts[0])[:50]}'")

    try:
        corpus_tokenized_jieba = [list(jieba.cut_for_search(text)) for text in corpus_texts]
        context.log.info(f"keyword_index_asset: Tokenized {len(corpus_tokenized_jieba)} texts for BM25.")
        
        bm25_model = bm25s.BM25() # 使用默认参数初始化
        context.log.info("keyword_index_asset: BM25 model initialized.")
        
        bm25_model.index(corpus_tokenized_jieba)
        indexed_doc_count = len(bm25_model.doc_freqs) if hasattr(bm25_model, 'doc_freqs') and bm25_model.doc_freqs is not None else len(corpus_tokenized_jieba)
        context.log.info(f"keyword_index_asset: BM25 model indexing complete for {indexed_doc_count} documents.")
        
        index_directory = config.index_file_path
        context.log.info(f"keyword_index_asset: BM25 index will be saved to directory: {index_directory}")
        os.makedirs(index_directory, exist_ok=True)
        
        bm25_model.save(index_directory) 
        context.log.info(f"keyword_index_asset: bm25_model.save('{index_directory}') called.")
        
        doc_ids_path = os.path.join(index_directory, "doc_ids.pkl")
        with open(doc_ids_path, 'wb') as f_out:
            pickle.dump(document_ids, f_out)
        context.log.info(f"keyword_index_asset: doc_ids.pkl saved to {doc_ids_path} with {len(document_ids)} IDs.")
        
        # 验证文件是否真的创建了
        expected_params_file = os.path.join(index_directory, "params.index.json") # bm25s 保存时会创建这个
        if os.path.exists(expected_params_file) and os.path.exists(doc_ids_path):
            context.log.info(f"keyword_index_asset: Verified that BM25 index files (e.g., params.index.json, doc_ids.pkl) exist in {index_directory}.")
        else:
            context.log.error(f"keyword_index_asset: BM25 index files (e.g., params.index.json or doc_ids.pkl) NOT FOUND in {index_directory} after save operations!")
            context.log.error(f"keyword_index_asset: Check - params.index.json exists: {os.path.exists(expected_params_file)}")
            context.log.error(f"keyword_index_asset: Check - doc_ids.pkl exists: {os.path.exists(doc_ids_path)}")
            # 如果文件未找到，可能需要抛出异常以使资产失败
            # raise FileNotFoundError(f"BM25 index files not found in {index_directory} after save.")

        context.add_output_metadata(
            metadata={
                "num_documents_indexed": len(corpus_texts), 
                "index_directory_path": index_directory,
                "bm25_corpus_size_actual": indexed_doc_count
            }
        )
        context.log.info("keyword_index_asset: BM25 indexing and saving completed successfully.")
    except Exception as e_bm25:
        context.log.error(f"keyword_index_asset: Error during BM25 indexing or saving: {e_bm25}", exc_info=True)
        raise

# --- KG Extraction 相关的配置和资产 ---


# class KGExtractionConfig(dg.Config):
#     extraction_prompt_template: str = KG_EXTRACTION_SINGLE_CHUNK_PROMPT_TEMPLATE_V1
#     local_llm_model_name: str = "Qwen3-1.7B-GGUF_via_llama.cpp"

# DEFAULT_KG_EXTRACTION_SCHEMA = {
#     "type": "object",
#     "properties": {
#         "entities": {
#             "type": "array",
#             "items": {
#                 "type": "object",
#                 "properties": {
#                     "text": {"type": "string", "description": "提取到的实体原文"},
#                     "label": {"type": "string", "description": "实体类型 (例如: PERSON, ORGANIZATION, TASK)"}
#                 },
#                 "required": ["text", "label"]
#             },
#             "description": "从文本中提取出的实体列表。"
#         },
#         "relations": {
#             "type": "array",
#             "items": {
#                 "type": "object",
#                 "properties": {
#                     "head_entity_text": {"type": "string", "description": "头实体的文本"},
#                     "head_entity_label": {"type": "string", "description": "头实体的类型 (例如: PERSON, TASK)"},
#                     "relation_type": {"type": "string", "description": "关系类型 (例如: WORKS_AT, ASSIGNED_TO)"},
#                     "tail_entity_text": {"type": "string", "description": "尾实体的文本"},
#                     "tail_entity_label": {"type": "string", "description": "尾实体的类型 (例如: ORGANIZATION, PERSON)"}
#                 },
#                 "required": ["head_entity_text", "head_entity_label", "relation_type", "tail_entity_text", "tail_entity_label"]
#             },
#             "description": "从文本中提取出的关系三元组列表。"
#         }
#     },
#     "required": ["entities", "relations"]
# }


# @dg.asset(
#     name="kg_extractions",
#     description="Extracts entities and relations from text chunks for knowledge graph construction.",
#     group_name="kg_building",
#     io_manager_key="pydantic_json_io_manager",
#     deps=["text_chunks"]
# )
# async def kg_extraction_asset(
#     context: dg.AssetExecutionContext, # Pylance 提示 dg.AssetExecutionContext 未定义 "SystemResource"
#     text_chunks: List[ChunkOutput],
#     config: KGExtractionConfig,
#     LocalLLM_api: LocalLLMAPIResource,
#     system_info: SystemResource  # <--- 我们添加了 system_info
# ) -> List[KGTripleSetOutput]:
#     all_kg_outputs: List[KGTripleSetOutput] = []
#     if not text_chunks:
#         context.log.info("No text chunks received for KG extraction, skipping.")
#         return all_kg_outputs

#     total_input_chunks = len(text_chunks)
#     total_entities_extracted_overall = 0
#     total_relations_extracted_overall = 0
#     successfully_processed_chunks_count = 0
    
#     # 并发控制参数
#     recommended_concurrency = system_info.get_recommended_concurrent_tasks(task_type="kg_extraction_llm")
#     CONCURRENT_REQUESTS_LIMIT = max(1, recommended_concurrency) # 直接使用HAL推荐，但至少为1
#     context.log.info(f"HAL recommended concurrency for 'kg_extraction_llm': {recommended_concurrency}. Effective limit set to: {CONCURRENT_REQUESTS_LIMIT}")
#     semaphore = asyncio.Semaphore(CONCURRENT_REQUESTS_LIMIT)


#     async def extract_kg_for_chunk(chunk: ChunkOutput) -> Optional[KGTripleSetOutput]:
#         async with semaphore:
#             # 使用单个chunk的prompt模板
#             prompt = config.extraction_prompt_template.format(text_to_extract=chunk.chunk_text)
#             try:
#                 context.log.debug(f"Starting KG extraction for chunk_id: {chunk.chunk_id}, Text (start): {chunk.chunk_text[:100]}...")
#                 structured_response = await LocalLLM_api.generate_structured_output(
#                     prompt=prompt, 
#                     json_schema=DEFAULT_KG_EXTRACTION_SCHEMA # 使用单个对象的schema
#                 )
                
#                 # 确保 structured_response 是字典类型
#                 if not isinstance(structured_response, dict):
#                     context.log.error(f"Failed KG extraction for chunk {chunk.chunk_id}: LLM response was not a dict. Got: {type(structured_response)}. Response: {str(structured_response)[:200]}")
#                     return None

#                 entities_data = structured_response.get("entities", [])
#                 extracted_entities_list = [
#                     ExtractedEntity(text=normalize_text_for_id(e.get("text","")), label=e.get("label","UNKNOWN").upper())
#                     for e in entities_data if isinstance(e, dict)
#                 ]
                
#                 relations_data = structured_response.get("relations", [])
#                 extracted_relations_list = [
#                     ExtractedRelation(
#                         head_entity_text=r.get('head_entity_text',""), 
#                         head_entity_label=r.get('head_entity_label',"UNKNOWN").upper(), 
#                         relation_type=r.get('relation_type',"UNKNOWN").upper(), 
#                         tail_entity_text=r.get('tail_entity_text',""), 
#                         tail_entity_label=r.get('tail_entity_label',"UNKNOWN").upper()
#                     ) 
#                     for r in relations_data if isinstance(r, dict) and 
#                                                r.get('head_entity_text') and r.get('head_entity_label') and
#                                                r.get('relation_type') and r.get('tail_entity_text') and
#                                                r.get('tail_entity_label')
#                 ]
                
#                 context.log.debug(f"Finished KG extraction for chunk_id: {chunk.chunk_id}. Entities: {len(extracted_entities_list)}, Relations: {len(extracted_relations_list)}")
#                 return KGTripleSetOutput(
#                     chunk_id=chunk.chunk_id,
#                     extracted_entities=extracted_entities_list,
#                     extracted_relations=extracted_relations_list,
#                     extraction_model_name=config.local_llm_model_name,
#                     original_chunk_metadata=chunk.chunk_metadata
#                 )
#             except Exception as e:
#                 context.log.error(f"Failed KG extraction for chunk {chunk.chunk_id}: {e}", exc_info=True)
#                 return None 

#     context.log.info(f"Starting KG extraction for {total_input_chunks} chunks with concurrency limit: {CONCURRENT_REQUESTS_LIMIT}.")
    
#     tasks = [extract_kg_for_chunk(chunk) for chunk in text_chunks]
    
#     results = await asyncio.gather(*tasks)
    
#     context.log.info(f"Finished all KG extraction tasks. Received {len(results)} results (including potential None for failures).")

#     for result_item in results:
#         if result_item and isinstance(result_item, KGTripleSetOutput):
#             all_kg_outputs.append(result_item)
#             total_entities_extracted_overall += len(result_item.extracted_entities)
#             total_relations_extracted_overall += len(result_item.extracted_relations)
#             successfully_processed_chunks_count +=1
#         elif result_item is None:
#             context.log.warning("A KG extraction task failed and returned None.")
            
#     context.log.info(f"KG extraction complete. Successfully processed {successfully_processed_chunks_count} out of {total_input_chunks} chunks.")
#     context.add_output_metadata(
#         metadata={
#             "total_chunks_input_to_kg": total_input_chunks, # 恢复为 total_input_chunks
#             "chunks_successfully_extracted_kg": successfully_processed_chunks_count,
#             "total_entities_extracted": total_entities_extracted_overall, 
#             "total_relations_extracted": total_relations_extracted_overall
#             # 移除了批处理相关的元数据 "total_batches_processed", "batch_size_configured"
#         }
#     )
#     return all_kg_outputs


# # --- KuzuDB 构建资产链 ---

# @dg.asset(
#     name="duckdb_schema", # <--- 修改资产名称
#     description="Creates the base schema (node and relation tables) in DuckDB.",
#     group_name="kg_building",
#     # deps=[kg_extraction_asset] # 保持依赖，确保在提取之后创建schema (逻辑上)
#                                  # 虽然schema创建本身不直接使用提取结果，但流水线顺序上合理
# )
# def duckdb_schema_asset(context: dg.AssetExecutionContext, duckdb_kg: DuckDBResource, embedder: GGUFEmbeddingResource): # <--- 修改函数名和资源参数
#     context.log.info("--- Starting DuckDB Schema Creation Asset ---")
    
#     # 获取嵌入维度，与KuzuDB时类似
#     EMBEDDING_DIM = embedder.get_embedding_dimension()
#     if not EMBEDDING_DIM:
#         raise ValueError("Could not determine embedding dimension from GGUFEmbeddingResource.")

#     node_table_ddl = f"""
#     CREATE TABLE IF NOT EXISTS ExtractedEntity (
#         id_prop VARCHAR PRIMARY KEY,
#         text VARCHAR,
#         label VARCHAR,
#         embedding FLOAT[{EMBEDDING_DIM}]
#     );
#     """

#     relation_table_ddl = f"""
#     CREATE TABLE IF NOT EXISTS KGExtractionRelation (
#         relation_id VARCHAR PRIMARY KEY,
#         source_node_id_prop VARCHAR,
#         target_node_id_prop VARCHAR,
#         relation_type VARCHAR
#         -- Optional: FOREIGN KEY (source_node_id_prop) REFERENCES ExtractedEntity(id_prop),
#         -- Optional: FOREIGN KEY (target_node_id_prop) REFERENCES ExtractedEntity(id_prop)
#     );
#     """
#     # 也可以为关系表的 (source, target, type) 创建复合唯一索引或普通索引以加速查询
#     relation_index_ddl = """
#     CREATE INDEX IF NOT EXISTS idx_relation_source_target_type 
#     ON KGExtractionRelation (source_node_id_prop, target_node_id_prop, relation_type);
#     """
    
#     ddl_commands = [node_table_ddl, relation_table_ddl, relation_index_ddl]

#     try:
#         with duckdb_kg.get_connection() as conn:
#             context.log.info("Executing DuckDB DDL commands...")
#             for command_idx, command in enumerate(ddl_commands):
#                 context.log.debug(f"Executing DDL {command_idx+1}:\n{command.strip()}")
#                 conn.execute(command)
#             context.log.info("DuckDB Schema DDL commands executed successfully.")
#     except Exception as e_ddl:
#         context.log.error(f"Error during DuckDB schema creation: {e_ddl}", exc_info=True)
#         raise
#     context.log.info("--- DuckDB Schema Creation Asset Finished ---")


# @dg.asset(
#     name="duckdb_nodes", # <--- 修改资产名称
#     description="Loads all unique extracted entities as nodes into DuckDB.",
#     group_name="kg_building",
#     deps=[duckdb_schema_asset, kg_extraction_asset] # <--- 修改依赖
# )
# def duckdb_nodes_asset(
#     context: dg.AssetExecutionContext,
#     kg_extractions: List[KGTripleSetOutput], # 来自 kg_extraction_asset 的输出
#     duckdb_kg: DuckDBResource,               # <--- 修改资源参数
#     embedder: GGUFEmbeddingResource          # 保持对 embedder 的依赖，用于生成嵌入
# ):
#         # --- START: 移动并强化初始日志 ---
#     print("<<<<< duckdb_nodes_asset FUNCTION ENTERED - PRINTING TO STDOUT >>>>>", flush=True) 
#     # 尝试使用 context.log，如果它此时可用
#     try:
#         context.log.info("<<<<< duckdb_nodes_asset FUNCTION CALLED - VIA CONTEXT.LOG - VERY BEGINNING >>>>>")
#     except Exception as e_log_init:
#         print(f"Context.log not available at the very beginning of duckdb_nodes_asset: {e_log_init}", flush=True)
#     # --- END: 移动并强化初始日志 ---

#     context.log.info("--- Starting DuckDB Node Loading Asset (Using INSERT ON CONFLICT) ---")
#     if not kg_extractions:
#         context.log.warning("No KG extractions received. Skipping node loading.")
#         return

#     # +++ 新增调试日志：检查表是否存在 +++
#     try:
#         with duckdb_kg.get_connection() as conn_debug:
#             context.log.info("Attempting to list tables in DuckDB from duckdb_nodes_asset:")
#             tables = conn_debug.execute("SHOW TABLES;").fetchall()
#             context.log.info(f"Tables found: {tables}")
#             if any('"ExtractedEntity"' in str(table_row).upper() for table_row in tables) or \
#                any('ExtractedEntity' in str(table_row) for table_row in tables) : # 检查大小写不敏感的匹配
#                 context.log.info("Table 'ExtractedEntity' (or similar) IS visible at the start of duckdb_nodes_asset.")
#             else:
#                 context.log.warning("Table 'ExtractedEntity' IS NOT visible at the start of duckdb_nodes_asset. Schema asset might not have run correctly or changes are not reflected.")
#     except Exception as e_debug_show:
#         context.log.error(f"Error trying to list tables in duckdb_nodes_asset: {e_debug_show}")
#     # +++ 结束新增调试日志 +++
    
#     unique_nodes_data_for_insert: List[Dict[str, Any]] = []
#     unique_nodes_keys = set() # 用于在Python层面去重，避免多次尝试插入相同实体

#     for kg_set in kg_extractions:
#         for entity in kg_set.extracted_entities:
#             # 规范化文本和标签，用于生成唯一键和存储
#             normalized_text = normalize_text_for_id(entity.text)
#             normalized_label = entity.label.upper() # 确保标签大写
            
#             # 为实体生成唯一ID (基于规范化文本和标签的哈希值)
#             # 注意：如果同一个实体（相同文本和标签）在不同chunk中被提取，它们的id_prop会一样
#             node_id_prop = hashlib.md5(f"{normalized_text}_{normalized_label}".encode('utf-8')).hexdigest()
            
#             node_unique_key_for_py_dedup = (node_id_prop) # 使用id_prop进行Python层面的去重

#             if node_unique_key_for_py_dedup not in unique_nodes_keys:
#                 unique_nodes_keys.add(node_unique_key_for_py_dedup)
                
#                 # 生成嵌入向量 (与KuzuDB时逻辑相同)
#                 embedding_vector_list = embedder.encode([normalized_text]) # embedder.encode期望一个列表
#                 final_embedding_for_db: List[float]

#                 if embedding_vector_list and embedding_vector_list[0] and \
#                    isinstance(embedding_vector_list[0], list) and \
#                    len(embedding_vector_list[0]) == embedder.get_embedding_dimension():
#                     final_embedding_for_db = embedding_vector_list[0]
#                 else:
#                     context.log.warning(f"Failed to generate valid embedding for node: {normalized_text} ({normalized_label}). Using zero vector. Embedding result: {embedding_vector_list}")
#                     final_embedding_for_db = [0.0] * embedder.get_embedding_dimension()
                    
#                 unique_nodes_data_for_insert.append({
#                     "id_prop": node_id_prop,
#                     "text": normalized_text,
#                     "label": normalized_label,
#                     "embedding": final_embedding_for_db # DuckDB的FLOAT[]可以直接接受Python的List[float]
#                 })

#     if not unique_nodes_data_for_insert:
#         context.log.warning("No unique nodes found in extractions to load into DuckDB.")
#         return

#     nodes_processed_count = 0
#     nodes_inserted_count = 0
#     nodes_updated_count = 0

#     upsert_sql = f"""
#     INSERT INTO "ExtractedEntity" (id_prop, text, label, embedding)
#     VALUES (?, ?, ?, ?)
#     ON CONFLICT (id_prop) DO UPDATE SET
#         text = excluded.text,
#         label = excluded.label,
#         embedding = excluded.embedding;
#     """
#     # excluded.column_name 用于引用试图插入但导致冲突的值

#     try:
#         with duckdb_kg.get_connection() as conn:
#             context.log.info(f"Attempting to UPSERT {len(unique_nodes_data_for_insert)} unique nodes into DuckDB ExtractedEntity table...")
            
#             # DuckDB 支持 executemany 用于批量操作，但对于 ON CONFLICT，逐条执行或构造大型 VALUES 列表可能更直接
#             # 或者使用 pandas DataFrame + duckdb.register + CREATE TABLE AS / INSERT INTO SELECT
#             # 这里为了清晰，我们先用循环执行，对于几千到几万个节点，性能尚可接受
#             # 如果节点数量非常大 (几十万以上)，应考虑更优化的批量upsert策略

#             for node_data_dict in unique_nodes_data_for_insert:
#                 params = (
#                     node_data_dict["id_prop"],
#                     node_data_dict["text"],
#                     node_data_dict["label"],
#                     node_data_dict["embedding"]
#                 )
#                 try:
#                     # conn.execute() 对于 DML (如 INSERT, UPDATE) 不直接返回受影响的行数
#                     # 但我们可以假设它成功了，除非抛出异常
#                     conn.execute(upsert_sql, params)
#                     # 无法直接判断是insert还是update，除非查询前后对比，这里简化处理
#                     nodes_processed_count += 1 
#                 except Exception as e_upsert_item:
#                     context.log.error(f"Error UPSERTING node with id_prop {node_data_dict.get('id_prop')} into DuckDB: {e_upsert_item}", exc_info=True)
            
#             # 我们可以查一下表中的总行数来间接了解情况
#             total_rows_after = conn.execute('SELECT COUNT(*) FROM "ExtractedEntity"').fetchone()[0]
#             context.log.info(f"Successfully processed {nodes_processed_count} node upsert operations into DuckDB.")
#             context.log.info(f"Total rows in ExtractedEntity table after upsert: {total_rows_after}")

#     except Exception as e_db_nodes:
#         context.log.error(f"Error during DuckDB node loading: {e_db_nodes}", exc_info=True)
#         raise
    
#     context.add_output_metadata({
#         "nodes_prepared_for_upsert": len(unique_nodes_data_for_insert),
#         "nodes_processed_by_upsert_statement": nodes_processed_count,
#     })
#     context.log.info("--- DuckDB Node Loading Asset Finished ---")


# @dg.asset(
#     name="duckdb_relations", # <--- 修改资产名称
#     description="Loads all extracted relationships into DuckDB.",
#     group_name="kg_building",
#     deps=[duckdb_nodes_asset] # <--- 修改依赖
# )
# def duckdb_relations_asset(
#     context: dg.AssetExecutionContext, 
#     kg_extractions: List[KGTripleSetOutput], # 来自 kg_extraction_asset
#     duckdb_kg: DuckDBResource                # <--- 修改资源参数
# ):
#     context.log.info("--- Starting DuckDB Relation Loading Asset ---")
#     if not kg_extractions:
#         context.log.warning("No KG extractions received. Skipping relation loading.")
#         return

#     relations_to_insert: List[Dict[str, str]] = []
#     unique_relation_keys = set() # 用于在Python层面去重

#     for kg_set in kg_extractions:
#         for rel in kg_set.extracted_relations:
#             # 从实体文本和标签生成源节点和目标节点的ID (与 duckdb_nodes_asset 中一致)
#             source_node_text_norm = normalize_text_for_id(rel.head_entity_text)
#             source_node_label_norm = rel.head_entity_label.upper()
#             source_node_id = hashlib.md5(f"{source_node_text_norm}_{source_node_label_norm}".encode('utf-8')).hexdigest()

#             target_node_text_norm = normalize_text_for_id(rel.tail_entity_text)
#             target_node_label_norm = rel.tail_entity_label.upper()
#             target_node_id = hashlib.md5(f"{target_node_text_norm}_{target_node_label_norm}".encode('utf-8')).hexdigest()
            
#             relation_type_norm = rel.relation_type.upper()

#             # 为关系本身生成一个唯一ID
#             relation_unique_str = f"{source_node_id}_{relation_type_norm}_{target_node_id}"
#             relation_id = hashlib.md5(relation_unique_str.encode('utf-8')).hexdigest()

#             if relation_id not in unique_relation_keys:
#                 unique_relation_keys.add(relation_id)
#                 relations_to_insert.append({
#                     "relation_id": relation_id,
#                     "source_node_id_prop": source_node_id,
#                     "target_node_id_prop": target_node_id,
#                     "relation_type": relation_type_norm
#                 })
    
#     if not relations_to_insert:
#         context.log.warning("No unique relations found in extractions to load into DuckDB.")
#         return

#     relations_processed_count = 0
    
#     # 使用 INSERT INTO ... ON CONFLICT DO NOTHING 来避免插入重复的关系 (基于 relation_id)
#     insert_sql = """
#     INSERT INTO KGExtractionRelation (relation_id, source_node_id_prop, target_node_id_prop, relation_type)
#     VALUES (?, ?, ?, ?)
#     ON CONFLICT (relation_id) DO NOTHING;
#     """

#     try:
#         with duckdb_kg.get_connection() as conn:
#             context.log.info(f"Attempting to INSERT {len(relations_to_insert)} unique relations into DuckDB KGExtractionRelation table...")
            
#             for rel_data_dict in relations_to_insert:
#                 params = (
#                     rel_data_dict["relation_id"],
#                     rel_data_dict["source_node_id_prop"],
#                     rel_data_dict["target_node_id_prop"],
#                     rel_data_dict["relation_type"]
#                 )
#                 try:
#                     conn.execute(insert_sql, params)
#                     # DuckDB的execute对于INSERT ON CONFLICT DO NOTHING不直接返回是否插入
#                     # 但我们可以假设它成功处理了（要么插入，要么忽略）
#                     relations_processed_count += 1
#                 except Exception as e_insert_item:
#                     context.log.error(f"Error INSERTING relation with id {rel_data_dict.get('relation_id')} into DuckDB: {e_insert_item}", exc_info=True)
            
#             total_rels_after = conn.execute("SELECT COUNT(*) FROM KGExtractionRelation").fetchone()[0]
#             context.log.info(f"Successfully processed {relations_processed_count} relation insert (ON CONFLICT DO NOTHING) operations.")
#             context.log.info(f"Total rows in KGExtractionRelation table after inserts: {total_rels_after}")

#     except Exception as e_db_rels:
#         context.log.error(f"Error during DuckDB relation loading: {e_db_rels}", exc_info=True)
#         raise
        
#     context.add_output_metadata({
#         "relations_prepared_for_insert": len(relations_to_insert),
#         "relations_processed_by_insert_statement": relations_processed_count,
#     })
#     context.log.info("--- DuckDB Relation Loading Asset Finished ---")



# @dg.asset(
#     name="duckdb_vector_index", # <--- 修改资产名称
#     description="Creates the HNSW vector index on the embedding column in DuckDB.",
#     group_name="kg_building",
#     deps=[duckdb_relations_asset]  # <--- 修改依赖
# )
# def duckdb_vector_index_asset(
#     context: dg.AssetExecutionContext, 
#     duckdb_kg: DuckDBResource # <--- 修改资源参数
# ):
#     context.log.info("--- Starting DuckDB Vector Index Creation Asset ---")
    
#     table_to_index = "ExtractedEntity"
#     column_to_index = "embedding"
#     # 索引名可以自定义，通常包含表名、列名和类型
#     index_name = f"{table_to_index}_{column_to_index}_hnsw_idx"
#     metric_type = "l2sq" # 欧氏距离的平方，与我们测试时一致

#     # DuckDB 的 CREATE INDEX ... USING HNSW 语句
#     # IF NOT EXISTS 确保了幂等性
#     index_creation_sql = f"""
#     CREATE INDEX IF NOT EXISTS {index_name} 
#     ON {table_to_index} USING HNSW ({column_to_index}) 
#     WITH (metric='{metric_type}');
#     """

#     try:
#         with duckdb_kg.get_connection() as conn:
#             # 在创建索引前，确保vss扩展已加载且持久化已开启 (虽然DuckDBResource的setup已做)
#             try:
#                 conn.execute("LOAD vss;")
#                 conn.execute("SET hnsw_enable_experimental_persistence=true;")
#                 context.log.info("DuckDB: VSS extension loaded and HNSW persistence re-confirmed for index creation asset.")
#             except Exception as e_vss_setup_idx:
#                 context.log.warning(f"DuckDB: Failed to re-confirm VSS setup for index asset: {e_vss_setup_idx}. "
#                                      "Proceeding, assuming it was set by DuckDBResource.")

#             context.log.info(f"Executing DuckDB vector index creation command:\n{index_creation_sql.strip()}")
#             conn.execute(index_creation_sql)
#             context.log.info(f"DuckDB vector index '{index_name}' creation command executed successfully (or index already existed).")

#     except Exception as e_index_asset:
#         context.log.error(f"Error during DuckDB vector index creation: {e_index_asset}", exc_info=True)
#         raise
    
#     context.log.info("--- DuckDB Vector Index Creation Asset Finished ---")


# --- 更新 all_processing_assets 列表 ---
all_processing_assets = [
    clean_chunk_text_asset,
    generate_embeddings_asset,
    vector_storage_asset,
    keyword_index_asset,
    # kg_extraction_asset,
    # duckdb_schema_asset,
    # duckdb_nodes_asset,
    # duckdb_relations_asset,
    # duckdb_vector_index_asset,
]
```

    |-- pydantic_models_dagster.py

``` py
# zhz_rag_pipeline/pydantic_models_dagster.py
from typing import List, Dict, Any, Union, Optional, Literal
# --- 修改：从 pydantic 导入 BaseModel 和 Field ---
from pydantic import BaseModel, Field
# --- 修改结束 ---
import uuid
# from typing import List # 这行是多余的，因为上面已经从 typing 导入了 List

class LoadedDocumentOutput(BaseModel):
    document_path: str
    file_type: str
    # --- VITAL FIX: Make raw_content optional and always a string ---
    raw_content: Optional[str] = None # raw_content is now optional and will only hold decoded text
    metadata: Dict[str, Any]

# --- 修改：在 ParsedDocumentOutput 定义之前定义其依赖的 Element 类型 ---
class DocumentElementMetadata(BaseModel):
    """通用元数据，可附加到任何文档元素上"""
    page_number: Optional[int] = None
    source_coordinates: Optional[Dict[str, float]] = None # 例如，PDF中的bbox
    custom_properties: Optional[Dict[str, Any]] = None # 其他特定于元素的属性

class TitleElement(BaseModel):
    element_type: Literal["title"] = "title"
    text: str
    level: int # 例如 1 代表 H1, 2 代表 H2
    metadata: Optional[DocumentElementMetadata] = None

class NarrativeTextElement(BaseModel): # 普通段落文本
    element_type: Literal["narrative_text"] = "narrative_text"
    text: str
    metadata: Optional[DocumentElementMetadata] = None

class ListItemElement(BaseModel):
    element_type: Literal["list_item"] = "list_item"
    text: str
    level: int = 0 # 列表嵌套层级，0代表顶层列表项
    ordered: bool = False # True代表有序列表项, False代表无序
    item_number: Optional[Union[int, str]] = None # 例如 "1", "a", "*"
    metadata: Optional[DocumentElementMetadata] = None

class TableElement(BaseModel):
    element_type: Literal["table"] = "table"
    text_representation: Optional[str] = None 
    markdown_representation: Optional[str] = None
    html_representation: Optional[str] = None
    caption: Optional[str] = None
    metadata: Optional[DocumentElementMetadata] = None

class CodeBlockElement(BaseModel):
    element_type: Literal["code_block"] = "code_block"
    code: str
    language: Optional[str] = None
    metadata: Optional[DocumentElementMetadata] = None

class ImageElement(BaseModel): 
    element_type: Literal["image"] = "image"
    alt_text: Optional[str] = None
    caption: Optional[str] = None
    metadata: Optional[DocumentElementMetadata] = None

class PageBreakElement(BaseModel):
    element_type: Literal["page_break"] = "page_break"
    metadata: Optional[DocumentElementMetadata] = None
    
class HeaderElement(BaseModel):
    element_type: Literal["header"] = "header"
    text: str
    metadata: Optional[DocumentElementMetadata] = None

class FooterElement(BaseModel):
    element_type: Literal["footer"] = "footer"
    text: str
    metadata: Optional[DocumentElementMetadata] = None

DocumentElementType = Union[
    TitleElement, 
    NarrativeTextElement, 
    ListItemElement, 
    TableElement, 
    CodeBlockElement,
    ImageElement,
    PageBreakElement,
    HeaderElement,
    FooterElement
]

class ParsedDocumentOutput(BaseModel):
    parsed_text: str = Field(description="文档内容的线性化纯文本表示，尽可能保留语义。") 
    elements: List[DocumentElementType] = Field(default_factory=list, description="从文档中解析出的结构化元素列表。")
    original_metadata: Dict[str, Any] = Field(description="关于原始文档的元数据，如文件名、路径、大小等。")
    summary: Optional[str] = None
# --- 已有模型 ---
class ChunkOutput(BaseModel):
    chunk_id: str = Field(default_factory=lambda: str(uuid.uuid4())) # 确保 Field 被导入
    chunk_text: str
    source_document_id: str 
    chunk_metadata: Dict[str, Any]

class EmbeddingOutput(BaseModel):
    chunk_id: str 
    chunk_text: str 
    embedding_vector: List[float]
    embedding_model_name: str 
    original_chunk_metadata: Dict[str, Any]

class ExtractedEntity(BaseModel):
    text: str 
    label: str 

class ExtractedRelation(BaseModel):
    head_entity_text: str
    head_entity_label: str
    relation_type: str
    tail_entity_text: str
    tail_entity_label: str

class KGTripleSetOutput(BaseModel):
    chunk_id: str 
    extracted_entities: List[ExtractedEntity] = Field(default_factory=list)
    extracted_relations: List[ExtractedRelation] = Field(default_factory=list) 
    extraction_model_name: str 
    original_chunk_metadata: Dict[str, Any]
```

    |-- resources.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/resources.py

import logging
import dagster as dg
import chromadb
from typing import List, Dict, Any, Optional, Iterator
import httpx
import json
import os
from contextlib import asynccontextmanager, contextmanager # <--- 修正: 导入 contextmanager
from pydantic import Field as PydanticField, PrivateAttr
import asyncio
import time 
import duckdb
import sys
from queue import Empty
from pathlib import Path


# --- 日志和硬件管理器导入 ---
try:
    from zhz_rag.utils.interaction_logger import get_logger
except ImportError:
    import logging
    def get_logger(name: str) -> logging.Logger:
        logger = logging.getLogger(name)
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
        return logger

try:
    from zhz_rag.utils.hardware_manager import HardwareManager, HardwareInfo
except ImportError as e_hal_import:
    print(f"ERROR: Failed to import HardwareManager/HardwareInfo: {e_hal_import}. HAL features will be disabled.")
    HardwareManager = None
    HardwareInfo = None # type: ignore


# --- GGUFEmbeddingResource: API客户端版本 ---

class GGUFEmbeddingResourceConfig(dg.Config):
    api_url: str = PydanticField( # <--- 修正: 使用 PydanticField 别名
        default="http://127.0.0.1:8089",
        description="URL of the standalone embedding API service."
    )

class GGUFEmbeddingResource(dg.ConfigurableResource):
    api_url: str

    _client: httpx.AsyncClient = PrivateAttr()
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)
    _dimension: Optional[int] = PrivateAttr(default=None)
    _batch_size: int = PrivateAttr(default=128) # 提供一个保守的默认值

    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        self._client = httpx.AsyncClient(base_url=self.api_url, timeout=600.0) # 延长超时以适应大批量
        self._logger.info(f"GGUFEmbeddingResource configured to use API at: {self.api_url}")
        
        # 动态计算批处理大小
        try:
            # 假设SystemResource在依赖中，可以这样访问
            if "system_resource" in context.resources_by_key:
                system_resource = context.resources_by_key["system_resource"]
                # 基于CPU核心数推荐一个批处理大小
                # 这是一个启发式规则：物理核心越多，可以支持的并行处理能力越强
                # 假设每个核心可以轻松处理32-64个嵌入任务
                physical_cores = system_resource._hw_info.cpu_physical_cores if system_resource._hw_info else 4
                self._batch_size = max(128, physical_cores * 64) 
                self._logger.info(f"Dynamically set embedding batch size to {self._batch_size} based on {physical_cores} physical cores.")
            else:
                self._logger.warning("SystemResource not found in context, using default batch size of 128.")

        except Exception as e:
            self._logger.error(f"Failed to dynamically set batch size: {e}. Using default 128.", exc_info=True)

        # 健康检查
        try:
            response = httpx.get(f"{self.api_url}/health")
            response.raise_for_status()
            health_data = response.json()
            if health_data.get("model_loaded"):
                self._dimension = health_data.get("dimension")
                self._logger.info(f"Embedding service is healthy. Dimension confirmed: {self._dimension}")
            else:
                raise RuntimeError(f"Embedding service at {self.api_url} is not healthy.")
        except Exception as e:
            self._logger.error(f"Failed to connect to embedding service: {e}")
            raise RuntimeError("Could not initialize GGUFEmbeddingResource.") from e

    def teardown_for_execution(self, context: dg.InitResourceContext) -> None:
        if hasattr(self, '_client') and not self._client.is_closed:
            async def _close():
                await self._client.aclose()
            try:
                loop = asyncio.get_running_loop()
                loop.create_task(_close())
            except RuntimeError:
                asyncio.run(_close())
            self._logger.info("GGUFEmbeddingResource client closed.")

    def get_embedding_dimension(self) -> int:
        if self._dimension is None:
            raise ValueError("Embedding dimension not available.")
        return self._dimension

    def encode(self, texts: List[str], **kwargs: Any) -> List[List[float]]:
        if not texts:
            return []

        all_embeddings: List[List[float]] = []
        
        # --- 核心：批处理循环 ---
        for i in range(0, len(texts), self._batch_size):
            batch_texts = texts[i:i + self._batch_size]
            self._logger.info(f"Processing batch {i // self._batch_size + 1}/{(len(texts) + self._batch_size - 1) // self._batch_size} with {len(batch_texts)} texts.")
            
            async def _async_encode_batch():
                try:
                    response = await self._client.post("/embed", json={"texts": batch_texts})
                    response.raise_for_status()
                    data = response.json()
                    return data.get("embeddings", [])
                except httpx.RequestError as e:
                    self._logger.error(f"Request to embedding service failed for a batch: {e}")
                    return [[] for _ in batch_texts] # 返回空列表表示此批次失败
                except Exception as e:
                    self._logger.error(f"An unexpected error occurred during embedding a batch: {e}")
                    return [[] for _ in batch_texts]

            # 在循环内部执行异步调用
            try:
                loop = asyncio.get_running_loop()
                if loop.is_running():
                    future = asyncio.run_coroutine_threadsafe(_async_encode_batch(), loop)
                    batch_embeddings = future.result(timeout=600)
                else:
                    batch_embeddings = asyncio.run(_async_encode_batch())
            except RuntimeError:
                batch_embeddings = asyncio.run(_async_encode_batch())

            all_embeddings.extend(batch_embeddings)
            time.sleep(0.1) # 在批次之间加入一个微小的延迟，避免瞬间打爆API

        return all_embeddings

class ChromaDBResourceConfig(dg.Config):
    collection_name: str = PydanticField(
        default="zhz_rag_collection",
        description="Name of the ChromaDB collection."
    )
    persist_directory: str = PydanticField(
        # 确保路径与你的项目结构和期望的存储位置一致
        default=os.path.join(os.getenv("ZHZ_AGENT_PROJECT_ROOT", "/home/zhz/zhz_agent"), "zhz_rag", "stored_data", "chromadb_index"),
        description="Directory to persist ChromaDB data."
    )
    # 可以添加更多ChromaDB客户端的配置，例如auth, headers等
    # client_settings: Optional[Dict[str, Any]] = None # 例如 chromadb.Settings

class ChromaDBResource(dg.ConfigurableResource):
    collection_name: str
    persist_directory: str

    _client: Optional[chromadb.PersistentClient] = PrivateAttr(default=None)
    _collection: Optional[Any] = PrivateAttr(default=None)
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)
    _batch_size: int = PrivateAttr(default=4096) # ChromaDB的推荐批处理大小通常在4k-5k之间

    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        os.makedirs(self.persist_directory, exist_ok=True)
        self._logger.info(f"ChromaDB persist directory: {self.persist_directory}")
        
        try:
            self._client = chromadb.PersistentClient(path=self.persist_directory)
            self._logger.info(f"ChromaDB client initialized. Attempting to get or create collection: '{self.collection_name}'")
            self._collection = self._client.get_or_create_collection(name=self.collection_name)
            self._logger.info(f"Successfully got or created ChromaDB collection: '{self.collection_name}'. Collection ID: {self._collection.id}")
            self._logger.info(f"Current item count in collection '{self.collection_name}': {self._collection.count()}")
            # 我们可以根据ChromaDB的实际限制动态设置批处理大小，但为简单起见先用一个安全值
            # self._batch_size = chromadb.get_max_batch_size()
            self._logger.info(f"ChromaDB batch size set to: {self._batch_size}")
        except Exception as e:
            self._logger.error(f"Failed to initialize ChromaDB client or collection: {e}", exc_info=True)
            raise RuntimeError(f"Could not initialize ChromaDBResource due to: {e}") from e

    def teardown_for_execution(self, context: dg.InitResourceContext) -> None:
        if self._client:
            self._logger.info("ChromaDBResource teardown: Client was persistent, no explicit close needed.")
        self._client = None
        self._collection = None

    def add_embeddings(
        self, 
        ids: List[str], 
        embeddings: List[List[float]], 
        documents: Optional[List[str]] = None, 
        metadatas: Optional[List[Dict[str, Any]]] = None
    ) -> None:
        if self._collection is None:
            msg = "ChromaDB collection is not initialized. Cannot add embeddings."
            self._logger.error(msg)
            raise RuntimeError(msg)
        
        if not ids:
            self._logger.warning("add_embeddings called with empty IDs list. Nothing to add.")
            return

        total_items = len(ids)
        for i in range(0, total_items, self._batch_size):
            batch_end = min(i + self._batch_size, total_items)
            batch_ids = ids[i:batch_end]
            batch_embeddings = embeddings[i:batch_end]
            batch_documents = documents[i:batch_end] if documents else None
            batch_metadatas = metadatas[i:batch_end] if metadatas else None

            self._logger.info(
                f"Adding batch {i // self._batch_size + 1}/{(total_items + self._batch_size - 1) // self._batch_size} "
                f"with {len(batch_ids)} items to ChromaDB."
            )

            try:
                self._collection.add(
                    ids=batch_ids,
                    embeddings=batch_embeddings,
                    documents=batch_documents,
                    metadatas=batch_metadatas
                )
            except Exception as e:
                self._logger.error(
                    f"Failed to add batch starting at index {i} to ChromaDB: {e}",
                    exc_info=True
                )
                # 根据策略，您可以选择在此处继续、重试或直接抛出异常中断整个过程
                # 为确保数据完整性，我们选择抛出异常
                raise
        
        self._logger.info(f"Successfully added/updated all {total_items} items. Collection count now: {self._collection.count()}")

    def query_embeddings(
        self,
        query_embeddings: List[List[float]],
        n_results: int = 5,
        where_filter: Optional[Dict[str, Any]] = None,
        include: Optional[List[str]] = None
    ) -> Optional[Dict[str, Any]]:
        if self._collection is None:
            msg = "ChromaDB collection is not initialized. Cannot query embeddings."
            self._logger.error(msg)
            raise RuntimeError(msg)

        if include is None:
            include = ["metadatas", "documents", "distances"]

        try:
            self._logger.info(f"Querying collection '{self.collection_name}' with {len(query_embeddings)} vector(s), n_results={n_results}, filter={where_filter is not None}.")
            results = self._collection.query(
                query_embeddings=query_embeddings,
                n_results=n_results,
                where=where_filter,
                include=include
            )
            return results
        except Exception as e:
            self._logger.error(f"Failed to query embeddings from ChromaDB: {e}", exc_info=True)
            raise
        

class LocalLLMAPIResourceConfig(dg.Config):
    api_url: str = "http://127.0.0.1:8088/v1/chat/completions"
    default_temperature: float = 0.1
    default_max_new_tokens: int = 2048

class LocalLLMAPIResource(dg.ConfigurableResource):
    api_url: str
    default_temperature: float
    default_max_new_tokens: int
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)
    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        self._logger.info(f"LocalLLMAPIResource configured with API URL: {self.api_url}")
    async def generate_structured_output(self, prompt: str, json_schema: Dict[str, Any], temperature: Optional[float] = None, max_new_tokens: Optional[int] = None) -> Dict[str, Any]:
        logger_instance = self._logger if self._logger else dg.get_dagster_logger()
        temp_to_use = temperature if temperature is not None else self.default_temperature
        tokens_to_use = max_new_tokens if max_new_tokens is not None else self.default_max_new_tokens
        messages = [{"role": "user", "content": prompt}]
        payload = {"model": "local_kg_extraction_model", "messages": messages, "temperature": temp_to_use, "max_tokens": tokens_to_use, "response_format": {"type": "json_object", "schema": json_schema}}
        logger_instance.debug(f"Sending request to Local LLM Service. Prompt (start): {prompt[:100]}...")
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(300.0)) as client:
                response = await client.post(self.api_url, json=payload)
                response.raise_for_status()
                response_json = response.json()
                if response_json.get("choices") and response_json["choices"][0].get("message"):
                    generated_text = response_json["choices"][0]["message"].get("content", "")
                    return json.loads(generated_text)
                raise ValueError(f"Local LLM response format is incorrect: {response_json}")
        except Exception as e:
            logger_instance.error(f"Error during Local LLM call: {e}", exc_info=True)
            raise

class GeminiAPIResourceConfig(dg.Config):
    model_name: str = PydanticField(default="gemini/gemini-1.5-flash-latest", description="Name of the Gemini model.")
    proxy_url: Optional[str] = PydanticField(default_factory=lambda: os.getenv("LITELLM_PROXY_URL"), description="Optional proxy URL for LiteLLM.")
    default_temperature: float = 0.1
    default_max_tokens: int = 2048
    
class GeminiAPIResource(dg.ConfigurableResource):
    model_name: str
    proxy_url: Optional[str]
    default_temperature: float
    default_max_tokens: int
    _api_key: Optional[str] = PrivateAttr(default=None)
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)
    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        self._api_key = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY")
        if not self._api_key: self._logger.warning("Gemini API key not found.")
        else: self._logger.info(f"GeminiAPIResource initialized. Model: {self.model_name}, Proxy: {self.proxy_url or 'Not set'}")
    async def call_completion(self, messages: List[Dict[str, str]], temperature: Optional[float] = None, max_tokens: Optional[int] = None) -> Optional[str]:
        import litellm
        logger_instance = self._logger if self._logger else dg.get_dagster_logger()
        if not self._api_key: return None
        litellm_params = {"model": self.model_name, "messages": messages, "api_key": self._api_key, "temperature": temperature or self.default_temperature, "max_tokens": max_tokens or self.default_max_tokens}
        if self.proxy_url: litellm_params["proxy"] = {"http": self.proxy_url, "https": self.proxy_url}
        try:
            response = await litellm.acompletion(**litellm_params)
            return response.choices[0].message.content if response and response.choices else None
        except Exception as e:
            logger_instance.error(f"Error calling Gemini via LiteLLM: {e}", exc_info=True)
            return None
        
class DuckDBResource(dg.ConfigurableResource):
    db_file_path: str = PydanticField(
        default=os.path.join(os.getenv("ZHZ_AGENT_PROJECT_ROOT", "/home/zhz/zhz_agent"), "zhz_rag", "stored_data", "duckdb_knowledge_graph.db"),
        description="Path to the DuckDB database file."
    )
    _conn: Optional[duckdb.DuckDBPyConnection] = PrivateAttr(default=None)
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)

    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        self._logger.info("<<<<< DuckDBResource SETUP_FOR_EXECUTION - START >>>>>")

        os.makedirs(os.path.dirname(self.db_file_path), exist_ok=True)
        
        try:
            self._logger.info(f"Connecting to DuckDB at: {self.db_file_path}")
            self._conn = duckdb.connect(database=self.db_file_path, read_only=False)
            self._logger.info(f"Successfully connected to DuckDB at: {self.db_file_path}")

            self._logger.info("Attempting to INSTALL and LOAD vss extension.")
            self._conn.execute("INSTALL vss;")
            self._conn.execute("LOAD vss;")
            self._conn.execute("SET hnsw_enable_experimental_persistence=true;")
            self._logger.info("DuckDB VSS extension loaded and persistence enabled successfully.")

        except Exception as e:
            self._logger.error(f"Error during DuckDB connection or VSS setup: {e}", exc_info=True)
            error_str = str(e).lower()
            if "already installed" in error_str or "already loaded" in error_str:
                self._logger.warning(f"VSS extension seems to be already installed/loaded, continuing...")
            else:
                raise RuntimeError(f"DuckDB connection/VSS setup failed: {e}") from e
        
        self._logger.info("<<<<< DuckDBResource SETUP_FOR_EXECUTION - END >>>>>")

    def teardown_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger.info(">>>>> DuckDBResource TEARDOWN_FOR_EXECUTION - START <<<<<")
        if self._conn:
            try:
                self._logger.info(f"Executing CHECKPOINT on DuckDB connection for: {self.db_file_path}")
                self._conn.execute("CHECKPOINT;")
                self._logger.info(f"CHECKPOINT executed successfully for: {self.db_file_path}")
            except Exception as e_checkpoint:
                self._logger.error(f"Error executing CHECKPOINT for DuckDB: {e_checkpoint}", exc_info=True)
            finally:
                self._logger.info(f"Closing DuckDB connection for: {self.db_file_path}")
                self._conn.close()
                self._conn = None 
        else:
            self.logger.info("No active DuckDB connection to teardown.")
        self._logger.info(">>>>> DuckDBResource TEARDOWN_FOR_EXECUTION - END <<<<<")

    @contextmanager
    def get_connection(self) -> Iterator[duckdb.DuckDBPyConnection]:
        if not self._conn:
            raise ConnectionError("DuckDB connection not established. Ensure setup_for_execution was successful.")
        yield self._conn

class SystemResource(dg.ConfigurableResource):
    _hw_manager: Optional[Any] = PrivateAttr(default=None)
    _hw_info: Optional[Any] = PrivateAttr(default=None)
    _logger: Optional[dg.DagsterLogManager] = PrivateAttr(default=None)
    def setup_for_execution(self, context: dg.InitResourceContext) -> None:
        self._logger = context.log
        if HardwareManager:
            self._hw_manager = HardwareManager()
            self._hw_info = self._hw_manager.get_hardware_info()
            self._logger.info(f"SystemResource hardware detection: {self._hw_info}")
        else:
            self._logger.warning("HardwareManager not available.")
    def get_recommended_concurrent_tasks(self, task_type: str = "cpu_bound_llm") -> int:
        if self._hw_manager: return self._hw_manager.recommend_concurrent_tasks(task_type=task_type)
        return 1
```

        |-- __init__.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/__init__.py
import logging # 添加 logging 导入
from typing import Callable, Dict, Any, Optional, Union

# 尝试导入 Pydantic 模型，如果失败，则类型别名使用 Any
try:
    from ..pydantic_models_dagster import ParsedDocumentOutput
    _ParserOutputType = Optional[ParsedDocumentOutput]
except ImportError:
    _ParserOutputType = Optional[Any] # Fallback

# 定义一个类型别名，表示解析函数的签名
# 输入可以是路径(str)或内容(str/bytes)，元数据字典，返回Pydantic模型或字典
ParserFunction = Callable[[Union[str, bytes], Dict[str, Any]], _ParserOutputType]

# 从各个解析器模块导入主解析函数
from .md_parser import parse_markdown_to_structured_output
from .docx_parser import parse_docx_to_structured_output
from .pdf_parser import parse_pdf_to_structured_output
from .xlsx_parser import parse_xlsx_to_structured_output
from .html_parser import parse_html_to_structured_output
from .txt_parser import parse_txt_to_structured_output

logger = logging.getLogger(__name__) # 添加 logger 实例

# 创建一个解析器注册表 (合并自 parser_dispatcher.py)
PARSER_REGISTRY: Dict[str, ParserFunction] = {
    ".md": parse_markdown_to_structured_output,
    ".docx": parse_docx_to_structured_output,
    ".pdf": parse_pdf_to_structured_output,
    ".xlsx": parse_xlsx_to_structured_output,
    ".html": parse_html_to_structured_output,
    ".htm": parse_html_to_structured_output,  # Alias for html
    ".txt": parse_txt_to_structured_output,
}

def dispatch_parsing( # 合并自 parser_dispatcher.py
    file_extension: str,
    content_or_path: Union[str, bytes], # 确保这里是 Union[str, bytes]
    original_metadata: Dict[str, Any]
) -> Optional[Any]: # 返回 Optional[Any] 以匹配下游期望
    parser_func = PARSER_REGISTRY.get(file_extension.lower())
    if parser_func:
        try:
            # 调用相应的解析函数
            # txt_parser 和 md_parser, html_parser 期望 content_str
            # docx_parser, pdf_parser, xlsx_parser 期望 file_path
            # content_or_path 变量在 ingestion_assets.py 中已经根据 file_ext 做了区分
            return parser_func(content_or_path, original_metadata)
        except Exception as e:
            logger.error(f"Error calling parser for '{file_extension}' on '{original_metadata.get('source_file_path', 'N/A')}': {e}", exc_info=True)
            return None # 解析失败返回 None
    else:
        logger.warning(f"No specific parser registered for file type '{file_extension}'.")
        # 尝试一个通用的纯文本提取作为最终回退（如果适用且有实现）
        # 或者直接返回None
        return None

def get_parser(file_extension: str) -> Optional[ParserFunction]: # 保留此函数以防其他地方用到
    return PARSER_REGISTRY.get(file_extension.lower())

__all__ = [
    "parse_markdown_to_structured_output",
    "parse_docx_to_structured_output",
    "parse_pdf_to_structured_output",
    "parse_xlsx_to_structured_output",
    "parse_html_to_structured_output",
    "parse_txt_to_structured_output",
    "get_parser", # 保留
    "dispatch_parsing", # 新增导出
    "PARSER_REGISTRY",
    "ParserFunction"
]
```

        |-- docx_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/docx_parser.py

import os
from typing import List, Dict, Any, Optional, Union
import re

# --- 添加：为当前模块的 logger 进行基本配置 ---
import logging
logger = logging.getLogger(__name__)
if not logger.handlers: # 避免重复添加 handler (如果模块被多次导入)
    handler = logging.StreamHandler() # 输出到 stderr，通常会被 Dagster 捕获
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO) # 设置希望看到的最低日志级别 (INFO, DEBUG等)
    # logger.propagate = False # 可以考虑设置，防止日志向上传播到根logger导致重复打印，但通常 Dagster 会处理好
logger.info(f"Logger for {__name__} configured in docx_parser.py.") # 确认配置生效
# --- 结束添加 ---

# --- 依赖导入与可用性检查 ---
try:
    from unstructured.partition.docx import partition_docx
    from unstructured.documents.elements import (
        Element as UnstructuredElement,
        Text, 
        NarrativeText,
        Title,
        ListItem,
        Table,
        Image as UnstructuredImage, 
        Header as UnstructuredHeader, 
        Footer as UnstructuredFooter, 
        Address,
        EmailAddress,
        FigureCaption,
        PageBreak as UnstructuredPageBreak, 
        CodeSnippet
    )
    _UNSTRUCTURED_AVAILABLE_DOCX = True
    logging.info("Successfully imported Unstructured for DOCX parsing.")
except ImportError as e_unstructured:
    logging.error(f"Failed to import Unstructured for DOCX: {e_unstructured}. DOCX parsing will have limited functionality.")
    _UNSTRUCTURED_AVAILABLE_DOCX = False
    # 创建占位符类以避免后续 NameError
    class UnstructuredElement: pass
    class Text: pass                  # type: ignore
    class NarrativeText: pass          # type: ignore
    class Title: pass                  # type: ignore
    class ListItem: pass               # type: ignore
    class Table: pass                  # type: ignore
    class UnstructuredImage: pass      # type: ignore
    class UnstructuredHeader: pass     # type: ignore
    class UnstructuredFooter: pass     # type: ignore
    class Address: pass                # type: ignore
    class EmailAddress: pass           # type: ignore
    class FigureCaption: pass          # type: ignore
    class UnstructuredPageBreak: pass  # type: ignore
    class CodeSnippet: pass            # type: ignore

try:
    from markdownify import markdownify as md # type: ignore
    _MARKDOWNIFY_AVAILABLE = True
except ImportError:
    logging.warning("markdownify library not found. HTML table to Markdown conversion will be skipped.")
    _MARKDOWNIFY_AVAILABLE = False
    def md(html_content: str) -> str: # Fallback
        return f"[Markdownify not available. HTML content: {html_content[:100]}...]"

_PYDANTIC_MODELS_AVAILABLE_DOCX = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, DocumentElementType, TitleElement, NarrativeTextElement,
        ListItemElement, TableElement, CodeBlockElement, PageBreakElement, ImageElement,
        HeaderElement, FooterElement, DocumentElementMetadata
    )
    _PYDANTIC_MODELS_AVAILABLE_DOCX = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class TitleElement(BaseModel): element_type:str="title"; text:str; level:int; metadata: Optional[DocumentElementMetadata] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class ListItemElement(BaseModel): element_type:str="list_item"; text:str; level:int=0; ordered:bool=False; item_number:Optional[Union[int, str]]=None; metadata: Optional[DocumentElementMetadata] = None
    class TableElement(BaseModel): # <--- 修改此行
        element_type:str="table"; 
        markdown_representation:Optional[str]=None; 
        html_representation:Optional[str]=None; 
        text_representation:Optional[str]=None; # <--- 添加此字段
        caption:Optional[str]=None; 
        metadata: Optional[DocumentElementMetadata] = None
    class CodeBlockElement(BaseModel): element_type:str="code_block"; code:str; language:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class PageBreakElement(BaseModel): element_type:str="page_break"; metadata: Optional[DocumentElementMetadata] = None
    class ImageElement(BaseModel): element_type:str="image"; alt_text:Optional[str]=None; caption:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class HeaderElement(BaseModel): element_type:str="header"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class FooterElement(BaseModel): element_type:str="footer"; text:str; metadata: Optional[DocumentElementMetadata] = None
    DocumentElementType = Any

logger = logging.getLogger(__name__)

# --- 辅助函数 ---
def _create_doc_element_metadata(unstructured_element: UnstructuredElement) -> Optional[Union[DocumentElementMetadata, Dict[str, Any]]]:
    if not hasattr(unstructured_element, 'metadata'):
        return None
        
    meta_data_dict: Dict[str, Any] = {}
    if hasattr(unstructured_element.metadata, 'page_number') and unstructured_element.metadata.page_number is not None:
        meta_data_dict['page_number'] = unstructured_element.metadata.page_number
    
    if hasattr(unstructured_element.metadata, 'filename'):
        meta_data_dict['source_filename'] = unstructured_element.metadata.filename
    if hasattr(unstructured_element.metadata, 'filetype'):
        meta_data_dict['source_filetype'] = unstructured_element.metadata.filetype

    if not meta_data_dict:
        return None

    if _PYDANTIC_MODELS_AVAILABLE_DOCX:
        return DocumentElementMetadata(**meta_data_dict)
    else:
        return meta_data_dict

def _convert_unstructured_elements_to_custom(
    unstructured_elements: List[UnstructuredElement], 
    doc_path_for_log: str # 添加一个参数用于日志记录
) -> List[Any]:
    custom_elements: List[Any] = []
    
    file_basename_for_log = os.path.basename(doc_path_for_log)

    # --- 使用 print 进行强制调试 ---
    logger.info(f"DOCX Parser ({file_basename_for_log}): _convert_unstructured_elements_to_custom received {len(unstructured_elements)} elements from unstructured.")
    if not unstructured_elements:
        logger.warning(f"DOCX Parser ({file_basename_for_log}): Unstructured returned an empty list of elements. No custom elements will be generated by this function initially.")
    
    if not _UNSTRUCTURED_AVAILABLE_DOCX:
        logger.warning(f"DOCX Parser ({file_basename_for_log}): Unstructured library is not available (should have been caught earlier).")
        # 作为回退，我们可以尝试将每个元素的文本提取为 NarrativeTextElement (如果 unstructured_elements 非空但 _UNSTRUCTURED_AVAILABLE_DOCX 意外为 False)
        for el_idx, el_fallback in enumerate(unstructured_elements):
            fallback_text = getattr(el_fallback, 'text', f"[Unstructured not fully available - Element {el_idx+1} in {file_basename_for_log}]").strip()
            if fallback_text:
                if _PYDANTIC_MODELS_AVAILABLE_DOCX:
                    custom_elements.append(NarrativeTextElement(text=fallback_text))
                else:
                    custom_elements.append({"element_type": "narrative_text", "text": fallback_text})
        return custom_elements

    for el_idx, el in enumerate(unstructured_elements):
        el_type_name = type(el).__name__
        el_id_str = getattr(el, 'id', 'N/A')
        el_text_preview = getattr(el, 'text', '')[:50].strip().replace('\n', ' ') if getattr(el, 'text', '') else "[NO TEXT]"
        # --- 修改日志级别 ---
        logger.debug( # <--- 从 info 修改为 debug
            f"DOCX Parser ({file_basename_for_log}): Processing unstructured element index {el_idx}, "
            f"Type: {el_type_name}, ID: {el_id_str}, Text Preview: '{el_text_preview}'"
        )
        
        # 打印 el.metadata.text_as_html 的预览（如果存在）
        html_preview_from_meta = getattr(el.metadata, 'text_as_html', None) if hasattr(el, 'metadata') else None
        if html_preview_from_meta:
            logger.debug( # <--- 从 info 修改为 debug
                f"  └─ ({file_basename_for_log}) Unstructured Element (idx {el_idx}, type {el_type_name}) has text_as_html (len: {len(html_preview_from_meta)}). Preview: {html_preview_from_meta[:70]}"
            )
        # --- 结束修改 ---
        
        element_metadata = _create_doc_element_metadata(el)
        el_text = el.text.strip() if hasattr(el, 'text') and el.text else ""
        custom_el: Optional[Any] = None

        if isinstance(el, Title):
            level = el.metadata.category_depth if hasattr(el.metadata, 'category_depth') and el.metadata.category_depth is not None else 1
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is Title (level {level}).")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = TitleElement(text=el_text, level=level, metadata=element_metadata)
                else: custom_el = {"element_type": "title", "text": el_text, "level": level, "metadata": element_metadata}
        
        elif isinstance(el, ListItem):
            level = el.metadata.category_depth if hasattr(el.metadata, 'category_depth') and el.metadata.category_depth is not None else 0
            # 尝试从元数据获取更精确的列表信息 (unstructured 可能提供)
            # item_number 和 ordered 的逻辑可以根据 unstructured 的实际输出来完善
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is ListItem (level {level}).")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = ListItemElement(text=el_text, level=level, metadata=element_metadata)
                else: custom_el = {"element_type": "list_item", "text": el_text, "level": level, "metadata": element_metadata}

        elif isinstance(el, Table):
            logger.info(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} IS an unstructured.documents.elements.Table object.")
            html_table = el.metadata.text_as_html if hasattr(el.metadata, 'text_as_html') else None
            
            if html_table:
                logger.info(f"DOCX Parser ({file_basename_for_log}): Found HTML table content for Table element (idx {el_idx}). Length: {len(html_table)}. Preview: {html_table[:150]}")
            else:
                logger.warning(f"DOCX Parser ({file_basename_for_log}): No HTML table content (el.metadata.text_as_html) found for Table element (idx {el_idx}) from unstructured. Element ID: {el.id if hasattr(el, 'id') else 'N/A'}")

            md_table = None
            if html_table and _MARKDOWNIFY_AVAILABLE:
                try: 
                    md_table = md(html_table)
                    logger.info(f"DOCX Parser ({file_basename_for_log}): Successfully converted HTML table (idx {el_idx}) to Markdown. MD Length: {len(md_table) if md_table else 0}")
                except Exception as e_md: 
                    logger.warning(f"DOCX Parser ({file_basename_for_log}): Failed to convert HTML table (idx {el_idx}) to Markdown: {e_md}. HTML: {html_table[:100]}")
            
            raw_table_text_fallback = el.text.strip() if hasattr(el, 'text') and el.text else None
            caption_text = None
            if hasattr(el.metadata, 'table_captions') and el.metadata.table_captions:
                    caption_obj = el.metadata.table_captions[0]
                    if hasattr(caption_obj, 'text'):
                            caption_text = caption_obj.text
            
            if not caption_text and hasattr(el.metadata, 'filename'): # Redundant if filename is always doc_path_for_log
                    caption_text = f"Table from {file_basename_for_log}" # Use basename
            final_caption = caption_text if caption_text else "Table"

            final_md_table = md_table
            final_html_table = html_table
            final_text_representation = None

            if not final_md_table and not final_html_table and raw_table_text_fallback:
                logger.info(f"DOCX Parser ({file_basename_for_log}): Table (idx {el_idx}) has no HTML/MD rep, but has raw text from unstructured: '{raw_table_text_fallback[:100]}...' Using it as text_representation.")
                final_text_representation = raw_table_text_fallback
            elif not final_md_table and not final_html_table and not raw_table_text_fallback:
                    logger.warning(f"DOCX Parser ({file_basename_for_log}): Table (idx {el_idx}) has no HTML, Markdown, or raw text representation from unstructured.")


            if _PYDANTIC_MODELS_AVAILABLE_DOCX: 
                custom_el = TableElement(
                    markdown_representation=final_md_table, 
                    html_representation=final_html_table, 
                    text_representation=final_text_representation,
                    caption=final_caption, 
                    metadata=element_metadata
                )
            else: 
                custom_el = {
                    "element_type": "table", 
                    "markdown_representation": final_md_table, 
                    "html_representation": final_html_table, 
                    "text_representation": final_text_representation,
                    "caption": final_caption, 
                    "metadata": element_metadata
                }
        
        elif isinstance(el, (NarrativeText, Text, Address, EmailAddress, FigureCaption)):
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is NarrativeText/Text like.")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = NarrativeTextElement(text=el_text, metadata=element_metadata)
                else: custom_el = {"element_type": "narrative_text", "text": el_text, "metadata": element_metadata}
        
        elif isinstance(el, UnstructuredHeader):
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is Header.")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = HeaderElement(text=el_text, metadata=element_metadata)
                else: custom_el = {"element_type": "header", "text": el_text, "metadata": element_metadata}
        
        elif isinstance(el, UnstructuredFooter):
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is Footer.")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = FooterElement(text=el_text, metadata=element_metadata)
                else: custom_el = {"element_type": "footer", "text": el_text, "metadata": element_metadata}

        elif isinstance(el, UnstructuredImage):
            alt_text = el_text if el_text else (el.metadata.filename if hasattr(el.metadata, 'filename') else "Image")
            logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is Image. Alt text: {alt_text}")
            if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = ImageElement(alt_text=alt_text, metadata=element_metadata)
            else: custom_el = {"element_type": "image", "alt_text": alt_text, "metadata": element_metadata}

        elif isinstance(el, UnstructuredPageBreak):
            logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is PageBreak.")
            if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = PageBreakElement(metadata=element_metadata)
            else: custom_el = {"element_type": "page_break", "metadata": element_metadata}
        
        elif isinstance(el, CodeSnippet):
            if el_text:
                logger.debug(f"DOCX Parser ({file_basename_for_log}): Element index {el_idx} is CodeSnippet.")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = CodeBlockElement(code=el_text, metadata=element_metadata) # language can be inferred later if needed
                else: custom_el = {"element_type": "code_block", "code": el_text, "metadata": element_metadata}

        else: 
            # This is the catch-all for any other Unstructured element type
            # or if an element doesn't have text but we still want to represent it (though usually skipped if no text)
            if el_text: # Only create an element if there's text
                logger.warning(f"DOCX Parser ({file_basename_for_log}): Unhandled Unstructured element type: {el_type_name} at index {el_idx}. Treating as NarrativeText. Text: {el_text[:50]}")
                if _PYDANTIC_MODELS_AVAILABLE_DOCX: custom_el = NarrativeTextElement(text=el_text, metadata=element_metadata)
                else: custom_el = {"element_type": "narrative_text", "text": el_text, "_unstructured_type": el_type_name, "metadata": element_metadata}
            elif el_type_name != "CompositeElement": # CompositeElement often has no direct text but contains other elements
                    logger.debug(f"DOCX Parser ({file_basename_for_log}): Skipping Unstructured element type: {el_type_name} at index {el_idx} due to no text content.")

        if custom_el:
            custom_elements.append(custom_el)
            
    return custom_elements


def _generate_linear_text_from_custom_elements(elements: List[Any]) -> str:
    text_parts = []
    for el_data_any in elements:
        el_data: Dict[str, Any] = {}
        if _PYDANTIC_MODELS_AVAILABLE_DOCX and hasattr(el_data_any, 'model_dump'):
            el_data = el_data_any.model_dump(exclude_none=True)
        elif isinstance(el_data_any, dict):
            el_data = el_data_any
        else:
            continue

        el_type = el_data.get("element_type")
        text_content = el_data.get("text", "")
        
        current_element_text = ""
        if el_type == "title":
            current_element_text = f"\n{'#' * el_data.get('level',1)} {text_content}\n"
        elif el_type == "narrative_text":
            current_element_text = text_content + "\n"
        elif el_type == "list_item":
            prefix = f"{el_data.get('item_number', '')}. " if el_data.get('ordered') and el_data.get('item_number') else "- "
            indent = "  " * el_data.get('level', 0)
            current_element_text = f"{indent}{prefix}{text_content}\n"
        elif el_type == "table":
            caption = el_data.get('caption', 'Unnamed Table')
            md_repr = el_data.get('markdown_representation')
            if md_repr: current_element_text = f"\n[Table: {caption}]\n{md_repr}\n"
            elif el_data.get('html_representation'): current_element_text = f"\n[Table (HTML): {caption}]\n{el_data.get('html_representation')[:200]}...\n"
        elif el_type == "code_block":
            lang = el_data.get('language', "") or ""
            code_content = el_data.get('code', "")
            current_element_text = f"\n```{lang}\n{code_content}\n```\n"
        elif el_type == "page_break":
            current_element_text = "\n---\n"
        elif el_type == "header" or el_type == "footer":
            current_element_text = f"\n[{el_type.capitalize()}]: {text_content}\n"
        elif el_type == "image":
            alt_text = el_data.get('alt_text', 'Image')
            current_element_text = f"\n[Image: {alt_text}]\n"
        
        if current_element_text:
            text_parts.append(current_element_text)

    full_text = "".join(text_parts)
    full_text = re.sub(r'\n{3,}', '\n\n', full_text).strip() # Clean up excessive newlines
    return full_text


# --- 主解析函数 ---
def parse_docx_to_structured_output(
    file_path: str, 
    original_metadata: Dict[str, Any]
) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    file_basename_for_log = os.path.basename(file_path)
    
    # --- 使用 print 进行强制调试 ---
    logger.info(f"DOCX Parser: Attempting to parse DOCX file: {file_basename_for_log} using Unstructured")
    
    if not _UNSTRUCTURED_AVAILABLE_DOCX:
        logger.error(f"DOCX Parser ({file_basename_for_log}): Unstructured library is not available. DOCX parsing cannot proceed.")
        return None
    try:
        unstructured_elements = partition_docx(
            filename=file_path, 
            strategy="fast", 
            infer_table_structure=True,
        )
        logger.info(f"DOCX Parser ({file_basename_for_log}): Unstructured partitioned DOCX. Found {len(unstructured_elements)} raw elements from partition_docx.")

        custom_elements = _convert_unstructured_elements_to_custom(unstructured_elements, file_path)
        logger.info(f"DOCX Parser ({file_basename_for_log}): _convert_unstructured_elements_to_custom created {len(custom_elements)} custom elements.")
        
        linear_text = _generate_linear_text_from_custom_elements(custom_elements)
        logger.info(f"DOCX Parser ({file_basename_for_log}): Generated linear text (len: {len(linear_text)}). Preview: {linear_text[:100].replace(chr(10), ' ')}")

        if not custom_elements and not linear_text.strip() and unstructured_elements:
            logger.warning(f"DOCX Parser ({file_basename_for_log}): partition_docx returned {len(unstructured_elements)} elements, "
                            "but no custom elements or linear text were generated. This might indicate all elements were skipped "
                            "or had no text content suitable for conversion.")
        elif not custom_elements and not linear_text.strip() and not unstructured_elements:
                logger.warning(f"DOCX Parser ({file_basename_for_log}): partition_docx returned 0 elements, "
                                "and no custom elements or linear text were generated.")

        if _PYDANTIC_MODELS_AVAILABLE_DOCX:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=custom_elements, 
                original_metadata=original_metadata
            )
        else:
            return {
                "parsed_text": linear_text,
                "elements": custom_elements,
                "original_metadata": original_metadata
            }
            
    except FileNotFoundError:
        logger.error(f"DOCX Parser ({file_basename_for_log}): File not found: {file_path}")
        return None
    except ImportError as ie:
        logger.error(f"DOCX Parser ({file_basename_for_log}): ImportError during DOCX parsing with Unstructured: {ie}.")
        return None
    except Exception as e:
        logger.error(f"DOCX Parser ({file_basename_for_log}): Critical error parsing DOCX file: {e}", exc_info=True)
        error_message = f"[ERROR PARSING DOCX: {file_basename_for_log} - {type(e).__name__}: {str(e)}]"
        if _PYDANTIC_MODELS_AVAILABLE_DOCX:
            return ParsedDocumentOutput(
                parsed_text=error_message,
                elements=[],
                original_metadata=original_metadata
            )
        else:
            return {
                "parsed_text": error_message,
                "elements": [],
                "original_metadata": original_metadata
            }
```

        |-- html_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/html_parser.py
import os
import logging
from typing import List, Dict, Any, Optional, Union, Set
import re

try:
    from bs4 import BeautifulSoup, Tag, NavigableString
    _BS4_AVAILABLE = True
    logging.info("Successfully imported BeautifulSoup4 for HTML parsing.")
except ImportError:
    logging.error("BeautifulSoup4 (bs4) not found. HTML parsing will not be available.")
    _BS4_AVAILABLE = False
    class BeautifulSoup: pass # Placeholder
    class Tag: pass
    class NavigableString: pass


_PYDANTIC_MODELS_AVAILABLE_HTML = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, DocumentElementType, TitleElement, NarrativeTextElement,
        ListItemElement, TableElement, CodeBlockElement, PageBreakElement,
        DocumentElementMetadata
    )
    _PYDANTIC_MODELS_AVAILABLE_HTML = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class TitleElement(BaseModel): element_type:str="title"; text:str; level:int; metadata: Optional[DocumentElementMetadata] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class ListItemElement(BaseModel): element_type:str="list_item"; text:str; level:int=0; ordered:bool=False; item_number:Optional[Union[int, str]]=None; metadata: Optional[DocumentElementMetadata] = None
    class TableElement(BaseModel): element_type:str="table"; markdown_representation:Optional[str]=None; html_representation:Optional[str]=None; caption:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class CodeBlockElement(BaseModel): element_type:str="code_block"; code:str; language:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class PageBreakElement(BaseModel): element_type:str="page_break"; metadata: Optional[DocumentElementMetadata] = None
    DocumentElementType = Any

logger = logging.getLogger(__name__)

# Tags to typically ignore for main content extraction
IGNORE_TAGS_HTML = ['script', 'style', 'nav', 'footer', 'header', 'aside', 'form', 'meta', 'link', 'button', 'input', 'noscript', 'iframe', 'canvas', 'svg', 'path']
# Tags that define a semantic block but we want to process their children
CONTAINER_TAGS_HTML = ['div', 'section', 'article', 'main', 'body', 'figure', 'figcaption', 'details', 'summary']


def _table_to_markdown(table_tag: Tag) -> str:
    """Converts a BeautifulSoup table Tag to a Markdown string."""
    md_rows = []
    header_processed = False
    
    # Process header (thead)
    thead = table_tag.find('thead')
    if thead:
        header_rows_tags = thead.find_all('tr')
        for hr_tag in header_rows_tags:
            header_cells = hr_tag.find_all(['th', 'td'])
            if header_cells:
                header_texts = [cell.get_text(separator=' ', strip=True) for cell in header_cells]
                md_rows.append("| " + " | ".join(header_texts) + " |")
                if not header_processed: # Add separator only after the first header row group
                    md_rows.append("| " + " | ".join(["---"] * len(header_texts)) + " |")
                    header_processed = True
    
    # Process body (tbody or direct tr in table)
    tbody = table_tag.find('tbody')
    if not tbody: # If no tbody, look for tr directly under table
        rows_to_process = table_tag.find_all('tr', recursive=False)
    else:
        rows_to_process = tbody.find_all('tr')
        
    for row_tag in rows_to_process:
        # Skip if this row was already processed as part of thead (if thead was missing)
        if not header_processed and row_tag.find('th'):
            header_cells = row_tag.find_all(['th', 'td'])
            header_texts = [cell.get_text(separator=' ', strip=True) for cell in header_cells]
            md_rows.append("| " + " | ".join(header_texts) + " |")
            md_rows.append("| " + " | ".join(["---"] * len(header_texts)) + " |")
            header_processed = True
            continue
        
        cell_texts = [cell.get_text(separator=' ', strip=True) for cell in row_tag.find_all('td')]
        if cell_texts: # Only add row if it has content
            md_rows.append("| " + " | ".join(cell_texts) + " |")
            
    return "\n".join(md_rows)

def _convert_html_tag_to_elements_recursive(tag: Tag, elements_list: List[Any], processed_tags: Set[Tag], current_list_level: int = 0):
    """
    Recursively processes a BeautifulSoup Tag and its children to extract structured elements.
    Modifies elements_list in place.
    """
    if tag in processed_tags or not isinstance(tag, Tag) or tag.name in IGNORE_TAGS_HTML:
        return

    tag_name = tag.name.lower()
    element_metadata = None # Placeholder for now, can be enhanced to include source line numbers etc.
    
    created_element = False

    if tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
        level = int(tag_name[1:])
        text = tag.get_text(strip=True)
        if text:
            if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(TitleElement(text=text, level=level, metadata=element_metadata))
            else: elements_list.append({"element_type": "title", "text": text, "level": level, "metadata": element_metadata})
            created_element = True
    
    elif tag_name == 'p':
        text = tag.get_text(strip=True)
        if text:
            if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(NarrativeTextElement(text=text, metadata=element_metadata))
            else: elements_list.append({"element_type": "narrative_text", "text": text, "metadata": element_metadata})
            created_element = True

    elif tag_name in ['ul', 'ol']:
        ordered = tag_name == 'ol'
        start_num = int(tag.get('start', '1')) if ordered else 1
        
        # Iterate over direct children that are <li>
        direct_li_children = [child for child in tag.children if isinstance(child, Tag) and child.name == 'li']
        for i, li_tag in enumerate(direct_li_children):
            if li_tag in processed_tags: continue
            
            # Extract text directly under <li>, excluding text from nested lists
            li_text_parts = []
            for content_child in li_tag.contents:
                if isinstance(content_child, NavigableString):
                    stripped_text = content_child.strip()
                    if stripped_text: li_text_parts.append(stripped_text)
                elif isinstance(content_child, Tag) and content_child.name not in ['ul', 'ol']: # Get text from non-list children
                    li_text_parts.append(content_child.get_text(strip=True))
            
            final_li_text = " ".join(li_text_parts).strip()

            if final_li_text:
                item_num_str = str(start_num + i) if ordered else None
                if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(ListItemElement(text=final_li_text, level=current_list_level, ordered=ordered, item_number=item_num_str, metadata=element_metadata))
                else: elements_list.append({"element_type": "list_item", "text": final_li_text, "level": current_list_level, "ordered": ordered, "item_number": item_num_str, "metadata": element_metadata})
            
            processed_tags.add(li_tag) # Mark <li> as processed for its direct text
            # Recursively process children of this <li> for nested lists or other elements
            for child_of_li in li_tag.children:
                if isinstance(child_of_li, Tag):
                     _convert_html_tag_to_elements_recursive(child_of_li, elements_list, processed_tags, current_list_level + 1)
        created_element = True # The list itself is an element boundary

    elif tag_name == 'table':
        md_table = _table_to_markdown(tag)
        caption_tag = tag.find('caption')
        caption_text = caption_tag.get_text(strip=True) if caption_tag else None
        if md_table or caption_text : # Only add if table has content or caption
            if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(TableElement(markdown_representation=md_table, html_representation=str(tag), caption=caption_text, metadata=element_metadata))
            else: elements_list.append({"element_type": "table", "markdown_representation": md_table, "html_representation": str(tag), "caption": caption_text, "metadata": element_metadata})
        created_element = True

    elif tag_name == 'pre':
        code_tag = tag.find('code')
        code_text, lang = "", None
        if code_tag:
            code_text = code_tag.get_text() # Keep original spacing and newlines
            lang_class = code_tag.get('class', [])
            if lang_class: lang = next((cls.split('language-')[-1] for cls in lang_class if cls.startswith('language-')), None)
        else:
            code_text = tag.get_text()
        
        if code_text.strip(): # Check if there's actual code
            if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(CodeBlockElement(code=code_text.strip('\n'), language=lang, metadata=element_metadata))
            else: elements_list.append({"element_type": "code_block", "code": code_text.strip('\n'), "language": lang, "metadata": element_metadata})
        created_element = True

    elif tag_name == 'blockquote':
        text = tag.get_text(strip=True)
        if text:
            if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(NarrativeTextElement(text=text, metadata=element_metadata))
            else: elements_list.append({"element_type": "narrative_text", "text": text, "_is_blockquote": True, "metadata": element_metadata})
        created_element = True

    elif tag_name == 'hr':
        if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(PageBreakElement(metadata=element_metadata))
        else: elements_list.append({"element_type": "page_break", "metadata": element_metadata})
        created_element = True
    
    processed_tags.add(tag)
    # If the tag itself wasn't a specific block element we handled, or it's a known container,
    # process its children.
    if not created_element or tag_name in CONTAINER_TAGS_HTML:
        for child in tag.children:
            if isinstance(child, Tag):
                _convert_html_tag_to_elements_recursive(child, elements_list, processed_tags, current_list_level)
            elif isinstance(child, NavigableString): # Handle loose text not in <p> etc.
                loose_text = child.strip()
                if loose_text and tag_name not in ['ul', 'ol']: # Avoid adding list item text twice
                    if _PYDANTIC_MODELS_AVAILABLE_HTML: elements_list.append(NarrativeTextElement(text=loose_text, metadata=element_metadata))
                    else: elements_list.append({"element_type": "narrative_text", "text": loose_text, "_is_loose_text": True, "metadata": element_metadata})

def _generate_linear_text_from_html_elements(elements: List[Any]) -> str:
    # This function is identical to the one in docx_parser.py, can be refactored to common_utils later.
    text_parts = []
    for el_data_any in elements:
        el_data: Dict[str, Any] = {}
        if _PYDANTIC_MODELS_AVAILABLE_HTML and hasattr(el_data_any, 'model_dump'):
            el_data = el_data_any.model_dump(exclude_none=True)
        elif isinstance(el_data_any, dict):
            el_data = el_data_any
        else: continue

        el_type = el_data.get("element_type")
        text_content = el_data.get("text", "")
        current_element_text = ""
        if el_type == "title": current_element_text = f"\n{'#' * el_data.get('level',1)} {text_content}\n"
        elif el_type == "narrative_text": current_element_text = text_content + "\n"
        elif el_type == "list_item":
            prefix = f"{el_data.get('item_number', '')}. " if el_data.get('ordered') and el_data.get('item_number') else "- "
            indent = "  " * el_data.get('level', 0)
            current_element_text = f"{indent}{prefix}{text_content}\n"
        elif el_type == "table":
            caption = el_data.get('caption','Unnamed Table')
            md_repr = el_data.get('markdown_representation')
            if md_repr: current_element_text = f"\n[Table: {caption}]\n{md_repr}\n"
        elif el_type == "code_block":
            lang = el_data.get('language', "") or ""
            code_content = el_data.get('code', "")
            current_element_text = f"\n```{lang}\n{code_content}\n```\n"
        elif el_type == "page_break": current_element_text = "\n---\n"
        if current_element_text: text_parts.append(current_element_text)
    full_text = "".join(text_parts)
    return re.sub(r'\n{3,}', '\n\n', full_text).strip()

def parse_html_to_structured_output(
    html_content_str: str, 
    original_metadata: Dict[str, Any]
) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"Attempting to parse HTML content (length: {len(html_content_str)} chars) using BeautifulSoup4")
    if not _BS4_AVAILABLE:
        logger.error("BeautifulSoup4 (bs4) is not available. HTML parsing cannot proceed.")
        return None

    elements: List[Any] = []
    try:
        # Try lxml first, then html.parser
        try:
            soup = BeautifulSoup(html_content_str, "lxml")
        except Exception: # Fallback if lxml is not installed or fails
            logger.warning("lxml parser not available or failed, falling back to html.parser for HTML.")
            soup = BeautifulSoup(html_content_str, "html.parser")

        # Attempt to find the main content area
        main_content_area = soup.find('article') or soup.find('main') or soup.body
        if not main_content_area:
            logger.warning("Could not find <article>, <main>, or <body> tag. Parsing entire document if possible.")
            main_content_area = soup # Fallback to entire soup object

        # Remove ignored tags before processing
        for ignore_tag_name in IGNORE_TAGS_HTML:
            for tag_to_remove in main_content_area.find_all(ignore_tag_name):
                tag_to_remove.decompose()
        
        processed_tags_set: Set[Tag] = set()
        _convert_html_tag_to_elements_recursive(main_content_area, elements, processed_tags_set)
        
        logger.info(f"Converted HTML to {len(elements)} custom elements.")
        
        linear_text = _generate_linear_text_from_html_elements(elements)
        logger.info(f"Generated linear text from HTML elements (length: {len(linear_text)}). Preview: {linear_text[:200]}")

        if _PYDANTIC_MODELS_AVAILABLE_HTML:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=elements, # type: ignore
                original_metadata=original_metadata
            )
        else:
            return {
                "parsed_text": linear_text,
                "elements": elements,
                "original_metadata": original_metadata
            }
    except Exception as e:
        logger.error(f"Error parsing HTML content with BeautifulSoup4: {e}", exc_info=True)
        return None
```

        |-- md_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/md_parser.py
import os
from markdown_it import MarkdownIt
from markdown_it.tree import SyntaxTreeNode
import logging
from typing import List, Dict, Any, Optional, Union
import re

# --- Pydantic 模型导入和占位符定义 ---
_PARSER_PYDANTIC_AVAILABLE = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, DocumentElementType, TitleElement, NarrativeTextElement,
        ListItemElement, TableElement, CodeBlockElement, PageBreakElement,
        DocumentElementMetadata
    )
    _PARSER_PYDANTIC_AVAILABLE = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class TitleElement(BaseModel): element_type:str="title"; text:str; level:int; metadata: Optional[DocumentElementMetadata] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class ListItemElement(BaseModel): element_type:str="list_item"; text:str; level:int=0; ordered:bool=False; item_number:Optional[Union[int, str]]=None; metadata: Optional[DocumentElementMetadata] = None
    class TableElement(BaseModel): element_type:str="table"; markdown_representation:Optional[str]=None; html_representation:Optional[str]=None; caption:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class CodeBlockElement(BaseModel): element_type:str="code_block"; code:str; language:Optional[str]=None; metadata: Optional[DocumentElementMetadata] = None
    class PageBreakElement(BaseModel): element_type:str="page_break"; metadata: Optional[DocumentElementMetadata] = None
    DocumentElementType = Any

logger = logging.getLogger(__name__)

# --- 辅助函数 ---
def _get_node_text_content(node: SyntaxTreeNode, exclude_lists_and_tables: bool = False) -> str:
    if node.type == "text":
        return node.content
    if node.type == "softbreak":
        return " "
    if node.type == "hardbreak":
        return "\n"
    if node.type == "code_inline":
        return f"`{node.content}`"
    
    if exclude_lists_and_tables and node.type in ["bullet_list", "ordered_list", "table"]:
        return ""

    content = ""
    if node.children:
        for child in node.children:
            content += _get_node_text_content(child, exclude_lists_and_tables)
    return content

def _convert_table_node_to_markdown(table_node: SyntaxTreeNode) -> str:
    md_rows = []
    
    thead_node = next((child for child in table_node.children if child.type == 'thead'), None)
    tbody_node = next((child for child in table_node.children if child.type == 'tbody'), None)

    header_texts = []
    if thead_node:
        tr_node_header = next((child for child in thead_node.children if child.type == 'tr'), None)
        if tr_node_header:
            header_texts = [_get_node_text_content(cell).strip() for cell in tr_node_header.children if cell.type == 'th']
    elif tbody_node: 
        first_row_in_tbody = next((child for child in tbody_node.children if child.type == 'tr'), None)
        if first_row_in_tbody and all(cell.type == 'th' for cell in first_row_in_tbody.children):
             header_texts = [_get_node_text_content(cell).strip() for cell in first_row_in_tbody.children]

    if header_texts:
        md_rows.append("| " + " | ".join(header_texts) + " |")
        md_rows.append("| " + " | ".join(["---"] * len(header_texts)) + " |")

    rows_container = tbody_node if tbody_node else table_node 
    
    first_row_in_container_is_header = False
    if not header_texts and rows_container: # 只有在没有thead且容器存在时，才检查第一行是否是表头
        first_tr = next((child for child in rows_container.children if child.type == 'tr'), None)
        if first_tr and all(cell.type == 'th' for cell in first_tr.children):
            # 如果第一行全是th，作为表头处理
            header_texts_from_body = [_get_node_text_content(cell).strip() for cell in first_tr.children]
            if header_texts_from_body:
                md_rows.append("| " + " | ".join(header_texts_from_body) + " |")
                md_rows.append("| " + " | ".join(["---"] * len(header_texts_from_body)) + " |")
                first_row_in_container_is_header = True

    if rows_container: # 确保 rows_container 存在
        for row_idx, tr_node in enumerate(child for child in rows_container.children if child.type == 'tr'):
            # 如果第一行已经被作为表头处理了，则跳过它
            if first_row_in_container_is_header and row_idx == 0:
                continue
            
            # 如果已经通过 thead 处理了表头，那么 tbody/table 下的所有 tr 都应视为数据行
            # 如果没有通过 thead 处理表头，并且当前行也不是被推断为表头的 tbody 第一行，那么它也是数据行
            cell_texts = [_get_node_text_content(cell).strip() for cell in tr_node.children if cell.type == 'td']
            if cell_texts or len(tr_node.children) > 0 : 
                md_rows.append("| " + " | ".join(cell_texts) + " |")
            
    return "\n".join(md_rows)

# --- 主转换函数 ---
def _convert_md_tree_to_elements(root_node: SyntaxTreeNode) -> List[Any]: 
    elements: List[Any] = []
    
    def _process_node_recursive(node: SyntaxTreeNode, current_semantic_level: int = 0, list_ctx: Optional[Dict] = None):
        nonlocal elements
        current_metadata = None 

        node_type = node.type
        
        if node_type == "heading":
            level = int(node.tag[1:])
            text = _get_node_text_content(node).strip()
            if text or node.children: 
                if _PARSER_PYDANTIC_AVAILABLE: elements.append(TitleElement(text=text, level=level, metadata=current_metadata))
                else: elements.append({"element_type": "title", "text": text, "level": level, "metadata": current_metadata})
        
        elif node_type == "paragraph":
            text = _get_node_text_content(node).strip()
            if text:
                if _PARSER_PYDANTIC_AVAILABLE: elements.append(NarrativeTextElement(text=text, metadata=current_metadata))
                else: elements.append({"element_type": "narrative_text", "text": text, "metadata": current_metadata})

        elif node_type == "bullet_list" or node_type == "ordered_list":
            is_ordered_list = (node_type == "ordered_list")
            child_list_ctx = {
                "ordered": is_ordered_list,
                "start_num": int(node.attrs.get("start", 1)) if node.attrs and is_ordered_list else 1,
                "item_idx_in_list": 0 
            }
            for child_node in node.children:
                if child_node.type == "list_item":
                    _process_node_recursive(child_node, current_semantic_level + 1, child_list_ctx)
        
        elif node_type == "list_item":
            item_text = _get_node_text_content(node, exclude_lists_and_tables=True).strip()
            
            if item_text and list_ctx: 
                display_level = current_semantic_level - 1 
                item_number_str = None
                if list_ctx["ordered"]:
                    item_number_str = str(list_ctx["start_num"] + list_ctx["item_idx_in_list"])
                    list_ctx["item_idx_in_list"] += 1
                else: 
                    item_number_str = node.markup if node.markup else "-" 

                if _PARSER_PYDANTIC_AVAILABLE:
                    elements.append(ListItemElement(
                        text=item_text, level=display_level, 
                        ordered=list_ctx["ordered"], 
                        item_number=item_number_str, metadata=current_metadata
                    ))
                else:
                    elements.append({
                        "element_type": "list_item", "text": item_text, 
                        "level": display_level, "ordered": list_ctx["ordered"], 
                        "item_number": item_number_str, "metadata": current_metadata
                    })
            
            for child_node in node.children:
                if child_node.type in ["bullet_list", "ordered_list"]:
                    _process_node_recursive(child_node, current_semantic_level, None) # Pass current_semantic_level for nested list

        elif node_type == "table":
            md_table_representation = _convert_table_node_to_markdown(node)
            if md_table_representation:
                if _PARSER_PYDANTIC_AVAILABLE: elements.append(TableElement(markdown_representation=md_table_representation, metadata=current_metadata))
                else: elements.append({"element_type": "table", "markdown_representation": md_table_representation, "metadata": current_metadata})

        elif node_type == "fence" or node_type == "code_block":
            code_content = node.content.strip('\n') 
            lang = node.info.strip() if node.info else None
            if _PARSER_PYDANTIC_AVAILABLE: elements.append(CodeBlockElement(code=code_content, language=lang, metadata=current_metadata))
            else: elements.append({"element_type": "code_block", "code": code_content, "language": lang, "metadata": current_metadata})

        elif node_type == "hr":
            if _PARSER_PYDANTIC_AVAILABLE: elements.append(PageBreakElement(metadata=current_metadata))
            else: elements.append({"element_type": "page_break", "metadata": current_metadata})

        elif node_type == "blockquote":
            text = _get_node_text_content(node).strip()
            if text:
                if _PARSER_PYDANTIC_AVAILABLE: elements.append(NarrativeTextElement(text=text, metadata=current_metadata))
                else: elements.append({"element_type": "narrative_text", "text": text, "_is_blockquote": True, "metadata": current_metadata})
        
        elif node.children and node_type not in ["list_item", "heading", "paragraph", "table", "fence", "code_block", "blockquote", "hr", "bullet_list", "ordered_list"]: # Avoid re-processing children of already handled types
             for child in node.children:
                _process_node_recursive(child, current_semantic_level, list_ctx) # Pass context along

    _process_node_recursive(root_node) 
    return elements

def _generate_parsed_text_from_elements_internal(elements: List[Any]) -> str:
    text_parts = []
    for el_data_any in elements:
        el_data = {}
        if _PARSER_PYDANTIC_AVAILABLE and hasattr(el_data_any, 'model_dump'): el_data = el_data_any.model_dump()
        elif isinstance(el_data_any, dict): el_data = el_data_any
        else: continue
        el_type = el_data.get("element_type")
        if el_type == "title": text_parts.append(f"\n{'#' * el_data.get('level',1)} {el_data.get('text','')}\n")
        elif el_type == "narrative_text": text_parts.append(el_data.get('text','') + "\n")
        elif el_type == "list_item":
            item_num_display = str(el_data.get('item_number','-')) 
            prefix = f"{item_num_display}. " if el_data.get('ordered') else f"{item_num_display} "
            indent = "  " * el_data.get('level',0)
            text_parts.append(f"{indent}{prefix}{el_data.get('text','')}\n")
        elif el_type == "table":
            caption_text = str(el_data.get('caption')) if el_data.get('caption') is not None else 'Unnamed Table'
            if el_data.get('markdown_representation'): 
                text_parts.append(f"\n[Table: {caption_text}]\n{el_data['markdown_representation']}\n")
            elif el_data.get('text_representation'): 
                text_parts.append(f"\n[Table: {caption_text}]\n{el_data['text_representation']}\n")
        elif el_type == "code_block":
            lang = el_data.get('language', "") or ""
            text_parts.append(f"\n```{lang}\n{el_data.get('code','')}\n```\n")
        elif el_type == "page_break": text_parts.append("\n---\n")
        if el_type not in ['list_item'] and text_parts and (not text_parts[-1].endswith("\n\n") and not text_parts[-1].endswith("\n---\n\n") ) : 
             text_parts.append("\n") 
             
    raw_text = "".join(text_parts)
    cleaned_text = raw_text.strip()
    cleaned_text = cleaned_text.replace('\r\n', '\n') 
    cleaned_text = re.sub(r'\n{3,}', '\n\n', cleaned_text) 
    return cleaned_text

def parse_markdown_to_structured_output(md_content_str: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"Parsing Markdown content (length: {len(md_content_str)} chars) using markdown-it-py with SyntaxTreeNode...")
    try:
        md_parser = MarkdownIt("commonmark", {'linkify': True}).enable("table")
        tokens = md_parser.parse(md_content_str)
        
        root_syntax_node = SyntaxTreeNode(tokens)
        structured_elements = _convert_md_tree_to_elements(root_syntax_node) 

        linear_text = _generate_parsed_text_from_elements_internal(structured_elements)

        if _PARSER_PYDANTIC_AVAILABLE:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=structured_elements, 
                original_metadata=original_metadata
            )
        else:
            return {
                "parsed_text": linear_text,
                "elements": structured_elements,
                "original_metadata": original_metadata
            }
    except Exception as e:
        logger.error(f"Error in parse_markdown_to_structured_output: {e}", exc_info=True)
        return None

# --- Placeholder for other parsers (保持不变) ---
def parse_docx_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"DOCX parser placeholder for: {file_path}") 
    text = f"[DOCX content of {os.path.basename(file_path)}]"
    if _PARSER_PYDANTIC_AVAILABLE: return ParsedDocumentOutput(parsed_text=text, elements=[NarrativeTextElement(text=text)], original_metadata=original_metadata) 
    return {"parsed_text": text, "elements": [{"element_type":"narrative_text", "text":text}], "original_metadata": original_metadata}

def parse_pdf_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"PDF parser placeholder for: {file_path}") 
    text = f"[PDF content of {os.path.basename(file_path)}]"
    if _PARSER_PYDANTIC_AVAILABLE: return ParsedDocumentOutput(parsed_text=text, elements=[NarrativeTextElement(text=text)], original_metadata=original_metadata) 
    return {"parsed_text": text, "elements": [{"element_type":"narrative_text", "text":text}], "original_metadata": original_metadata}

def parse_xlsx_to_structured_output(file_path: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"XLSX parser placeholder for: {file_path}") 
    text = f"[XLSX content of {os.path.basename(file_path)}]"
    if _PARSER_PYDANTIC_AVAILABLE: return ParsedDocumentOutput(parsed_text=text, elements=[NarrativeTextElement(text=text)], original_metadata=original_metadata) 
    return {"parsed_text": text, "elements": [{"element_type":"narrative_text", "text":text}], "original_metadata": original_metadata}
        
def parse_html_to_structured_output(html_content_str: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"HTML parser placeholder for content length: {len(html_content_str)}") 
    text = f"[HTML content snippet: {html_content_str[:100]}]"
    if _PARSER_PYDANTIC_AVAILABLE: return ParsedDocumentOutput(parsed_text=text, elements=[NarrativeTextElement(text=text)], original_metadata=original_metadata) 
    return {"parsed_text": text, "elements": [{"element_type":"narrative_text", "text":text}], "original_metadata": original_metadata}

def parse_txt_to_structured_output(txt_content_str: str, original_metadata: Dict[str, Any]) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"TXT parser for content length: {len(txt_content_str)}") 
    if _PARSER_PYDANTIC_AVAILABLE:
        return ParsedDocumentOutput(
            parsed_text=txt_content_str, 
            elements=[NarrativeTextElement(text=txt_content_str)], 
            original_metadata=original_metadata
        ) 
    return {
        "parsed_text": txt_content_str, 
        "elements": [{"element_type":"narrative_text", "text":txt_content_str}], 
        "original_metadata": original_metadata
    }
```

        |-- pdf_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/pdf_parser.py
import os
import logging
from typing import List, Dict, Any, Optional, Union
import re

try:
    import fitz  # PyMuPDF
    _PYMUPDF_AVAILABLE = True
    logging.info("Successfully imported PyMuPDF (fitz) for PDF parsing.")
except ImportError:
    logging.error("PyMuPDF (fitz) not found. PDF parsing will not be available.")
    _PYMUPDF_AVAILABLE = False
    # 占位符，以防 fitz 未安装时代码尝试引用它
    class fitz: 
        class Document: pass
        class Page: pass
        class Rect: pass 

_PYDANTIC_MODELS_AVAILABLE_PDF = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, DocumentElementType, NarrativeTextElement,
        DocumentElementMetadata, PageBreakElement
    )
    _PYDANTIC_MODELS_AVAILABLE_PDF = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    class PageBreakElement(BaseModel): element_type:str="page_break"; metadata: Optional[DocumentElementMetadata] = None
    DocumentElementType = Any

logger = logging.getLogger(__name__)

def _create_pdf_element_metadata(page_number: Optional[int] = None) -> Optional[Union[DocumentElementMetadata, Dict[str, Any]]]:
    meta_data_dict: Dict[str, Any] = {}
    if page_number is not None:
        meta_data_dict['page_number'] = page_number
    
    if not meta_data_dict:
        return None

    if _PYDANTIC_MODELS_AVAILABLE_PDF:
        return DocumentElementMetadata(**meta_data_dict)
    else:
        return meta_data_dict

def parse_pdf_to_structured_output(
    file_path: str, 
    original_metadata: Dict[str, Any]
) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"Attempting to parse PDF file: {file_path} using PyMuPDF (fitz)")
    if not _PYMUPDF_AVAILABLE:
        logger.error("PyMuPDF (fitz) is not available. PDF parsing cannot proceed.")
        return None

    elements: List[Any] = []
    full_text_parts: List[str] = []

    try:
        doc = fitz.open(file_path)
        logger.info(f"PyMuPDF opened PDF. Pages: {doc.page_count}")

        for page_num in range(doc.page_count):
            page = doc.load_page(page_num)
            
            # 使用 "dict" 模式提取文本块，并按阅读顺序排序
            page_content_blocks = page.get_text("dict", sort=True).get("blocks", [])
            
            page_text_collected = []
            
            if page_content_blocks:
                for block in page_content_blocks:
                    if block['type'] == 0: # 0 表示文本块
                        block_text_lines = []
                        for line in block.get("lines", []):
                            line_content = "".join([span.get("text", "") for span in line.get("spans", [])])
                            block_text_lines.append(line_content)
                        block_text_content = "\n".join(block_text_lines).strip()
                        if block_text_content:
                            page_text_collected.append(block_text_content)
            
            if page_text_collected:
                # 将整页的文本作为一个 NarrativeTextElement
                page_full_text = "\n\n".join(page_text_collected) # 用双换行符分隔来自不同块的文本
                element_metadata = _create_pdf_element_metadata(page_number=page_num + 1)
                if _PYDANTIC_MODELS_AVAILABLE_PDF:
                    elements.append(NarrativeTextElement(text=page_full_text, metadata=element_metadata)) # type: ignore
                else:
                    elements.append({"element_type": "narrative_text", "text": page_full_text, "metadata": element_metadata})
                full_text_parts.append(page_full_text)
            
            # 在每页（除了最后一页）之后添加一个 PageBreakElement
            if page_num < doc.page_count - 1:
                if _PYDANTIC_MODELS_AVAILABLE_PDF:
                    elements.append(PageBreakElement(metadata=_create_pdf_element_metadata(page_number=page_num + 1))) # type: ignore
                else:
                    elements.append({"element_type": "page_break", "metadata": _create_pdf_element_metadata(page_number=page_num + 1)})


        doc.close()
        
        linear_text = "\n\n--- Page Break ---\n\n".join(full_text_parts) # 用特殊标记分隔页面文本
        linear_text = re.sub(r'\n{3,}', '\n\n', linear_text).strip()

        if _PYDANTIC_MODELS_AVAILABLE_PDF:
            return ParsedDocumentOutput(
                parsed_text=linear_text,
                elements=elements, # type: ignore
                original_metadata=original_metadata
            )
        else:
            return {
                "parsed_text": linear_text,
                "elements": elements,
                "original_metadata": original_metadata
            }

    except FileNotFoundError:
        logger.error(f"PDF file not found: {file_path}")
        return None
    except Exception as e:
        logger.error(f"Error parsing PDF file {file_path} with PyMuPDF: {e}", exc_info=True)
        return None
```

        |-- txt_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/txt_parser.py
import os
import logging
from typing import Dict, Any, Optional, Union

_PYDANTIC_MODELS_AVAILABLE_TXT = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, NarrativeTextElement,
        DocumentElementMetadata
    )
    _PYDANTIC_MODELS_AVAILABLE_TXT = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None # Not really applicable for txt
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class NarrativeTextElement(BaseModel): element_type:str="narrative_text"; text:str; metadata: Optional[DocumentElementMetadata] = None
    # DocumentElementType is not strictly needed here as we only create NarrativeTextElement

logger = logging.getLogger(__name__)

def parse_txt_to_structured_output(
    txt_content_str: str, # For .txt, we expect the content string directly
    original_metadata: Dict[str, Any]
) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    logger.info(f"Attempting to parse TXT content (length: {len(txt_content_str)} chars)")

    # For .txt files, the entire content is treated as a single narrative text block.
    # No complex structure is assumed or extracted.
    
    elements = []
    element_metadata = None # No specific sub-element metadata for a single block txt file

    if _PYDANTIC_MODELS_AVAILABLE_TXT:
        elements.append(NarrativeTextElement(text=txt_content_str, metadata=element_metadata)) # type: ignore
        doc_output = ParsedDocumentOutput(
            parsed_text=txt_content_str,
            elements=elements, # type: ignore
            original_metadata=original_metadata
        )
    else:
        elements.append({"element_type": "narrative_text", "text": txt_content_str, "metadata": element_metadata})
        doc_output = {
            "parsed_text": txt_content_str,
            "elements": elements,
            "original_metadata": original_metadata
        }
    
    logger.info(f"Successfully processed TXT content into a single element.")
    return doc_output
```

        |-- xlsx_parser.py

``` py
# /home/zhz/zhz_agent/zhz_rag_pipeline_dagster/zhz_rag_pipeline/parsers/xlsx_parser.py
import os
import logging
from typing import List, Dict, Any, Optional, Union
import pandas as pd

# 确保安装了 'pandas', 'openpyxl', 'tabulate'
# pip install pandas openpyxl tabulate

# --- Pydantic 模型导入和占位符定义 (保持不变) ---
_PYDANTIC_MODELS_AVAILABLE_XLSX = False
try:
    from ..pydantic_models_dagster import (
        ParsedDocumentOutput, TableElement, DocumentElementMetadata
    )
    _PYDANTIC_MODELS_AVAILABLE_XLSX = True
except ImportError:
    class BaseModel: pass
    class DocumentElementMetadata(BaseModel): page_number: Optional[int] = None
    class ParsedDocumentOutput(BaseModel): parsed_text: str; elements: list; original_metadata: dict; summary: Optional[str] = None
    class TableElement(BaseModel): element_type: str = "table"; markdown_representation: Optional[str] = None; html_representation: Optional[str] = None; caption: Optional[str] = None; metadata: Optional[DocumentElementMetadata] = None

logger = logging.getLogger(__name__)

# --- 辅助函数 (保持不变) ---
def _create_xlsx_element_metadata(sheet_index: int, table_index_in_sheet: int) -> Optional[Union[DocumentElementMetadata, Dict[str, Any]]]:
    meta_data_dict: Dict[str, Any] = {
        'page_number': sheet_index, # 使用 page_number 表示工作表索引
        'custom_properties': {'table_index_in_sheet': table_index_in_sheet}
    }
    if _PYDANTIC_MODELS_AVAILABLE_XLSX:
        return DocumentElementMetadata(**meta_data_dict)
    else:
        return meta_data_dict

# --- 主解析函数 (全新版本) ---
def parse_xlsx_to_structured_output(
    file_path: str,
    original_metadata: Dict[str, Any]
) -> Optional[Union[ParsedDocumentOutput, Dict[str, Any]]]:
    """
    V2: 解析XLSX文件，智能识别并提取每个工作表内的多个独立表格。
    """
    logger.info(f"Attempting to parse XLSX file with multi-table support: {file_path}")
    
    try:
        xls = pd.ExcelFile(file_path)
    except Exception as e:
        logger.error(f"Failed to open Excel file {file_path}: {e}", exc_info=True)
        return None

    all_elements: List[Any] = []
    
    for sheet_idx, sheet_name in enumerate(xls.sheet_names):
        try:
            # 读取整个工作表，不指定表头，以便我们手动查找
            df_full = pd.read_excel(xls, sheet_name=sheet_name, header=None)
            
            if df_full.empty:
                logger.info(f"Sheet '{sheet_name}' is empty. Skipping.")
                continue

            # 通过查找空行来识别表格块
            is_row_empty = df_full.isnull().all(axis=1)
            # 获取空行的索引
            empty_row_indices = is_row_empty[is_row_empty].index.tolist()
            
            table_blocks: List[pd.DataFrame] = []
            last_split_index = -1
            
            for empty_idx in empty_row_indices:
                block_df = df_full.iloc[last_split_index + 1 : empty_idx].dropna(how='all')
                if not block_df.empty:
                    table_blocks.append(block_df)
                last_split_index = empty_idx
            
            # 添加最后一个块（从最后一个空行到末尾）
            final_block_df = df_full.iloc[last_split_index + 1 :].dropna(how='all')
            if not final_block_df.empty:
                table_blocks.append(final_block_df)

            logger.info(f"Sheet '{sheet_name}' was split into {len(table_blocks)} potential table blocks.")

            for table_idx, block_df in enumerate(table_blocks):
                # 将第一行作为表头
                header = block_df.iloc[0]
                table_data = block_df[1:]
                table_data.columns = header
                
                md_representation = table_data.to_markdown(index=False)
                table_caption = f"内容来自文件 '{os.path.basename(file_path)}' 的工作表 '{sheet_name}' (表格 {table_idx + 1})"
                
                element_metadata = _create_xlsx_element_metadata(
                    sheet_index=sheet_idx, 
                    table_index_in_sheet=table_idx
                )

                if _PYDANTIC_MODELS_AVAILABLE_XLSX:
                    table_el = TableElement(
                        markdown_representation=md_representation,
                        caption=table_caption,
                        metadata=element_metadata
                    )
                    all_elements.append(table_el)
                else:
                    all_elements.append({
                        "element_type": "table",
                        "markdown_representation": md_representation,
                        "caption": table_caption,
                        "metadata": element_metadata
                    })
                logger.info(f"  Successfully created TableElement for table {table_idx+1} in sheet '{sheet_name}'.")
                logger.debug(f"    - Table {table_idx+1} content preview: {md_representation[:200].replace(chr(10), ' ')}...")


        except Exception as e_sheet:
            logger.error(f"Failed to process sheet '{sheet_name}' in {file_path}: {e_sheet}", exc_info=True)
            continue
    
    if _PYDANTIC_MODELS_AVAILABLE_XLSX:
        return ParsedDocumentOutput(
            parsed_text="",
            elements=all_elements,
            original_metadata=original_metadata,
            summary=f"从文件 '{os.path.basename(file_path)}' 中解析了 {len(all_elements)} 个独立的表格。"
        )
    else:
        return {
            "parsed_text": "",
            "elements": all_elements,
            "original_metadata": original_metadata,
            "summary": f"从文件 '{os.path.basename(file_path)}' 中解析了 {len(all_elements)} 个独立的表格。"
        }
```

    |-- PKG-INFO
    |-- SOURCES.txt
    |-- dependency_links.txt
    |-- requires.txt
    |-- top_level.txt

==================================================

--- Structure and Code for: zhz_rag/ ---
|-- api/
|-- config/
|-- core_rag/
|-- crewai_integration/
|-- evaluation/
|-- finetuning/
|-- llm/
|-- stored_data/
|-- task_management/
|-- utils/
|-- zhz_rag_core.egg-info/
|-- __init__.py

``` py

```

|-- setup.py

``` py
# /home/zhz/zhz_agent/zhz_rag/setup.py
from setuptools import find_packages, setup

setup(
    name="zhz_rag_core",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        # Pydantic 版本由主 requirements.txt 控制
        # LiteLLM 版本由主 requirements.txt 控制
        # ChromaDB 版本由主 requirements.txt 控制

        "protobuf>=4.25.0,<5.30.0", # 放宽 protobuf 上限，因为 pydantic 2.11.5 可能需要较新的
        "packaging>=23.2,<25.0",
        "rich>=13.7.0,<14.0.0",
        
        "fastapi>=0.110.0,<0.116.0", # 保持较新
        "starlette>=0.35.0,<0.47.0", # 保持较新

        "langchain-core>=0.1.50,<0.4.0", # 较新 langchain 可能更好兼容
        "langchain-text-splitters>=0.0.1,<0.3.0",

        "httpx>=0.27.0", # 使用较新 httpx
        "python-dotenv>=1.0.0",
        "neo4j>=5.0.0", # neo4j 驱动
        "sentence-transformers>=2.2.0", # sentence-transformers
        "transformers>=4.38.0,<4.39.0", # 固定您之前的版本或小幅更新
        "torch>=2.0.0",
        "numpy<2.0", # 保持 Numpy < 2.0
        "bm25s",
        "jieba",
        "uvicorn[standard]", # 添加 standard extras
        "pandas>=2.0.0",
        "sqlalchemy>=2.0.0",
        "databases[aiosqlite]>=0.9.0", # for async sqlite
        "apscheduler>=3.10.0",
        "pytz",
    ],
)
```

    |-- __init__.py

``` py

```

    |-- run_crew.py

``` py
# /home/zhz/zhz_agent/run_agent.py

import os
import json
import datetime

from crewai import Agent, Task, Crew, Process

# --- 导入我们自己的项目模块 (使用绝对导入) ---
from zhz_rag.crewai_integration.tools import HybridRAGTool, BaseMCPTool
from zhz_rag.config.pydantic_models import QueryRequest # 用于 RAG 工具的输入
from zhz_rag.utils.common_utils import call_mcpo_tool
from zhz_rag.llm.custom_crewai_llms import CustomGeminiLLM

# --- 环境配置 ---
from dotenv import load_dotenv
load_dotenv()

# --- CrewAI 基类和事件系统 ---
from crewai.tools import BaseTool
from pydantic import BaseModel, Field
from typing import Any, Dict, List, Optional, Type
from crewai.llms.base_llm import BaseLLM as CrewAIBaseLLM
try:
    from crewai.utilities.events.base_event_listener import BaseEventListener as CrewAIBaseCallbackHandler
    from crewai.utilities.events import LLMCallStartedEvent, LLMCallCompletedEvent
    print("Successfully imported BaseEventListener and Event Types")
except ImportError:
    print("Failed to import BaseEventListener or Event Types, using dummy classes.")
    class CrewAIBaseCallbackHandler: pass
    class LLMCallStartedEvent: pass
    class LLMCallCompletedEvent: pass

# --- LiteLLM ---
import litellm

# --- 定义简单工具以供测试 ---
class SimpleToolInput(BaseModel):
    message: str = Field(description="A simple message string for the tool.")

class MySimpleTestTool(BaseTool):
    name: str = "MySimpleTestTool"
    description: str = "A very simple test tool that takes a message and returns it."
    args_schema: Type[BaseModel] = SimpleToolInput

    def _run(self, message: str) -> str:
        print(f"MySimpleTestTool received: {message}")
        return f"MySimpleTestTool processed: {message}"

# --- 配置 Agent 使用的 LLM 实例 ---
GEMINI_MODEL_NAME = "gemini/gemini-1.5-flash-latest"
GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY")

if not GEMINI_API_KEY:
    print("CRITICAL ERROR: GOOGLE_API_KEY or GEMINI_API_KEY not set.")
    exit(1)

# --- 定义详细的事件监听器 ---
class MyDetailedLogger(CrewAIBaseCallbackHandler):
    def __init__(self):
        super().__init__()
        print(f"[{datetime.datetime.now()}] MyDetailedLogger: 已初始化。")

    def setup_listeners(self, crewai_event_bus):
        print(f"[{datetime.datetime.now()}] MyDetailedLogger: 正在设置监听器...")

        @crewai_event_bus.on(LLMCallStartedEvent)
        def handle_llm_start(source, event: LLMCallStartedEvent):
            self.on_llm_start_logic(source, event)

        @crewai_event_bus.on(LLMCallCompletedEvent)
        def handle_llm_completed(source, event: LLMCallCompletedEvent):
            self.on_llm_end_logic(source, event)

        print(f"[{datetime.datetime.now()}] MyDetailedLogger: 监听器设置完成。")

    def on_llm_start_logic(self, source, event: LLMCallStartedEvent):
        print(f"\n>>>> LLM 调用开始 (Event Logic) <<<<")
        llm_inputs = getattr(event, 'llm_inputs', {})
        messages = llm_inputs.get('messages')
        tools = llm_inputs.get('tools')
        print(f"来源 (Source): {source}")
        if messages:
            print("消息 (来自 event.llm_inputs):")
            if isinstance(messages, list) and len(messages) > 0:
                first_message = messages[0]
                if isinstance(first_message, dict) and 'content' in first_message:
                    content_snippet = str(first_message.get('content', ''))[:300]
                    print(f"   Role: {first_message.get('role')}, Content Snippet: {content_snippet}...")
                else:
                     print(f"  First message (raw): {first_message}")
            else:
                 print(f"  Messages (raw): {messages}")
        else:
            print("消息 (来自 event.llm_inputs): 无")
        if tools:
            print("工具 (来自 event.llm_inputs):")
            try:
                print(f"  {json.dumps(tools, indent=2, ensure_ascii=False)}")
            except Exception as e:
                print(f"  无法序列化工具为 JSON: {e}. 工具: {tools}")
        else:
            print("工具 (来自 event.llm_inputs): 无")
        print("----------------------------------")

    def on_llm_end_logic(self, source, event: LLMCallCompletedEvent):
        print(f"\n>>>> LLM 调用结束 (Event Logic) <<<<")
        response = getattr(event, 'llm_output', None)
        print(f"来源 (Source): {source}")
        if response:
            if hasattr(response, 'choices') and response.choices:
                choice = response.choices[0]
                if hasattr(choice, 'message') and choice.message:
                    print(f"  消息内容: {choice.message.content}")
                    if hasattr(choice.message, 'tool_calls') and choice.message.tool_calls:
                        print(f"  工具调用: {choice.message.tool_calls}")
                    else:
                        print(f"  工具调用: 无")
            elif hasattr(response, 'content'):
                print(f"  响应内容: {response.content}")
            else:
                print(f"  LLM 响应 (来自 event.llm_output): {str(response)[:500]}...")
        else:
            print("  在 event.llm_output 中未找到响应对象。")
        print("----------------------------------")

# --- 实例化 CustomGeminiLLM ---
custom_llm_tool_config = {"function_calling_config": {"mode": "AUTO"}}
zhz_agent_tool = HybridRAGTool()
researcher_tools = [zhz_agent_tool]

llm_for_agent = CustomGeminiLLM(
    model=GEMINI_MODEL_NAME,
    api_key=GEMINI_API_KEY,
    temperature=0.1,
    max_tokens=2048,
    tool_config=custom_llm_tool_config,
    agent_tools=researcher_tools # 传递工具列表以供缓存
)
print(f"Custom Agent LLM configured: {GEMINI_MODEL_NAME} with custom tool_config")

# --- 设置 BaseMCPTool 的调用器 ---
BaseMCPTool.set_mcpo_caller(call_mcpo_tool)

# --- 定义 Agents ---
researcher_agent = Agent(
    role='信息检索专家',
    goal='准确地回答用户查询，并且只使用提供的工具。',
    backstory=(
        "你是一位高级AI助手，专注于信息检索。"
        "你的专长在于高效地利用工具来查找最相关和最精确的答案来回应用户的查询。"
    ),
    llm=llm_for_agent,
    tools=researcher_tools,
    verbose=True,
    allow_delegation=False,
)

writer_agent = Agent(
    role='报告撰写专家',
    goal='根据提供的信息，撰写清晰、结构良好且富有洞察力的报告。',
    backstory=(
        "您是一位资深的报告撰写专家，拥有出色的分析和写作能力。"
        "您擅长将复杂的信息提炼成易于理解的报告，并能根据不同的输出状态（答案、澄清、错误）"
        "灵活调整报告内容和格式。"
    ),
    llm=llm_for_agent,
    verbose=True,
    allow_delegation=False,
)

# --- 定义 Tasks (包含上下文传递修复) ---
research_task_description = """你收到了来自用户的以下查询：

'{query}'

你应该使用提供的 `HybridRAGQueryTool` 工具来处理这个查询。
如果这个工具需要 `top_k_vector`, `top_k_kg`, 或 `top_k_bm25` 这些参数，请使用以下建议值：
top_k_vector: 5, top_k_kg: 3, top_k_bm25: 5。
在使用完必要的工具后，你的最终输出应该是（使用中文）：'我的最终答案是：' 
后跟你使用的工具返回的精确、完整的JSON字符串输出内容。"""

research_task_expected_output = "短语 '我的最终答案是：' 后跟你使用的工具返回的精确、完整的JSON字符串输出内容。"

research_task = Task(
    description=research_task_description,
    expected_output=research_task_expected_output,
    agent=researcher_agent,
)

report_writing_task = Task(
    description="""根据【前一个任务】（信息检索专家）提供的RAG工具输出（它是一个JSON字符串），生成一份报告或响应。
请仔细分析这个JSON字符串输出，它应该包含一个 'status' 字段。
1. 如果 'status' 是 'success'，则提取 'final_answer' 字段的内容，并基于此答案撰写一份简洁的报告。
2. 如果 'status' 是 'clarification_needed'，则提取 'clarification_question' 字段的内容，并向用户明确指出需要澄清的问题，例如：'系统需要澄清：[澄清问题]'。
3. 如果 'status' 是 'error'，则提取 'error_message' (或 'error') 字段的内容，并向用户报告错误，例如：'RAG服务发生错误：[错误信息]'。
你的最终输出必须是清晰、专业且符合上述情况的报告或响应。""",
    expected_output="一份清晰的报告，或者一个明确的澄清请求，或者一个错误报告。",
    agent=writer_agent,
    context=[research_task],
)

# --- 实例化监听器 ---
my_event_logger = MyDetailedLogger()

# --- 定义 Crew (添加 event_listeners) ---
office_brain_crew = Crew(
    agents=[researcher_agent, writer_agent],
    tasks=[research_task, report_writing_task],
    process=Process.sequential,
    verbose=True,
    event_listeners=[my_event_logger] # <<< --- 激活事件监听器 ---
)

# --- 启动 Crew ---
if __name__ == "__main__":
    print("--- 启动智能助手终端大脑 Crew (使用 CustomGeminiLLM 和事件监听器) ---")
    user_query_input = "公司2024年第一季度在华东和华北的总销售额一共是多少？"
    # --- 修复：kickoff inputs 只包含 query ---
    inputs = {'query': user_query_input}
    result = office_brain_crew.kickoff(inputs=inputs)
    print("\n\n=== 最终报告 ===\n")
    if hasattr(result, 'raw'):
        print(result.raw)
    else:
        print(result)
    print("\n--- Crew 任务完成 ---")
```

    |-- tools.py

``` py
# zhz_agent/custom_crewai_tools.py

import os
import json
import asyncio
import traceback
from typing import Type, List, Dict, Any, Optional, ClassVar
from pydantic import BaseModel, Field
from crewai.tools import BaseTool
import httpx

# 从 zhz_agent.pydantic_models 导入 QueryRequest
from zhz_rag.config.pydantic_models import QueryRequest # 用于 RAG 工具的输入

# MCPO 代理的基地址
MCPO_BASE_URL = os.getenv("MCPO_BASE_URL", "http://localhost:8006")

class BaseMCPTool(BaseTool):
    mcpo_base_url: str = MCPO_BASE_URL
    _call_mcpo_func: ClassVar[callable] = None

    @classmethod
    def set_mcpo_caller(cls, caller: callable):
        cls._call_mcpo_func = caller

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    async def _call_mcpo_endpoint(self, service_and_tool_path: str, payload: dict) -> dict | str:
        api_url = f"{self.mcpo_base_url}/{service_and_tool_path}"
        cleaned_payload = {k: v for k, v in payload.items() if v is not None}
        print(f"BaseMCPTool: Calling mcpo endpoint: POST {api_url} with payload: {json.dumps(cleaned_payload, ensure_ascii=False)}")
        
        # --- [修改] 移除 proxies=None 参数 ---
        async with httpx.AsyncClient(trust_env=False) as client:
            response = None
            try:
                headers = {"Content-Type": "application/json"}
                response = await client.post(api_url, json=cleaned_payload, headers=headers, timeout=300.0)
                print(f"BaseMCPTool: mcpo status code for {service_and_tool_path}: {response.status_code}")
                print(f"BaseMCPTool: mcpo response headers for {service_and_tool_path}: {response.headers}") # <--- 新增日志
                # 尝试分块读取响应或提前获取少量内容进行日志记录，以防响应过大卡住 .text 或 .json()
                try:
                    response_text_snippet = await response.aread(num_bytes=1024) # 读取前1KB
                    print(f"BaseMCPTool: mcpo response text snippet (first 1KB) for {service_and_tool_path}: {response_text_snippet.decode(errors='ignore')}")
                except Exception as e_read:
                    print(f"BaseMCPTool: Error reading response snippet: {e_read}")

                if response.status_code == 200:
                    try:
                        # print(f"BaseMCPTool: mcpo raw response text for {service_and_tool_path}: {response.text}") # 如果怀疑内容问题，可以取消注释，但小心大响应
                        return response.json()
                    except json.JSONDecodeError:
                        print(f"BaseMCPTool Warning: mcpo returned status 200 but response is not JSON for '{service_and_tool_path}'. Returning raw text.")
                        return response.text
                else:
                    error_text = f"mcpo call to '{service_and_tool_path}' failed with status {response.status_code}. Response: {response.text[:500]}..."
                    print(f"BaseMCPTool Error: {error_text}")
                    return {"error": error_text, "status_code": response.status_code}
            except httpx.RequestError as exc:
                error_msg = f"BaseMCPTool HTTP RequestError calling mcpo tool '{service_and_tool_path}': {type(exc).__name__} - {exc}"
                print(f"BaseMCPTool Error: {error_msg}"); traceback.print_exc()
                return {"error": error_msg, "exception_type": type(exc).__name__}
            except Exception as exc:
                error_msg = f"BaseMCPTool Unexpected error calling mcpo tool '{service_and_tool_path}': {type(exc).__name__} - {exc}"
                response_text_snippet = response.text[:500] if response and hasattr(response, 'text') else "Response object not available or no text."
                print(f"BaseMCPTool Error: {error_msg}. Response snippet: {response_text_snippet}"); traceback.print_exc()
                return {"error": error_msg, "exception_type": type(exc).__name__}

    def _handle_tool_result(self, result: dict | str, tool_name_for_log: str) -> str:
        print(f"BaseMCPTool DEBUG: {tool_name_for_log} result from mcpo: {str(result)[:500]}...")
        parsed_result = result
        if isinstance(result, str):
            try:
                parsed_result = json.loads(result)
            except json.JSONDecodeError:
                if "error" in result.lower() or "failed" in result.lower() or "traceback" in result.lower():
                    return f"调用 {tool_name_for_log} 失败，返回非JSON错误文本: {result}"
                print(f"BaseMCPTool Info: Result for {tool_name_for_log} is a non-JSON string, returning as is.")
                return result
        if isinstance(parsed_result, dict):
            if "error" in parsed_result and "status_code" in parsed_result:
                return f"调用 {tool_name_for_log} 时发生HTTP错误：{parsed_result.get('error')}"
            if parsed_result.get("status") == "error":
                error_msg = parsed_result.get("error_message", "未知错误")
                error_code = parsed_result.get("error_code", "NO_CODE")
                return f"工具 {tool_name_for_log} 执行失败 (错误码: {error_code})：{error_msg}"
            try:
                return json.dumps(parsed_result, ensure_ascii=False, indent=2)
            except Exception as e:
                print(f"BaseMCPTool Error formatting successful dict result for {tool_name_for_log}: {e}")
                return str(parsed_result)
        print(f"BaseMCPTool Warning: Unexpected result format from {tool_name_for_log} mcpo call: {type(result)}, content: {str(result)[:200]}")
        return f"从 {tool_name_for_log} 服务收到的结果格式不正确或无法处理: {str(result)[:500]}"

    def _run_default_sync_wrapper(self, **kwargs) -> str:
        tool_name = getattr(self, 'name', self.__class__.__name__)
        print(f"BaseMCPTool INFO: Synchronous _run called for {tool_name} with args: {kwargs}.")
        result_str = ""
        try:
            # --- 改进的 asyncio.run 处理 ---
            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                loop = None

            async def async_runner():
                return await self._arun(**kwargs)

            if loop and loop.is_running():
                import concurrent.futures
                with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
                    future = executor.submit(asyncio.run, async_runner())
                    result = future.result(timeout=120)
            else:
                result = asyncio.run(async_runner())
            result_str = str(result)
        except asyncio.TimeoutError:
            error_message = f"Tool {tool_name} execution timed out after 120 seconds."
            print(f"BaseMCPTool ERROR_TRACE: {error_message}"); result_str = error_message
        except RuntimeError as e:
            if "cannot run event loop while another loop is running" in str(e).lower() or "event loop is already running" in str(e).lower():
                error_message = (f"BaseMCPTool Error in {tool_name} _run: Nested asyncio event loop conflict. Original error: {e}")
            else:
                error_message = f"BaseMCPTool RuntimeError in {tool_name} _run: {type(e).__name__} - {e}"
            print(f"BaseMCPTool ERROR_TRACE: {error_message}"); traceback.print_exc();
            result_str = error_message
        except Exception as e:
            error_message = f"BaseMCPTool General Exception in {tool_name} _run: {type(e).__name__} - {e}"
            print(f"BaseMCPTool ERROR_TRACE: {error_message}"); traceback.print_exc(); result_str = error_message
        return result_str

class HybridRAGTool(BaseMCPTool):
    name: str = "HybridRAGQueryTool"
    description: str = (
        "【核心RAG工具】用于通过执行混合检索增强生成 (RAG) 搜索来回答用户问题。 "
        "该工具整合了向量检索、知识图谱检索和关键词检索，并进行智能融合和重排序。 "
        "当用户需要从知识库中获取信息、回答复杂问题或生成报告时，应调用此工具。"
    )
    args_schema: Type[BaseModel] = QueryRequest
    target_mcp_service_path: str = "zhz_agent_rag_service/query_rag_v2"

    async def _arun(self, query: str, top_k_vector: int, top_k_kg: int, top_k_bm25: int, **kwargs: Any) -> str: # --- 确认有 **kwargs ---
        tool_name_for_log = getattr(self, 'name', "HybridRAGTool")
        print(f"CrewAI Tool DEBUG: {tool_name_for_log}._arun called with query='{query}', top_k_vector={top_k_vector}, top_k_kg={top_k_kg}, top_k_bm25={top_k_bm25}, additional_kwargs={kwargs}")

        security_context = kwargs.get('security_context')
        if security_context:
            print(f"CrewAI Tool INFO: Received security_context (in HybridRAGTool): {str(security_context)[:200]}...")

        payload = {
            "query": query,
            "top_k_vector": top_k_vector,
            "top_k_kg": top_k_kg,
            "top_k_bm25": top_k_bm25
        }
        result = await self._call_mcpo_endpoint(self.target_mcp_service_path, payload)
        return self._handle_tool_result(result, self.name)

    def _run(self, query: str, top_k_vector: int, top_k_kg: int, top_k_bm25: int, **kwargs: Any) -> str: # --- 确认有 **kwargs ---
        return self._run_default_sync_wrapper(query=query, top_k_vector=top_k_vector, top_k_kg=top_k_kg, top_k_bm25=top_k_bm25, **kwargs)
```

    |-- constants.py

``` py
# zhz_agent/zhz_rag/config/constants.py

NEW_KG_SCHEMA_DESCRIPTION = """
# 知识图谱结构 (KuzuDB) 与 Cypher 查询生成规则

## 1. 节点定义:
- 节点标签: `:ExtractedEntity` (你必须且只能使用此节点标签)
- 节点属性:
    - `id_prop`: STRING (主键，实体的唯一标识)
    - `text`: STRING (实体的名称或文本内容)
    - `label`: STRING (实体类型。允许的值: "PERSON", "ORGANIZATION", "TASK")

## 2. 关系定义:
- 关系类型: `:WorksAt`
    - 结构: `(:ExtractedEntity {label:"PERSON"}) -[:WorksAt]-> (:ExtractedEntity {label:"ORGANIZATION"})`
    - 含义: 一个人 (PERSON) 在一个组织 (ORGANIZATION) 工作。
- 关系类型: `:AssignedTo`
    - 结构: `(:ExtractedEntity {label:"TASK"}) -[:AssignedTo]-> (:ExtractedEntity {label:"PERSON"})`
    - 含义: 一个任务 (TASK) 被分配给一个人 (PERSON)。

## 3. Cypher 查询生成 - 输出为 JSON 对象:

    你的【完整且唯一】的回答，必须是一个包含 "status" 和 "query" 字段的JSON对象。
    - 如果你能根据用户问题和Schema生成一个有效的Cypher查询：
        - "status" 字段应为 "success"。
        - "query" 字段应为该Cypher查询字符串。
    - 如果你无法生成有效的Cypher查询：
        - "status" 字段应为 "unable_to_generate"。
        - "query" 字段应为 "无法生成Cypher查询."。
    【不要在JSON之外或query字段内（当status为success时）包含任何解释或额外文本。】

## 4. JSON 输出格式示例:

### 示例 1 (能够生成查询):
用户问题: "任务'FixBug123'分配给了谁？"
你的【完整且唯一】的 JSON 回答:
```json
{
  "status": "success",
  "query": "MATCH (t:ExtractedEntity {text: 'FixBug123', label: 'TASK'})-[:AssignedTo]->(p:ExtractedEntity {label: 'PERSON'}) RETURN p.text AS Assignee"
}
示例 2 (无法根据Schema回答):
用户问题: "法国的首都是哪里？"
你的【完整且唯一】的 JSON 回答:
{
  "status": "unable_to_generate",
  "query": "无法生成Cypher查询."
}
"""
```

    |-- pydantic_models.py

``` py
# /home/zhz/zhz_agent/zhz_rag/config/pydantic_models.py
from pydantic import BaseModel, Field, root_validator
from typing import List, Dict, Any, Optional
from enum import Enum
from datetime import datetime
import uuid

# --- RAG Models ---
class QueryRequest(BaseModel):
    query: str
    # --- START: 新增 filters 字段 ---
    filters: Optional[Dict[str, Any]] = Field(default=None, description="Optional metadata filter to apply during retrieval.")
    # --- END: 新增 filters 字段 ---
    # --- 修改：为所有 top_k 参数提供默认值，使其变为可选 ---
    top_k_vector: int = Field(default=3, description="Number of results to retrieve from vector search.")
    top_k_bm25: int = Field(default=3, description="Number of results to retrieve from BM25 search.")
    top_k_kg: int = Field(default=2, description="Number of results to retrieve from Knowledge Graph search.")
    top_k_final: int = Field(default=3, description="Number of final results after fusion and reranking.")
    # --- 结束修改 ---

    class Config:
        json_schema_extra = {
            "example": {
                "query": "What are the main objectives of the project?",
                "filters": {"must": [{"key": "filename", "match": {"value": "report.docx"}}]}, # <-- 更新示例
                "top_k_vector": 3,
                "top_k_bm25": 3,
                "top_k_kg": 2,
                "top_k_final": 3
            }
        }
        # 移除了 root_validator 和 extra='forbid' 以简化并遵循新的实践
        # 如果您仍需要严格的字段检查，可以将 extra='forbid' 放回

class RetrievedDocument(BaseModel):
    source_type: str
    content: str
    score: Optional[float] = None
    metadata: Optional[Dict[str, Any]] = None

class HybridRAGResponse(BaseModel):
    original_query: str
    answer: str
    retrieved_sources: List[RetrievedDocument]
    debug_info: Optional[Dict[str, Any]] = None


# --- Task Management Models ---
class TaskStatus(str, Enum):
    PENDING = "pending"
    ACTIVE = "active"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    FAILED = "failed"
    REMINDING = "reminding"

class ReminderMethod(str, Enum):
    NOTIFICATION = "notification"

class TaskModel(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="任务的唯一ID (自动生成)")
    title: str = Field(description="任务标题")
    description: Optional[str] = Field(None, description="任务的详细描述")
    status: TaskStatus = Field(default=TaskStatus.PENDING, description="任务当前状态")
    created_at: datetime = Field(default_factory=datetime.utcnow, description="任务创建时间 (UTC)")
    updated_at: datetime = Field(default_factory=datetime.utcnow, description="任务最后更新时间 (UTC)")
    due_date: Optional[datetime] = Field(None, description="任务截止日期或计划执行时间 (UTC)")
    reminder_time: Optional[datetime] = Field(None, description="任务提醒时间 (UTC)")
    reminder_offset_minutes: Optional[int] = Field(None, description="提醒时间相对于due_date的提前分钟数 (例如10分钟前)")
    reminder_methods: List[ReminderMethod] = Field(default=[ReminderMethod.NOTIFICATION], description="提醒方式列表")
    priority: int = Field(default=0, description="任务优先级 (例如 0:普通, 1:重要, 2:紧急)")
    tags: List[str] = Field(default_factory=list, description="任务标签")
    action_type: Optional[str] = Field(None, description="任务到期时需要执行的动作类型 (例如 'navigate', 'send_message', 'run_report')")
    action_payload: Dict[str, Any] = Field(default_factory=dict, description="执行动作时需要的参数 (例如导航的目的地)")
    execution_result: Optional[str] = Field(None, description="任务执行后的结果或错误信息")
    last_executed_at: Optional[datetime] = Field(None, description="上次执行时间 (UTC)")

    class Config:
        use_enum_values = True
        # Pydantic v2 推荐使用 from_attributes 替代 orm_mode
        from_attributes = True


class CreateTaskRequest(BaseModel):
    title: str
    description: Optional[str] = None
    due_date: Optional[datetime] = None
    reminder_offset_minutes: Optional[int] = None
    reminder_methods: Optional[List[ReminderMethod]] = [ReminderMethod.NOTIFICATION]
    priority: Optional[int] = 0
    tags: Optional[List[str]] = None
    action_type: Optional[str] = None
    action_payload: Optional[Dict[str, Any]] = None
    
    class Config:
        extra = 'forbid'

class UpdateTaskRequest(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[TaskStatus] = None
    due_date: Optional[datetime] = None
    reminder_offset_minutes: Optional[int] = None
    reminder_methods: Optional[List[ReminderMethod]] = None
    priority: Optional[int] = None
    tags: Optional[List[str]] = None
    action_type: Optional[str] = None
    action_payload: Optional[Dict[str, Any]] = None

    class Config:
        extra = 'forbid'


class IdentifiedEntity(BaseModel):
    text: str = Field(description="识别出的实体文本。")
    label: Optional[str] = Field(None, description="推断的实体类型 (例如 PERSON, ORGANIZATION, TASK)。")

class ExtractedRelationItem(BaseModel): # 新建一个类名以避免与可能的其他同名类冲突
    head_entity_text: str
    head_entity_label: str
    relation_type: str
    tail_entity_text: str
    tail_entity_label: str

class ExtractedEntitiesAndRelationIntent(BaseModel):
    entities: List[IdentifiedEntity] = Field(default_factory=list, description="从用户查询中识别出的核心实体列表。")
    # --- 新增 "relations" 字段 ---
    relations: List[ExtractedRelationItem] = Field(default_factory=list, description="从用户查询中识别出的关系列表。")
    # --- "relation_hint" 字段可以保留，或者如果您觉得 "relations" 列表更全面，可以考虑移除或标记为废弃 ---
    relation_hint: Optional[str] = Field(None, description="[可选的旧字段] 如果用户查询暗示了实体间的特定关系，这里是关系的文本描述或关键词。新的 'relations' 列表更推荐。")


class QueryExpansionAndKGExtractionOutput(BaseModel):
    expanded_queries: List[str] = Field(
        default_factory=list,
        description="A list of expanded or related questions generated from the original query."
    )
    extracted_entities_for_kg: ExtractedEntitiesAndRelationIntent = Field(
        default_factory=ExtractedEntitiesAndRelationIntent,
        description="Structured entities and relations extracted for Knowledge Graph querying."
    )
    metadata_filter: Optional[Dict[str, Any]] = Field( # <--- 新增字段
        default=None,
        description="An optional metadata filter (e.g., {'filename': 'report.docx'}) to apply during retrieval, if a specific source is mentioned."
    )
    
class RagQueryPlan(BaseModel):
    """
    Represents the output of the V2 RAG query planner.
    It contains the core query string and a metadata filter for precise retrieval.
    """
    query: str = Field(description="The refined, core query string for semantic vector search.")
    metadata_filter: Dict[str, Any] = Field(
        default_factory=dict,
        description="A ChromaDB-compatible 'where' filter for metadata-based pre-filtering of document chunks."
    )
```

    |-- PKG-INFO
    |-- SOURCES.txt
    |-- dependency_links.txt
    |-- requires.txt
    |-- top_level.txt
    |-- ZHZ_AGENT_tasks.db
    |-- __init__.py

``` py

```

    |-- common_utils.py

``` py
# 文件: zhz_rag/utils/common_utils.py

import httpx
import json
import traceback
import os
import glob
from dotenv import load_dotenv
from datetime import datetime, timezone
import uuid
import logging
import asyncio
from typing import List, Dict, Any, Optional
import re
import unicodedata
import glob

load_dotenv()

# --- Logger Configuration ---
utils_logger = logging.getLogger("UtilsLogger")
utils_logger.setLevel(logging.INFO)
if not utils_logger.hasHandlers():
    _utils_console_handler = logging.StreamHandler()
    _utils_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _utils_console_handler.setFormatter(_utils_formatter)
    utils_logger.addHandler(_utils_console_handler)
    utils_logger.propagate = False
utils_logger.info("--- UtilsLogger configured ---")

# --- 【【【【【 核心修正点：统一路径计算逻辑到 zhz_rag 包内 】】】】】 ---
_CURRENT_FILE_DIR = os.path.dirname(os.path.abspath(__file__))
# __file__ 指向 .../zhz_rag/utils/common_utils.py
# os.path.dirname(_CURRENT_FILE_DIR) 将指向 .../zhz_rag/
_ZHZ_RAG_PACKAGE_DIR = os.path.dirname(_CURRENT_FILE_DIR)

STORED_DATA_ROOT_DIR = os.path.join(_ZHZ_RAG_PACKAGE_DIR, 'stored_data')

RAG_INTERACTION_LOGS_DIR = os.path.join(STORED_DATA_ROOT_DIR, 'rag_interaction_logs')
EVALUATION_RESULTS_LOGS_DIR = os.path.join(STORED_DATA_ROOT_DIR, 'evaluation_results_logs')
FINETUNING_GENERATED_DATA_DIR = os.path.join(_ZHZ_RAG_PACKAGE_DIR, 'finetuning', 'generated_data')
# --- 【【【【【 修正结束 】】】】】

# Ensure these directories exist
_DIRECTORIES_TO_CREATE = [
    STORED_DATA_ROOT_DIR,
    RAG_INTERACTION_LOGS_DIR,
    EVALUATION_RESULTS_LOGS_DIR,
    FINETUNING_GENERATED_DATA_DIR
]
for dir_path in _DIRECTORIES_TO_CREATE:
    if not os.path.exists(dir_path):
        try:
            os.makedirs(dir_path, exist_ok=True)
            utils_logger.info(f"Successfully created directory: {dir_path}")
        except Exception as e:
            utils_logger.error(f"Error creating directory {dir_path}: {e}. Consider creating it manually.")

# --- Log File Path Getters (无需修改，它们会使用上面新的常量) ---

def get_interaction_log_filepath() -> str:
    """Gets the full path for the current RAG interaction log file (daily rotation)."""
    today_str = datetime.now(timezone.utc).strftime("%Y%m%d")
    return os.path.join(RAG_INTERACTION_LOGS_DIR, f"rag_interactions_{today_str}.jsonl")

def get_evaluation_result_log_filepath(evaluation_name: str) -> str:
    """Gets the full path for an evaluation result log file (daily rotation, by evaluation name)."""
    today_str = datetime.now(timezone.utc).strftime("%Y%m%d")
    return os.path.join(EVALUATION_RESULTS_LOGS_DIR, f"eval_results_{evaluation_name}_{today_str}.jsonl")

def find_latest_rag_interaction_log(log_dir: str = RAG_INTERACTION_LOGS_DIR) -> Optional[str]:
    """
    Finds the latest RAG interaction log file (rag_interactions_*.jsonl) in the specified directory.
    Defaults to RAG_INTERACTION_LOGS_DIR.
    """
    utils_logger.debug(f"Searching for RAG interaction logs in: {log_dir}")
    rag_log_pattern = os.path.join(log_dir, "rag_interactions_*.jsonl")
    candidate_rag_logs = glob.glob(rag_log_pattern)

    if candidate_rag_logs:
        candidate_rag_logs.sort(key=os.path.getmtime, reverse=True)
        utils_logger.info(f"Automatically selected RAG interaction log: {candidate_rag_logs[0]}")
        return candidate_rag_logs[0]
    else:
        utils_logger.warning(f"No RAG interaction log files found matching pattern: {rag_log_pattern} in directory {log_dir}")
        return None

# --- 其他辅助函数 (保持不变) ---
# MCP Tool Calling Utility
MCPO_BASE_URL = os.getenv("MCPO_BASE_URL", "http://localhost:8006")

async def call_mcpo_tool(tool_name_with_prefix: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    # (此函数内容保持不变)
    api_url = f"{MCPO_BASE_URL}/{tool_name_with_prefix}"
    cleaned_payload = {k: v for k, v in (payload or {}).items() if v is not None}
    utils_logger.info(f"CALL_MCPO_TOOL: Attempting to call {api_url}")
    timeout_config = httpx.Timeout(120.0, connect=10.0, read=120.0, write=10.0)
    async with httpx.AsyncClient(timeout=timeout_config) as client:
        try:
            headers = {"Content-Type": "application/json", "Accept": "application/json"}
            response = await client.post(api_url, json=cleaned_payload, headers=headers)
            response.raise_for_status()
            return {"success": True, "data": response.json()}
        except Exception as exc:
            # Simplified error handling for brevity
            return {"success": False, "error": str(exc)}


def load_jsonl_file(filepath: str, encoding: str = 'utf-8') -> List[Dict[str, Any]]:
    # (此函数内容保持不变)
    data_list: List[Dict[str, Any]] = []
    if not os.path.exists(filepath):
        utils_logger.error(f"File not found: {filepath}")
        return data_list
    try:
        with open(filepath, 'r', encoding=encoding) as f:
            for line in f:
                if line.strip(): data_list.append(json.loads(line.strip()))
    except Exception as e_file:
        utils_logger.error(f"Error reading or processing file {filepath}: {e_file}", exc_info=True)
        return []
    utils_logger.info(f"Successfully loaded {len(data_list)} entries from {filepath}")
    return data_list


def normalize_text_for_id(text: str) -> str:
    # (此函数内容保持不变)
    if not isinstance(text, str): return str(text)
    try:
        normalized_text = unicodedata.normalize('NFKD', text)
        normalized_text = normalized_text.lower().strip()
        return re.sub(r'\s+', ' ', normalized_text)
    except Exception:
        return text

def find_latest_rag_interaction_log(log_dir: str) -> Optional[str]:
    """
    Finds the latest RAG interaction log file in a given directory.
    This is useful for evaluation scripts.
    """
    # 确保我们使用的是此模块自己的 logger
    from .interaction_logger import interaction_logger_module_logger as logger
    logger.debug(f"Searching for RAG interaction logs in: {log_dir}")
    rag_log_pattern = os.path.join(log_dir, "rag_interactions_*.jsonl")
    candidate_rag_logs = glob.glob(rag_log_pattern)
    if candidate_rag_logs:
        candidate_rag_logs.sort(key=os.path.getmtime, reverse=True)
        logger.info(f"Automatically selected RAG interaction log: {candidate_rag_logs[0]}")
        return candidate_rag_logs[0]
    else:
        logger.warning(f"No RAG interaction log files found matching pattern: {rag_log_pattern} in directory {log_dir}")
        return None

def load_jsonl_file(filepath: str, encoding: str = 'utf-8') -> List[Dict[str, Any]]:
    """
    Loads a .jsonl file line by line into a list of dictionaries.
    """
    from .interaction_logger import interaction_logger_module_logger as logger
    data_list: List[Dict[str, Any]] = []
    if not os.path.exists(filepath):
        logger.error(f"File not found: {filepath}")
        return data_list
    try:
        with open(filepath, 'r', encoding=encoding) as f:
            for line_number, line in enumerate(f, 1):
                try:
                    if line.strip():
                        data_list.append(json.loads(line.strip()))
                except json.JSONDecodeError as e_json:
                    logger.warning(f"Skipping malformed JSON line {line_number} in {filepath}: {e_json}")
    except Exception as e_file:
        logger.error(f"Error reading or processing file {filepath}: {e_file}", exc_info=True)
        return []
    logger.info(f"Successfully loaded {len(data_list)} entries from {filepath}")
    return data_list
```

    |-- db_utils.py

``` py
# ZHZ_AGENT/database.py
import os
from databases import Database
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base
from typing import Optional

# --- APScheduler 相关导入 ---
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
# --- [修改] 明确导入并使用 pytz ---
import pytz #

# --- 数据库配置 ---
ZHZ_AGENT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_NAME = "ZHZ_AGENT_tasks.db"
DATABASE_FILE_PATH = os.path.join(ZHZ_AGENT_DIR, DB_NAME)
DATABASE_URL = f"sqlite+aiosqlite:///{DATABASE_FILE_PATH}"

database = Database(DATABASE_URL)
sqlalchemy_engine = create_engine(DATABASE_URL.replace("+aiosqlite", ""))
Base = declarative_base() #

# --- 全局调度器实例定义 ---
scheduler: Optional[AsyncIOScheduler] = None

def get_scheduler() -> AsyncIOScheduler:
    """获取或创建调度器实例，并配置作业存储和 UTC 时区。"""
    global scheduler
    if scheduler is None:
        jobstore_url = f"sqlite:///{DATABASE_FILE_PATH}"
        jobstores = {
            'default': SQLAlchemyJobStore(url=jobstore_url, tablename='apscheduler_jobs_v2') #
        }
        # --- [修复] 明确使用 pytz.utc 设置时区 ---
        scheduler = AsyncIOScheduler(
            jobstores=jobstores,
            timezone=pytz.utc # <--- 强制使用 pytz.utc #
        )
        import logging
        logging.getLogger('apscheduler').setLevel(logging.DEBUG)
        print(f"APScheduler initialized with timezone: {pytz.utc}") # 确认使用 pytz.utc #
    return scheduler #
```

    |-- gemini_api_utils.py

``` py
# 文件: zhz_rag/utils/gemini_api_utils.py

import google.generativeai as genai
import os
from dotenv import load_dotenv
import logging
from typing import Optional

# --- 加载 .env ---
# 这样即使在非Dagster环境中也能获取环境变量
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
dotenv_path = os.path.join(project_root, '.env')
if os.path.exists(dotenv_path):
    load_dotenv(dotenv_path=dotenv_path)

# --- 配置日志 ---
gemini_util_logger = logging.getLogger(__name__)

class GeminiAPIClient:
    """
    一个独立的、不依赖于Dagster的Gemini API客户端。
    """
    def __init__(self, api_key: str, proxy_url: Optional[str] = None):
        self._api_key = api_key
        self._proxy_url = proxy_url
        self._configure_client()
        gemini_util_logger.info("GeminiAPIClient initialized.")

    def _configure_client(self):
        """配置google-generativeai客户端，包括代理。"""
        try:
            if self._proxy_url:
                os.environ['https_proxy'] = self._proxy_url
                os.environ['http_proxy'] = self._proxy_url
                gemini_util_logger.info(f"Using proxy for Gemini API: {self._proxy_url}")
            
            genai.configure(api_key=self._api_key)
        except Exception as e:
            gemini_util_logger.error(f"Failed to configure Gemini client: {e}", exc_info=True)
            raise

    @classmethod
    def from_env(cls):
        """通过环境变量方便地创建实例。"""
        api_key = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY")
        if not api_key:
            raise ValueError("GEMINI_API_KEY or GOOGLE_API_KEY not found in environment variables.")
        
        proxy_url = os.getenv("LITELLM_PROXY_URL") # 复用这个代理配置
        return cls(api_key=api_key, proxy_url=proxy_url)

    def get_model(self, model_name: str = "gemini-1.5-flash-latest"):
        """获取一个配置好的GenerativeModel实例。"""
        try:
            return genai.GenerativeModel(model_name)
        except Exception as e:
            gemini_util_logger.error(f"Failed to get Gemini model '{model_name}': {e}", exc_info=True)
            return None
```

    |-- hardware_manager.py

``` py
# zhz_agent/utils/hardware_manager.py
import os
import psutil
import torch
import logging
from typing import Optional, Dict, Any

# 配置日志记录器
logger = logging.getLogger(__name__)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.setLevel(logging.INFO)

class HardwareInfo:
    """用于存储检测到的硬件信息的简单数据类"""
    def __init__(self,
                 cpu_logical_cores: int,
                 cpu_physical_cores: int,
                 total_system_ram_gb: float,
                 gpu_available: bool = False,
                 gpu_name: Optional[str] = None,
                 gpu_vram_total_gb: float = 0.0):
        self.cpu_logical_cores = cpu_logical_cores
        self.cpu_physical_cores = cpu_physical_cores
        self.total_system_ram_gb = total_system_ram_gb
        self.gpu_available = gpu_available
        self.gpu_name = gpu_name
        self.gpu_vram_total_gb = gpu_vram_total_gb

    def __str__(self):
        gpu_str = (f"GPU: {self.gpu_name} with {self.gpu_vram_total_gb:.2f} GB VRAM"
                   if self.gpu_available else "GPU: Not available or not detected")
        return (f"HardwareInfo(CPU: {self.cpu_physical_cores} Physical/{self.cpu_logical_cores} Logical Cores, "
                f"RAM: {self.total_system_ram_gb:.2f} GB, {gpu_str})")

class HardwareManager:
    """
    硬件抽象层 (HAL)，用于检测系统当前的硬件特性，
    并为上层应用提供一个统一的接口来查询和利用这些资源。
    """
    def __init__(self):
        logger.info("Initializing HardwareManager...")
        self.hw_info: Optional[HardwareInfo] = None
        self._detect_hardware()
        if self.hw_info:
            logger.info(f"Hardware detection complete: {self.hw_info}")
        else:
            logger.error("Hardware detection failed to produce valid HardwareInfo.")

    def _detect_cpu_info(self) -> Dict[str, Any]:
        """检测CPU信息"""
        try:
            logical_cores = psutil.cpu_count(logical=True)
            physical_cores = psutil.cpu_count(logical=False)
            if physical_cores is None:
                logger.warning("Could not determine physical core count, using logical core count as fallback.")
                physical_cores = logical_cores
            logger.info(f"CPU Info: Logical cores={logical_cores}, Physical cores={physical_cores}")
            return {"cpu_logical_cores": logical_cores, "cpu_physical_cores": physical_cores}
        except Exception as e:
            logger.error(f"Error detecting CPU info: {e}", exc_info=True)
            return {"cpu_logical_cores": 1, "cpu_physical_cores": 1}

    def _detect_memory_info(self) -> Dict[str, Any]:
        """检测内存信息"""
        try:
            virtual_mem = psutil.virtual_memory()
            total_ram_gb = virtual_mem.total / (1024 ** 3)
            logger.info(f"Memory Info: Total RAM={total_ram_gb:.2f} GB")
            return {"total_system_ram_gb": total_ram_gb}
        except Exception as e:
            logger.error(f"Error detecting memory info: {e}", exc_info=True)
            return {"total_system_ram_gb": 0.0}

    def _detect_gpu_info(self) -> Dict[str, Any]:
        """检测GPU信息 (目前仅NVIDIA GPU通过torch.cuda)"""
        gpu_details = {"gpu_available": False, "gpu_name": None, "gpu_vram_total_gb": 0.0}
        try:
            if torch.cuda.is_available():
                gpu_details["gpu_available"] = True
                device_id = 0
                gpu_name = torch.cuda.get_device_name(device_id)
                props = torch.cuda.get_device_properties(device_id)
                vram_total_gb = props.total_memory / (1024 ** 3)
                gpu_details["gpu_name"] = gpu_name
                gpu_details["gpu_vram_total_gb"] = vram_total_gb
                logger.info(f"NVIDIA GPU Detected: Name='{gpu_name}', VRAM={vram_total_gb:.2f} GB")
            else:
                logger.info("torch.cuda.is_available() returned False. No compatible NVIDIA GPU detected.")
        except Exception as e:
            logger.error(f"Error detecting NVIDIA GPU info: {e}", exc_info=True)
        return gpu_details

    def _detect_hardware(self):
        """执行所有硬件检测并填充 HardwareInfo"""
        cpu_info = self._detect_cpu_info()
        mem_info = self._detect_memory_info()
        gpu_info = self._detect_gpu_info()
        
        self.hw_info = HardwareInfo(
            cpu_logical_cores=cpu_info["cpu_logical_cores"],
            cpu_physical_cores=cpu_info["cpu_physical_cores"],
            total_system_ram_gb=mem_info["total_system_ram_gb"],
            gpu_available=gpu_info["gpu_available"],
            gpu_name=gpu_info["gpu_name"],
            gpu_vram_total_gb=gpu_info["gpu_vram_total_gb"]
        )

    def get_hardware_info(self) -> Optional[HardwareInfo]:
        """返回检测到的硬件信息"""
        return self.hw_info

    def recommend_llm_gpu_layers(self, model_total_layers: int, model_size_on_disk_gb: float, kv_cache_gb_per_1k_ctx: float = 0.25, context_length_tokens: int = 4096, safety_buffer_vram_gb: float = 1.5) -> int:
        """根据可用VRAM推荐LLM应卸载到GPU的层数。"""
        if not self.hw_info or not self.hw_info.gpu_available or self.hw_info.gpu_vram_total_gb == 0:
            logger.info("GPU not available, recommending 0 GPU layers (CPU only).")
            return 0

        estimated_kv_cache_vram_gb = (context_length_tokens / 1000) * kv_cache_gb_per_1k_ctx
        available_vram_for_model_weights_gb = self.hw_info.gpu_vram_total_gb - estimated_kv_cache_vram_gb - safety_buffer_vram_gb
        logger.info(f"VRAM Details: Total={self.hw_info.gpu_vram_total_gb:.2f}GB, Est. KV Cache={estimated_kv_cache_vram_gb:.2f}GB, Safety Buffer={safety_buffer_vram_gb:.2f}GB. Available for weights={available_vram_for_model_weights_gb:.2f}GB.")

        if available_vram_for_model_weights_gb <= 0:
            return 0
        
        if available_vram_for_model_weights_gb >= model_size_on_disk_gb:
            logger.info(f"Sufficient VRAM to offload all {model_total_layers} layers.")
            return -1
        else:
            proportion_of_model_can_fit = available_vram_for_model_weights_gb / model_size_on_disk_gb
            recommended_layers = int(model_total_layers * proportion_of_model_can_fit)
            logger.info(f"VRAM can fit ~{proportion_of_model_can_fit:.0%}. Recommending {recommended_layers} GPU layers.")
            return min(max(0, recommended_layers), model_total_layers)

    def recommend_concurrent_tasks(self, task_type: str = "cpu_bound_llm") -> int:
        """根据CPU核心数和任务类型推荐并发任务数"""
        if not self.hw_info:
            return 1
        if task_type == "cpu_bound_llm":
            return max(1, self.hw_info.cpu_physical_cores // 2)
        elif task_type == "io_bound":
            return self.hw_info.cpu_logical_cores * 2
        else:
            return self.hw_info.cpu_physical_cores

# --- main 用于测试 HardwareManager ---
if __name__ == "__main__":
    import os # 需要导入os才能在_detect_cpu_info的fallback中使用os.cpu_count()
    print("--- Testing HardwareManager ---")
    hw_manager = HardwareManager()
    hw_info = hw_manager.get_hardware_info()
    
    if hw_info:
        print("\n--- Detected Hardware ---")
        print(f"   CPU Logical Cores: {hw_info.cpu_logical_cores}")
        print(f"   CPU Physical Cores: {hw_info.cpu_physical_cores}")
        print(f"   Total System RAM: {hw_info.total_system_ram_gb:.2f} GB")
        if hw_info.gpu_available:
            print(f"   GPU Name: {hw_info.gpu_name}")
            print(f"   GPU VRAM Total: {hw_info.gpu_vram_total_gb:.2f} GB")
        else:
            print("   GPU: Not available or not detected.")
        
        print("\n--- Recommendations ---")
        # 假设一个1.7B Q8模型 (约1.8GB磁盘大小)，模型总共32层 (Qwen1.7B是28层，这里用32示意)
        # 上下文长度4096，每1k上下文KV缓存占用0.25GB VRAM (fp16时约0.23GB/1k，这里取个近似值)
        # 安全余量1.5GB VRAM
        model_layers = 28 # Qwen3-1.7B
        model_disk_size = 1.8 # GB
        ctx_len = 4096
        kv_per_1k_ctx = 0.25 
        vram_buffer = 1.5

        recommended_gpu_layers = hw_manager.recommend_llm_gpu_layers(
            model_total_layers=model_layers,
            model_size_on_disk_gb=model_disk_size,
            kv_cache_gb_per_1k_ctx=kv_per_1k_ctx,
            context_length_tokens=ctx_len,
            safety_buffer_vram_gb=vram_buffer
        )
        print(f"   Recommended LLM GPU Layers (for {model_disk_size}GB model, {model_layers} layers, {ctx_len} ctx): {recommended_gpu_layers}")
        
        recommended_llm_workers = hw_manager.recommend_concurrent_tasks(task_type="cpu_bound_llm")
        print(f"   Recommended Concurrent LLM Tasks (cpu_bound_llm): {recommended_llm_workers}")
        
        recommended_io_workers = hw_manager.recommend_concurrent_tasks(task_type="io_bound")
        print(f"   Recommended Concurrent I/O Tasks: {recommended_io_workers}")

    else:
        print("Failed to get hardware information.")

```

    |-- interaction_logger.py

``` py
# 文件: zhz_rag/utils/interaction_logger.py
import os
import json
import asyncio
from typing import Dict, Any, Optional
from datetime import datetime, timezone
import logging
import aiofiles  # 使用 aiofiles 进行异步文件操作
import uuid
import traceback
import sys # <--- 添加此行

# --- 配置此模块的logger ---
# 使用一个特定的名字，以便在项目中其他地方可以按名获取，避免与根logger混淆
interaction_logger_module_logger = logging.getLogger("InteractionLoggerUtil")
# 建议从环境变量或配置文件读取日志级别，提供默认值
interaction_logger_module_logger.setLevel(os.getenv("INTERACTION_LOG_LEVEL", "INFO").upper())
# 设置propagate = False以防止日志消息被传递到父级logger（如root logger），避免重复输出
interaction_logger_module_logger.propagate = False

# 确保只添加一次处理器，防止重复配置
if not interaction_logger_module_logger.hasHandlers():
    _il_console_handler = logging.StreamHandler()
    _il_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _il_console_handler.setFormatter(_il_formatter)
    interaction_logger_module_logger.addHandler(_il_console_handler)
    interaction_logger_module_logger.info("--- InteractionLoggerUtil configured ---")


# --- 定义日志存储目录常量 ---
# __file__ 指向 .../zhz_rag/utils/interaction_logger.py
_CURRENT_FILE_DIR_IL = os.path.dirname(os.path.abspath(__file__))
# _ZHZ_RAG_PACKAGE_DIR_IL 指向 .../zhz_rag
_ZHZ_RAG_PACKAGE_DIR_IL = os.path.dirname(_CURRENT_FILE_DIR_IL)

# STORED_DATA_ROOT_DIR_IL 指向 .../zhz_rag/stored_data
_STORED_DATA_ROOT_DIR_IL = os.path.join(_ZHZ_RAG_PACKAGE_DIR_IL, 'stored_data')

RAG_INTERACTION_LOGS_DIR_DEFAULT = os.path.join(_STORED_DATA_ROOT_DIR_IL, 'rag_interaction_logs')
EVALUATION_RESULTS_LOGS_DIR_DEFAULT = os.path.join(_STORED_DATA_ROOT_DIR_IL, 'evaluation_results_logs')


async def _async_write_to_jsonl_robust(filepath: str, interaction_json_string: str):
    """
    一个健壮的异步函数，用于将字符串追加到文件。
    使用了 aiofiles 库来避免阻塞事件循环。
    """
    logger_to_use = interaction_logger_module_logger
    logger_to_use.debug(f"ASYNC_WRITE_ROBUST: Attempting to write to {filepath}")
    try:
        async with aiofiles.open(filepath, mode='a', encoding='utf-8') as f:
            await f.write(interaction_json_string)
            await f.flush() # aiofiles 的 flush 也是异步的
        logger_to_use.debug(f"ASYNC_WRITE_ROBUST: Successfully wrote and flushed to {filepath}")
    except Exception as e:
        logger_to_use.error(f"CRITICAL_LOG_FAILURE in _async_write_to_jsonl_robust: Failed to write to {filepath}. Error: {e}", exc_info=True)
        # 备用方案
        # print(f"CRITICAL_LOG_FAILURE: Could not write to {filepath}. Error: {e}")
        # traceback.print_exc()

def _sync_write_to_jsonl_robust(filepath: str, interaction_json_string: str):
    """
    一个健壮的同步函数，用于将字符串追加到文件，并确保数据刷入磁盘。
    """
    logger_to_use = interaction_logger_module_logger
    logger_to_use.debug(f"SYNC_WRITE_ROBUST: Attempting to write to {filepath}")
    try:
        # 'a' for append. '+' is not strictly needed for 'a' as it creates the file if it doesn't exist.
        with open(filepath, 'a', encoding='utf-8') as f:
            f.write(interaction_json_string)
            # 步骤1: 确保Python应用层缓冲区的内容写入操作系统缓冲区
            f.flush()
            # 步骤2: 请求操作系统将缓冲区内容实际写入磁盘，提供最强保证
            os.fsync(f.fileno())
        logger_to_use.debug(f"SYNC_WRITE_ROBUST: Successfully wrote and synced to {filepath}")
    except Exception as e:
        # 这种底层的关键日志如果失败，需要非常明确的错误提示
        logger_to_use.error(f"CRITICAL_LOG_FAILURE in _sync_write_to_jsonl_robust: Failed to write to {filepath}. Error: {e}", exc_info=True)


async def log_interaction_data(
    log_data: Dict[str, Any],
    is_evaluation_result: bool = False,
    evaluation_name_for_file: Optional[str] = None
):
    """
    Asynchronously logs interaction data to a JSONL file in the appropriate directory.

    Args:
        log_data (Dict[str, Any]): The dictionary containing the data to log.
        is_evaluation_result (bool): If True, logs to the evaluation results directory. 
                                     Otherwise, logs to the standard RAG interaction directory.
        evaluation_name_for_file (Optional[str]): A specific name for the evaluation file, e.g., 'answer_gemini'.
    """
    try:
        # --- 修正：根据 is_evaluation_result 选择正确的目录 ---
        if is_evaluation_result:
            target_dir = os.getenv("EVALUATION_RESULTS_LOGS_DIR", EVALUATION_RESULTS_LOGS_DIR_DEFAULT)
            if not evaluation_name_for_file:
                evaluation_name_for_file = "default_eval"
            # 文件名格式: eval_results_指定的名称_日期.jsonl
            log_filename = f"eval_results_{evaluation_name_for_file}_{datetime.now(timezone.utc).strftime('%Y%m%d')}.jsonl"
        else:
            target_dir = os.getenv("RAG_INTERACTION_LOGS_DIR", RAG_INTERACTION_LOGS_DIR_DEFAULT)
            # 文件名格式: rag_interactions_日期.jsonl
            log_filename = f"rag_interactions_{datetime.now(timezone.utc).strftime('%Y%m%d')}.jsonl"

        # 确保目标目录存在
        os.makedirs(target_dir, exist_ok=True)
        log_filepath = os.path.join(target_dir, log_filename)

        # 准备要写入的JSON字符串
        # 确保时间戳是字符串格式，避免JSON序列化问题
        if 'timestamp_utc' in log_data and isinstance(log_data['timestamp_utc'], datetime):
             log_data['timestamp_utc'] = log_data['timestamp_utc'].isoformat()
        
        log_entry_str = json.dumps(log_data, ensure_ascii=False)

        # 异步写入文件
        await _async_write_to_jsonl_robust(log_filepath, log_entry_str + '\n')
        
    except Exception as e:
        # 在独立的日志系统中记录日志本身的错误
        interaction_logger_module_logger.error(f"Failed to log interaction data. Error: {e}", exc_info=True)
        interaction_logger_module_logger.error(f"Original log data that failed: {str(log_data)[:500]}")

def get_logger(name: str) -> logging.Logger:
    """
    一个通用的函数，用于获取或创建具有标准配置的logger。
    这避免了在每个模块中重复配置logger。
    """
    logger = logging.getLogger(name)
    if not logger.hasHandlers():
        logger.setLevel(os.getenv(f"{name.upper()}_LOG_LEVEL", "INFO").upper())
        logger.propagate = False
        handler = logging.StreamHandler(sys.stdout) # 确保日志输出到标准输出
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - PID:%(process)d - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    return logger
```

    |-- load_neo4j_data.py

``` py
# zhz_agent/load_neo4j_data.py
import json
import os
from neo4j import GraphDatabase, basic_auth
from dotenv import load_dotenv
import traceback

load_dotenv() # 确保加载 .env 文件中的NEO4J凭证

NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD") # 您需要确保这个密码是正确的

DATA_PATH = os.path.join(os.path.dirname(__file__), "data")
SAMPLE_KG_PATH = os.path.join(DATA_PATH, "sample_kg.json")

def clear_database(driver):
    """清除数据库中的所有节点和关系"""
    with driver.session(database="neo4j") as session:
        session.run("MATCH (n) DETACH DELETE n")
        print("Cleared all nodes and relationships from the database.")

def create_constraints(driver):
    """创建一些基本约束，确保节点属性的唯一性（如果适用）"""
    with driver.session(database="neo4j") as session:
        try:
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (p:Person) REQUIRE p.name IS UNIQUE")
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (pr:Project) REQUIRE pr.name IS UNIQUE")
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (r:Region) REQUIRE r.name IS UNIQUE")
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (prod:Product) REQUIRE prod.name IS UNIQUE")
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE")
            # SalesAmount 通常不需要唯一约束，因为它可能重复（例如不同区域同一时期的销售）
            print("Ensured constraints are created (or already exist).")
        except Exception as e:
            print(f"Error creating constraints: {e}")


def load_data(driver, kg_data):
    """根据kg_data中的facts加载数据到Neo4j"""
    facts = kg_data.get("facts", [])
    
    with driver.session(database="neo4j") as session:
        entities_to_create = set()
        node_types_from_schema = { # 定义了主要实体的标签和它们的主要标识属性
            "Person": "name", "Project": "name", "Region": "name", 
            "Product": "name", "Document": "id", "Idea": "name" # 新增Idea类型
        }

        for fact in facts:
            subject_name = fact.get("subject")
            object_name = fact.get("object")
            fact_type = fact.get("type", "")

            subject_label = None
            # 基于fact_type或其他逻辑推断subject_label
            if "person_" in fact_type: subject_label = "Person"
            elif "region_" in fact_type: subject_label = "Region"
            elif "product_" in fact_type: subject_label = "Product"
            # ... 其他类型的映射 ...
            
            if subject_label and subject_name:
                prop_name = node_types_from_schema.get(subject_label, "name")
                entities_to_create.add((subject_label, prop_name, subject_name))

            object_label = None
            if not fact_type.endswith("_amount"): # 不是直接的销售额事实
                if "_project" in fact_type: object_label = "Project"
                elif "_product" in fact_type: object_label = "Product"
                elif "_document" in fact_type: object_label = "Document"
                elif "_idea" in fact_type: object_label = "Idea" # 新增对Idea类型的处理
                # ... 其他类型的映射 ...

                if object_label and object_name:
                    prop_name = node_types_from_schema.get(object_label, "name") # Document会用id, Idea会用name
                    entities_to_create.add((object_label, prop_name, object_name))
        
        for label, prop, value in entities_to_create:
            if value is not None:
                query = f"MERGE (n:{label} {{{prop}: $value}})"
                session.run(query, value=value)
                print(f"Merged node: ({label} {{{prop}: '{value}'}})")

        for fact in facts:
            s_name = fact.get("subject")
            rel = fact.get("relation")
            o_name = fact.get("object")
            fact_type = fact.get("type", "")
            period = fact.get("period")

            if fact_type == "region_sales_amount" and period:
                session.run("MERGE (r:Region {name: $s_name})", s_name=s_name)
                try:
                    # ... (销售额解析逻辑不变) ...
                    if isinstance(o_name, str) and '万元' in o_name:
                        numeric_val_str = o_name.replace('万元', '').strip()
                        numeric_val = float(numeric_val_str)
                        unit_val = '万元'
                    # ... (其他单位解析) ...
                    else:
                        numeric_val = float(o_name) # 尝试直接转换
                        unit_val = None 
                    
                    query = """
                    MATCH (r:Region {name: $s_name})
                    CREATE (sa:SalesAmount {numeric_amount: $num_val, period: $period, unit: $unit_val})
                    CREATE (r)-[:HAS_SALES_AMOUNT]->(sa)
                    """
                    session.run(query, s_name=s_name, num_val=numeric_val, period=period, unit_val=unit_val)
                    print(f"Created SalesAmount for {s_name}, {period}: {numeric_val} {unit_val or ''}")
                except ValueError:
                    print(f"Could not parse sales amount: {o_name} for {s_name}, {period}. Skipping this SalesAmount fact.")
                
            elif s_name and rel and o_name: 
                s_label, o_label = None, None
                s_prop, o_prop = "name", "name" 

                # --- 更精确的标签和属性推断 ---
                if fact_type == "person_project" and rel == "WORKS_ON":
                    s_label, o_label = "Person", "Project"
                elif fact_type == "person_idea" and rel == "PROPOSED_IDEA": # 新增
                    s_label, o_label = "Person", "Idea"
                elif fact_type == "region_product" and rel == "HAS_SALES_PRODUCT": # 假设type是 region_product
                    s_label, o_label = "Region", "Product"
                elif fact_type == "product_document" and rel == "RELATED_TO":
                    s_label, o_label = "Product", "Document"
                    o_prop = "id" # Document用id匹配
                # 您可以根据您的fact_type添加更多精确的映射规则

                if s_label and o_label:
                    query = f"""
                    MATCH (s:{s_label} {{{s_prop}: $s_name}})
                    MATCH (o:{o_label} {{{o_prop}: $o_name}})
                    MERGE (s)-[:{rel}]->(o)
                    """
                    session.run(query, s_name=s_name, o_name=o_name)
                    print(f"Merged relationship: ({s_label} {{{s_prop}:'{s_name}'}})-[:{rel}]->({o_label} {{{o_prop}:'{o_name}'}})")
                else:
                    print(f"Could not determine labels for fact: {fact} (s_label: {s_label}, o_label: {o_label}). Relationship not created.")
            else:
                print(f"Skipping incomplete fact: {fact}")


if __name__ == "__main__":
    driver = None
    try:
        driver = GraphDatabase.driver(NEO4J_URI, auth=basic_auth(NEO4J_USER, NEO4J_PASSWORD))
        driver.verify_connectivity()
        print("Successfully connected to Neo4j.")
        
        clear_database(driver) # 清空数据库
        create_constraints(driver) # 创建约束

        with open(SAMPLE_KG_PATH, 'r', encoding='utf-8') as f:
            kg_data_to_load = json.load(f)
        
        load_data(driver, kg_data_to_load)
        
        print("\nData loading process completed.")
        print("You can now verify the data in Neo4j Browser (http://localhost:7474).")
        print("Example query to check SalesAmount:")
        print("MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount) RETURN r.name, sa.numeric_amount, sa.unit, sa.period")
        print("Example query to check Person-Project:")
        print("MATCH (p:Person)-[:WORKS_ON]->(proj:Project) RETURN p.name, proj.name")

    except Exception as e:
        print(f"An error occurred: {e}")
        traceback.print_exc()
    finally:
        if driver:
            driver.close()
            print("Neo4j connection closed.")
```

    |-- retrievers/
    |-- __init__.py

``` py
# zhz_agent/core_rag/__init__.py
from .kg_retriever import KGRetriever
from .fusion_engine import FusionEngine
# 如果上面 retrievers/__init__.py 也做了导出，这里也可以考虑是否进一步导出
```

    |-- fusion_engine.py

``` py
import os
import hashlib
import jieba
from typing import List, Dict, Any, Optional
import logging
import asyncio
from sentence_transformers import CrossEncoder

from zhz_rag.config.pydantic_models import RetrievedDocument

class FusionEngine:
    def __init__(self, logger: Optional[logging.Logger] = None, rrf_k: int = 60):
        if logger:
            self.logger = logger
        else:
            self.logger = logging.getLogger("FusionEngineLogger")
            if not self.logger.hasHandlers():
                self.logger.setLevel(logging.INFO)
                handler = logging.StreamHandler()
                formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s')
                handler.setFormatter(formatter)
                self.logger.addHandler(handler)
        
        self.rrf_k = rrf_k
        self.cross_encoder: Optional[CrossEncoder] = None # 明确类型
        
        # --- 在初始化时就调用加载 ---
        self._initialize_reranker()

    def _initialize_reranker(self):
        """
        严格从本地路径初始化Cross-Encoder模型。
        如果本地路径不存在，则禁用再排序功能。
        """
        # --- 使用您指定的本地模型路径 ---
        # 模型名称/ID
        model_name = "BAAI/bge-reranker-base"
        # 构建本地路径
        local_model_path = os.path.join(os.path.expanduser("~"), "models", model_name)

        self.logger.info(f"Attempting to load reranker model from local path: {local_model_path}")

        if not os.path.isdir(local_model_path):
            self.logger.error(f"Reranker model directory not found at: '{local_model_path}'. Reranking will be disabled.")
            self.cross_encoder = None
            return

        try:
            # 直接将本地路径传递给CrossEncoder
            self.cross_encoder = CrossEncoder(local_model_path, max_length=512)
            self.logger.info(f"Cross-Encoder model loaded successfully from '{local_model_path}'.")
        except Exception as e:
            self.logger.error(f"Failed to load Cross-Encoder model from '{local_model_path}': {e}", exc_info=True)
            self.cross_encoder = None
            
    async def rerank_documents(
        self,
        query: str,
        documents: List[RetrievedDocument],
        top_n: int = 5
    ) -> List[RetrievedDocument]:
        """
        使用Cross-Encoder模型对文档列表进行再排序，返回相关性最高的top_n个文档。
        """
        if self.cross_encoder is None:
            self.logger.warning("Reranker is not available, returning top_n documents without reranking.")
            return documents[:top_n]

        if not documents:
            return []

        if not query:
            self.logger.warning("Reranking query is empty. Returning original documents.")
            return documents
        
        self.logger.info(f"Reranking {len(documents)} documents for query: '{query[:50]}...'")

        model_input_pairs = [[query, doc.content] for doc in documents]
        
        def _predict():
            # 使用 try-except 包装 predict 调用，增加鲁棒性
            try:
                return self.cross_encoder.predict(model_input_pairs, show_progress_bar=False)
            except Exception as e:
                self.logger.error(f"Error during Cross-Encoder prediction: {e}", exc_info=True)
                return [] # 返回空列表表示预测失败
            
        scores = await asyncio.to_thread(_predict)

        if len(scores) != len(documents):
            self.logger.error("Reranking failed: number of scores does not match number of documents.")
            return documents[:top_n] # 失败时返回原始文档
        
        for doc, score in zip(documents, scores):
            doc.score = float(score)

        reranked_docs = sorted(documents, key=lambda d: d.score or -1.0, reverse=True)
        
        if reranked_docs:
            self.logger.info(f"Reranking complete. Top score: {reranked_docs[0].score:.4f}")
        
        return reranked_docs[:top_n]

    # ( _apply_rrf 和 fuse_results_with_rrf 方法保持不变 )
    def _apply_rrf(self, all_docs: List[RetrievedDocument]) -> List[RetrievedDocument]:
        if not all_docs:
            return []
        docs_by_source: Dict[str, List[RetrievedDocument]] = {}
        for doc in all_docs:
            source_type = doc.source_type or "unknown_source"
            if source_type not in docs_by_source:
                docs_by_source[source_type] = []
            docs_by_source[source_type].append(doc)

        doc_scores: Dict[str, float] = {}
        doc_objects: Dict[str, RetrievedDocument] = {}

        for source_type, docs_list in docs_by_source.items():
            sorted_docs = sorted(docs_list, key=lambda d: d.score if d.score is not None else -1, reverse=True)
            for rank, doc in enumerate(sorted_docs, 1):
                content_hash = hashlib.md5(doc.content.encode('utf-8')).hexdigest()
                if content_hash not in doc_scores:
                    doc_scores[content_hash] = 0.0
                    doc_objects[content_hash] = doc
                doc_scores[content_hash] += 1.0 / (self.rrf_k + rank)
        fused_results = []
        for content_hash, rrf_score in doc_scores.items():
            doc_obj = doc_objects[content_hash]
            doc_obj.score = rrf_score
            fused_results.append(doc_obj)
        fused_results.sort(key=lambda d: d.score or 0.0, reverse=True)
        return fused_results

    async def fuse_results_with_rrf(
        self,
        all_raw_retrievals: List[RetrievedDocument],
        top_n_final: int = 3
    ) -> List[RetrievedDocument]:
        self.logger.info(f"Fusing {len(all_raw_retrievals)} raw documents using RRF.")
        fused_and_ranked_results = self._apply_rrf(all_raw_retrievals)
        return fused_and_ranked_results[:top_n_final]
```

    |-- kg_retriever.py

``` py
# 文件: zhz_rag/core_rag/kg_retriever.py
import os
import json
import duckdb
from typing import List, Dict, Any, Optional, Iterator, TYPE_CHECKING
import logging
from contextlib import contextmanager
import asyncio
from cachetools import TTLCache # <--- 添加这一行
if TYPE_CHECKING:
    from zhz_rag.llm.local_model_handler import LocalModelHandler

from zhz_rag.config.pydantic_models import ExtractedEntitiesAndRelationIntent
from zhz_rag.utils.common_utils import normalize_text_for_id
from zhz_rag.utils.interaction_logger import log_interaction_data # <--- 确保这行存在
import uuid # <--- 添加导入
from datetime import datetime, timezone # <--- 添加导入

# 日志配置
kg_logger = logging.getLogger(__name__)
if not kg_logger.hasHandlers():
    kg_logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s')
    ch.setFormatter(formatter)
    kg_logger.addHandler(ch)
    kg_logger.propagate = False
kg_logger.info("KGRetriever (DuckDB) logger initialized/reconfirmed.")


class KGRetriever:
    # 使用 DuckDB 的环境变量或默认路径
    DUCKDB_KG_FILE_PATH_ENV = os.getenv(
        "DUCKDB_KG_FILE_PATH",
        os.path.join(os.getenv("ZHZ_AGENT_PROJECT_ROOT", "/home/zhz/zhz_agent"), "zhz_rag", "stored_data", "duckdb_knowledge_graph.db")
    )

    def __init__(self, db_file_path: Optional[str] = None, embedder: Optional['LocalModelHandler'] = None):
        self.db_file_path = db_file_path if db_file_path else self.DUCKDB_KG_FILE_PATH_ENV
        self._embedder = embedder
        self._retrieval_cache: TTLCache = TTLCache(maxsize=100, ttl=300) # <--- 修改这一行
        self._retrieval_cache_lock = asyncio.Lock()
        kg_logger.info(f"KGRetriever (DuckDB) initialized. DB file path set to: {self.db_file_path}")

        if not os.path.exists(self.db_file_path):
            kg_logger.warning(f"DuckDB database file not found at {self.db_file_path}. Retrieval operations will likely fail if the DB is not created by the Dagster pipeline first.")
        
        # 健康检查
        try:
            with self._get_duckdb_connection() as conn_test:
                result = conn_test.execute("SELECT 42;").fetchone()
                if result and result[0] == 42:
                    kg_logger.info("DuckDB connection test successful and VSS setup attempted in _get_duckdb_connection.")
                else:
                    kg_logger.warning("DuckDB connection test failed to return expected result.")
        except Exception as e_init_conn_test:
            kg_logger.error(f"Error during initial DuckDB connection test: {e_init_conn_test}", exc_info=True)
    
    @contextmanager
    def _get_duckdb_connection(self) -> Iterator[duckdb.DuckDBPyConnection]:
        """
        建立并返回一个DuckDB连接的上下文管理器。
        """
        conn: Optional[duckdb.DuckDBPyConnection] = None
        kg_logger.debug(f"_get_duckdb_connection: Attempting to connect to DB at {self.db_file_path}")
        try:
            if not os.path.exists(self.db_file_path):
                raise FileNotFoundError(f"DuckDB file '{self.db_file_path}' does not exist when trying to open connection.")

            conn = duckdb.connect(database=self.db_file_path, read_only=False)
            kg_logger.debug(f"DuckDB Connection object created for path: {self.db_file_path} (read_only=False)")
            
            try:
                conn.execute("LOAD vss;")
                kg_logger.debug("DuckDB: VSS extension loaded on connection.")
            except Exception as e_vss_setup:
                kg_logger.warning(f"DuckDB: Failed to setup VSS extension on connect: {e_vss_setup}. This might be okay if already set or not needed for this operation.")
            yield conn
        except Exception as e_outer:
            kg_logger.error(f"Error in _get_duckdb_connection: {e_outer}", exc_info=True)
            raise
        finally:
            kg_logger.debug("_get_duckdb_connection: Exiting context.")
            if conn:
                kg_logger.debug("Closing DuckDB connection.")
                conn.close()

    def _execute_duckdb_sql_query_sync(self, query: str, parameters: Optional[List[Any]] = None) -> List[Dict[str, Any]]:
        """
        执行DuckDB SQL查询并返回结果列表。
        （此版本不再包含通用日志记录逻辑）
        """
        kg_logger.info(f"--- Executing DuckDB SQL --- Query: {query.strip()}")
        if parameters:
            log_params = [
                str(p)[:100] + '...' if isinstance(p, list) and len(str(p)) > 100 else p
                for p in parameters
            ]
            kg_logger.info(f"Params: {log_params}")

        results_list: List[Dict[str, Any]] = []
        try:
            with self._get_duckdb_connection() as conn:
                prepared_statement = conn.execute(query, parameters)
                
                if prepared_statement.description:
                    column_names = [desc[0] for desc in prepared_statement.description]
                    raw_results = prepared_statement.fetchall()
                    
                    for row_tuple in raw_results:
                        results_list.append(dict(zip(column_names, row_tuple)))
                        
                kg_logger.info(f"DuckDB SQL executed. Records count: {len(results_list)}")
                if results_list: 
                    kg_logger.debug(f"First DuckDB record: {str(results_list[0])[:200]}")
                else:
                     kg_logger.debug("DuckDB SQL query returned 0 records.")
        except duckdb.Error as duckdb_err:
             kg_logger.error(f"DuckDB Error during SQL execution: '{query}'. Error: {duckdb_err}", exc_info=True)
        except Exception as e:
            kg_logger.error(f"Unexpected error executing DuckDB SQL query: '{query}'. Error: {e}", exc_info=True)
        return results_list
    
    def _format_duckdb_records_for_retrieval(
        self, 
        records: List[Dict[str, Any]], 
        query_context: str = "",
        source_type_prefix: str = "duckdb_kg"
    ) -> List[Dict[str, Any]]:
        formatted_docs = []
        if not records:
            return formatted_docs

        for record_data in records:
            content_parts = []
            entity_text = record_data.get("text") or record_data.get("target_text") or record_data.get("source_text")
            entity_label = record_data.get("label") or record_data.get("target_label") or record_data.get("source_label")
            relation_type = record_data.get("relation_type")
            
            if "source_text" in record_data and "target_text" in record_data and relation_type:
                content_parts = [
                    f"Source: {record_data['source_text']} ({record_data.get('source_label', 'Entity')})",
                    f"Relation: {relation_type}",
                    f"Target: {record_data['target_text']} ({record_data.get('target_label', 'Entity')})"
                ]
            elif entity_text:
                content_parts.append(f"Entity: {entity_text}")
                if entity_label:
                    content_parts.append(f"Label: {entity_label}")
            else:
                content_parts.append(f"Retrieved KG data: {json.dumps({k:v for k,v in record_data.items() if k != 'embedding'}, ensure_ascii=False, default=str)[:100]}")

            content_str = " | ".join(content_parts)
            
            doc_metadata = {
                "original_user_query_for_kg": query_context,
                "duckdb_retrieved_id_prop": record_data.get("id_prop") or record_data.get("source_id_prop"),
                "duckdb_retrieved_data": {k:v for k,v in record_data.items() if k != 'embedding'}
            }
            if record_data.get("_source_strategy"):
                doc_metadata["_source_strategy"] = record_data.get("_source_strategy")

            score_value = record_data.get("distance")
            if score_value is None:
                score_value = record_data.get("_score")

            if record_data.get("distance") is not None:
                similarity_score = 1.0 / (1.0 + float(score_value)) if score_value is not None else 0.5 
            elif isinstance(score_value, (int, float)):
                similarity_score = float(score_value)
            else:
                similarity_score = 0.5

            doc_data = {
                "source_type": source_type_prefix,
                "content": content_str,
                "score": similarity_score, 
                "metadata": {k: v for k, v in doc_metadata.items() if v is not None}
            }
            formatted_docs.append(doc_data)
        return formatted_docs

    async def retrieve(
        self, 
        user_query: str, 
        extracted_info: Optional[ExtractedEntitiesAndRelationIntent], # <--- 直接接收提取好的信息
        top_k: int = 3
    ) -> List[Dict[str, Any]]:
        kg_logger.info(f"Starting DuckDB KG retrieval for query: '{user_query}', top_k: {top_k}")

        cache_key = f"{user_query}_{top_k}"
        async with self._retrieval_cache_lock:
            cached_result = self._retrieval_cache.get(cache_key)
        
        if cached_result is not None:
            kg_logger.info(f"KG CACHE HIT for key: '{cache_key[:100]}...'")
            return cached_result
        
        kg_logger.info(f"KG CACHE MISS for key: '{cache_key[:100]}...'. Performing retrieval.")

        if not self._embedder:
            kg_logger.error("Embedder not configured for KGRetriever. Vector search will be skipped.")
        
        all_retrieved_records: List[Dict[str, Any]] = []
        processed_entity_ids = set()

        # 1. LLM提取步骤已被移除，直接使用传入的 extracted_info
        if extracted_info:
            entities_log = [e.model_dump() for e in extracted_info.entities]
            relations_log = [r.model_dump() for r in extracted_info.relations]
            kg_logger.info(f"Using pre-extracted KG info: Entities: {entities_log}, Relations: {relations_log}")
        else:
            kg_logger.info("No pre-extracted KG info provided.")

        # 2. 向量搜索
        if self._embedder:
            try:
                kg_logger.info(f"Generating embedding for vector search text: '{user_query}'")
                query_vector_list = await self._embedder.embed_query(user_query)
                if query_vector_list:
                    vector_search_sql = "SELECT id_prop, text, label, list_distance(embedding, ?) AS distance FROM ExtractedEntity ORDER BY distance ASC LIMIT ?;"
                    vector_results = self._execute_duckdb_sql_query_sync(vector_search_sql, [query_vector_list, top_k])
                    if vector_results:
                        for rec in vector_results: rec["_source_strategy"] = "vector_search"
                        all_retrieved_records.extend(vector_results)
                        processed_entity_ids.update(rec.get("id_prop") for rec in vector_results)
                        kg_logger.info(f"Retrieved {len(vector_results)} records via DuckDB vector search.")
                else:
                    kg_logger.warning("Failed to generate query embedding for vector search.")
            except Exception as e_vec_search:
                kg_logger.error(f"Error during DuckDB vector search: {e_vec_search}", exc_info=True)
        
        # 3. 基于LLM提取的实体进行精确查找
        if extracted_info and extracted_info.entities:
            for entity_info in extracted_info.entities:
                entity_text_norm = normalize_text_for_id(entity_info.text)
                entity_label_norm = entity_info.label.upper()
                exact_entity_sql = "SELECT id_prop, text, label FROM ExtractedEntity WHERE text = ? AND label = ? LIMIT 1;"
                entity_lookup_results = self._execute_duckdb_sql_query_sync(exact_entity_sql, [entity_text_norm, entity_label_norm])
                for rec in entity_lookup_results:
                    if rec.get("id_prop") not in processed_entity_ids:
                        rec["_source_strategy"] = "exact_entity_match"
                        all_retrieved_records.append(rec)
                        processed_entity_ids.add(rec.get("id_prop"))

        # 4. 基于LLM提取的结构化关系进行验证和邻居查找
        if extracted_info and extracted_info.relations:
            kg_logger.info(f"Found {len(extracted_info.relations)} structured relations to process.")
            for rel_item in extracted_info.relations:
                try:
                    head_text_norm = normalize_text_for_id(rel_item.head_entity_text)
                    head_label_norm = rel_item.head_entity_label.upper()
                    tail_text_norm = normalize_text_for_id(rel_item.tail_entity_text)
                    tail_label_norm = rel_item.tail_entity_label.upper()
                    relation_type_norm = rel_item.relation_type.upper()

                    kg_logger.info(f"Processing relation: ({head_text_norm}:{head_label_norm})-[{relation_type_norm}]->({tail_text_norm}:{tail_label_norm})")

                    relation_verification_sql = """
                    SELECT r.relation_type, s.id_prop AS source_id_prop, s.text AS source_text, s.label AS source_label, t.id_prop AS target_id_prop, t.text AS target_text, t.label AS target_label
                    FROM KGExtractionRelation r
                    JOIN ExtractedEntity s ON r.source_node_id_prop = s.id_prop
                    JOIN ExtractedEntity t ON r.target_node_id_prop = t.id_prop
                    WHERE s.text = ? AND s.label = ? AND t.text = ? AND t.label = ? AND r.relation_type = ? LIMIT 1;
                    """
                    relation_verification_params = [head_text_norm, head_label_norm, tail_text_norm, tail_label_norm, relation_type_norm]
                    
                    log_entry = {
                        "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
                        "task_type": "kg_executed_query_for_eval", "user_query_for_task": user_query,
                        "generated_query_language": "SQL_DuckDB", "generated_query": relation_verification_sql.strip(),
                        "query_parameters": [str(p) for p in relation_verification_params],
                        "application_version": "kg_retriever_0.2_rel_verify"
                    }
                    try:
                        asyncio.create_task(log_interaction_data(log_entry))
                    except Exception as e_log:
                        kg_logger.error(f"Error queuing precise log for relation verification query: {e_log}", exc_info=True)

                    relation_verification_results = self._execute_duckdb_sql_query_sync(relation_verification_sql, relation_verification_params)
                    
                    if relation_verification_results:
                        kg_logger.info(f"    Successfully verified relation in KG: {relation_type_norm} between '{head_text_norm}' and '{tail_text_norm}'")
                        
                        for verified_rel_record in relation_verification_results:
                            head_entity_from_rel = {"id_prop": verified_rel_record.get("source_id_prop"), "text": verified_rel_record.get("source_text"), "label": verified_rel_record.get("source_label"), "_source_strategy": f"verified_relation_head_{relation_type_norm}"}
                            if head_entity_from_rel.get("id_prop") not in processed_entity_ids:
                                all_retrieved_records.append(head_entity_from_rel)
                                processed_entity_ids.add(head_entity_from_rel.get("id_prop"))
                                kg_logger.info(f"      Added head entity '{head_entity_from_rel.get('text')}' from verified relation to results.")
                            tail_entity_from_rel = {"id_prop": verified_rel_record.get("target_id_prop"), "text": verified_rel_record.get("target_text"), "label": verified_rel_record.get("target_label"), "_source_strategy": f"verified_relation_tail_{relation_type_norm}"}
                            if tail_entity_from_rel.get("id_prop") not in processed_entity_ids:
                                all_retrieved_records.append(tail_entity_from_rel)
                                processed_entity_ids.add(tail_entity_from_rel.get("id_prop"))
                                kg_logger.info(f"      Added tail entity '{tail_entity_from_rel.get('text')}' from verified relation to results.")
                        
                        if head_text_norm and head_label_norm and relation_type_norm:
                            find_other_tails_sql = """
                            SELECT t.id_prop, t.text, t.label, r.relation_type
                            FROM ExtractedEntity h
                            JOIN KGExtractionRelation r ON h.id_prop = r.source_node_id_prop
                            JOIN ExtractedEntity t ON r.target_node_id_prop = t.id_prop
                            WHERE h.text = ? AND h.label = ? AND r.relation_type = ? AND t.text != ?
                            LIMIT ?;
                            """
                            find_other_tails_params = [head_text_norm, head_label_norm, relation_type_norm, tail_text_norm, top_k]
                            other_tails_results = self._execute_duckdb_sql_query_sync(find_other_tails_sql, find_other_tails_params)
                            for rec in other_tails_results:
                                if rec.get("id_prop") not in processed_entity_ids:
                                    rec["_source_strategy"] = f"neighbor_tail_for_{relation_type_norm}"
                                    all_retrieved_records.append(rec)
                                    processed_entity_ids.add(rec.get("id_prop"))
                                    kg_logger.info(f"        Added neighbor tail entity '{rec.get('text')}' to results.")

                        if tail_text_norm and tail_label_norm and relation_type_norm:
                            find_other_heads_sql = """
                            SELECT h.id_prop, h.text, h.label, r.relation_type
                            FROM ExtractedEntity t
                            JOIN KGExtractionRelation r ON t.id_prop = r.target_node_id_prop
                            JOIN ExtractedEntity h ON r.source_node_id_prop = h.id_prop
                            WHERE t.text = ? AND t.label = ? AND r.relation_type = ? AND h.text != ?
                            LIMIT ?;
                            """
                            find_other_heads_params = [tail_text_norm, tail_label_norm, relation_type_norm, head_text_norm, top_k]
                            other_heads_results = self._execute_duckdb_sql_query_sync(find_other_heads_sql, find_other_heads_params)
                            for rec in other_heads_results:
                                if rec.get("id_prop") not in processed_entity_ids:
                                    rec["_source_strategy"] = f"neighbor_head_for_{relation_type_norm}"
                                    all_retrieved_records.append(rec)
                                    processed_entity_ids.add(rec.get("id_prop"))
                                    kg_logger.info(f"        Added neighbor head entity '{rec.get('text')}' to results.")
                    else:
                        kg_logger.info(f"    Relation {relation_type_norm} between '{head_text_norm}' and '{tail_text_norm}' not found in KG via exact match.")

                except Exception as e_rel_proc:
                    kg_logger.error(f"Error processing structured relation item {rel_item.model_dump_json()}: {e_rel_proc}", exc_info=True)

        if not all_retrieved_records:
            kg_logger.info(f"No records retrieved from DuckDB KG for query: '{user_query}' after all strategies.")
            return []

        unique_records = []
        seen_ids = set()
        for record in all_retrieved_records:
            record_id = record.get("id_prop") or record.get("source_id_prop")
            if record_id and record_id in seen_ids:
                continue
            unique_records.append(record)
            if record_id:
                seen_ids.add(record_id)
        
        formatted_docs = self._format_duckdb_records_for_retrieval(unique_records, user_query, "duckdb_kg")
        
        async with self._retrieval_cache_lock:
            self._retrieval_cache[cache_key] = formatted_docs
        kg_logger.info(f"KG CACHED {len(formatted_docs)} results for key: '{cache_key[:100]}...'")

        kg_logger.info(f"KGRetriever (DuckDB) retrieve method finished. Returning {len(formatted_docs)} formatted documents for fusion.")
        return formatted_docs



    def close(self):
        kg_logger.info(f"KGRetriever (DuckDB).close() called. (No persistent DB object to close in this version as connections are per-method).")
        pass

```

        |-- __init__.py

``` py
# zhz_agent/core_rag/retrievers/__init__.py
from .chromadb_retriever import ChromaDBRetriever
from .file_bm25_retriever import FileBM25Retriever
```

        |-- chromadb_retriever.py

``` py
# 文件: zhz_rag/core_rag/retrievers/chromadb_retriever.py

import asyncio
import json
from typing import List, Dict, Any, Optional
import chromadb
import logging
from .embedding_functions import LlamaCppEmbeddingFunction
from cachetools import TTLCache # <--- 添加这一行

# 配置ChromaDBRetriever的日志记录器
logger = logging.getLogger(__name__)
# 注意：在模块级别配置basicConfig可能会影响整个应用的日志行为。
# 通常建议在应用入口处统一配置。
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class ChromaDBRetriever:
    def __init__(
        self,
        collection_name: str,
        persist_directory: str,
        embedding_function: LlamaCppEmbeddingFunction
    ):
        """
        初始化ChromaDBRetriever。

        Args:
            collection_name (str): 要查询的ChromaDB集合名称。
            persist_directory (str): ChromaDB数据持久化的目录。
            embedding_function (LlamaCppEmbeddingFunction): 用于生成嵌入的函数实例。
        """
        self.collection_name = collection_name
        self.persist_directory = persist_directory
        self._embedding_function = embedding_function
        self._client: Optional[chromadb.Client] = None
        self._collection: Optional[chromadb.Collection] = None
        self._dimension: Optional[int] = None

    # --- 新增: 初始化TTLCache召回结果缓存和异步锁 ---
        # maxsize=100: 最多缓存100个查询结果
        # ttl=300: 缓存条目存活300秒（5分钟）
        self._retrieval_cache: TTLCache = TTLCache(maxsize=100, ttl=300)
        self._retrieval_cache_lock = asyncio.Lock()

        # 初始化依然是同步的，在服务启动时执行
        self._initialize_retriever()

    def _initialize_retriever(self):
        """
        初始化ChromaDB客户端和集合。
        """
        try:
            logger.info(f"Initializing ChromaDB client from path: {self.persist_directory}")
            self._client = chromadb.PersistentClient(path=self.persist_directory)
            
            logger.info(f"Getting or creating ChromaDB collection: {self.collection_name} using provided async embedding function.")
            self._collection = self._client.get_or_create_collection(
                name=self.collection_name,
                embedding_function=self._embedding_function 
            )

            if self._collection.count() == 0:
                logger.warning(f"ChromaDB collection '{self.collection_name}' is empty!")
            else:
                logger.info(f"ChromaDB collection '{self.collection_name}' loaded. Item count: {self._collection.count()}")
        except Exception as e:
            logger.error(f"Failed to initialize ChromaDB client or collection: {e}", exc_info=True)
            raise

    async def retrieve(
        self, 
        query_text: str, 
        n_results: int = 5, 
        include_fields: Optional[List[str]] = None,
        where_filter: Optional[Dict[str, Any]] = None  # <--- 新增参数
    ) -> List[Dict[str, Any]]:
        if self._collection is None or self._embedding_function is None:
            logger.error("Retriever is not properly initialized.")
            return []

        # --- 更新缓存键以包含过滤器 ---
        cache_key_parts = [query_text, str(n_results)]
        if where_filter:
            # 将过滤器字典转换为稳定的字符串表示
            filter_str = json.dumps(where_filter, sort_keys=True)
            cache_key_parts.append(filter_str)
        cache_key = "_".join(cache_key_parts)
        
        async with self._retrieval_cache_lock:
            cached_result = self._retrieval_cache.get(cache_key)
        
        if cached_result is not None:
            logger.info(f"ChromaDB CACHE HIT for key with filter: '{cache_key[:100]}...'")
            return cached_result
        
        logger.info(f"ChromaDB CACHE MISS for key: '{cache_key[:100]}...'. Performing retrieval.")
        if where_filter:
            logger.info(f"Applying metadata filter: {where_filter}")

        logger.info(f"Retrieving documents for query: '{query_text[:100]}...' with n_results={n_results}")
        
        try:
            query_embedding = await self._embedding_function.embed_query(query_text)
            
            if not query_embedding: 
                logger.error(f"Failed to generate embedding for query: {query_text[:100]}")
                return []
            
            # +++ 新增日志 +++
            logger.info(f"ChromaDBRetriever: Query embedding for '{query_text[:50]}' (first 10 elements): {str(query_embedding[:10])}")
            logger.info(f"ChromaDBRetriever: Length of query embedding: {len(query_embedding)}")
            is_query_emb_all_zeros = all(v == 0.0 for v in query_embedding)
            logger.info(f"ChromaDBRetriever: Is query embedding all zeros: {is_query_emb_all_zeros}")
            # +++ 结束新增日志 +++

            def _blocking_query():
                include_fields_query = include_fields if include_fields is not None else ["metadatas", "documents", "distances"]
                # --- 核心修改：在查询时应用 where_filter ---
                return self._collection.query(
                    query_embeddings=[query_embedding], 
                    n_results=n_results,
                    include=include_fields_query,
                    where=where_filter  # <--- 应用过滤器
                )

            results = await asyncio.to_thread(_blocking_query)
            
            retrieved_docs = []
            if results and results.get("ids") and results.get("ids")[0]:
                ids_list = results["ids"][0]
                documents_list = results.get("documents", [[]])[0]
                metadatas_list = results.get("metadatas", [[]])[0] 
                distances_list = results.get("distances", [[]])[0]

                for i in range(len(ids_list)):
                    chunk_id = ids_list[i]
                    metadata = metadatas_list[i] if metadatas_list and i < len(metadatas_list) else {}
                    distance = distances_list[i] if distances_list and i < len(distances_list) else float('inf')
                    content = documents_list[i] if documents_list and i < len(documents_list) else metadata.get("chunk_text", "[Content not found]")
                    score = (1 - distance / 2.0) if distance != float('inf') and distance <= 2.0 else 0.0 

                    retrieved_docs.append({
                        "id": chunk_id,
                        "content": content,
                        "score": score,
                        "distance": distance, 
                        "metadata": metadata,
                        "source_type": "vector_chromadb"
                    })
                
                logger.info(f"Retrieved {len(retrieved_docs)} documents from ChromaDB (with filter: {where_filter is not None}).")
            else:
                logger.info("No documents retrieved from ChromaDB for the query.")

            async with self._retrieval_cache_lock:
                self._retrieval_cache[cache_key] = retrieved_docs
            logger.info(f"ChromaDB CACHED {len(retrieved_docs)} results for key: '{cache_key[:100]}...'")
            return retrieved_docs

        except Exception as e:
            logger.error(f"Error during ChromaDB retrieval: {e}", exc_info=True)
            return []
        
        
    async def get_texts_by_ids(self, ids: List[str]) -> Dict[str, str]:
        """
        (异步) 根据提供的ID列表从ChromaDB集合中获取文档的文本内容。
        """
        if not self._collection:
            logger.error("ChromaDBRetriever: Collection is not initialized.")
            return {id_val: "[Error: Collection not initialized]" for id_val in ids}
        
        if not ids:
            return {}
            
        logger.info(f"ChromaDBRetriever: Getting texts for {len(ids)} IDs.")
        
        def _blocking_get():
            return self._collection.get(ids=ids, include=["documents"])

        try:
            results = await asyncio.to_thread(_blocking_get)
            retrieved_ids = results.get("ids", [])
            retrieved_docs = results.get("documents", [])
            
            texts_map = {doc_id: doc_text for doc_id, doc_text in zip(retrieved_ids, retrieved_docs)}

            for doc_id in ids:
                if doc_id not in texts_map:
                    texts_map[doc_id] = f"[Content for chunk_id {doc_id} not found in ChromaDB]"
                    logger.warning(f"ChromaDBRetriever: Content for ID '{doc_id}' not found in get() result.")

            logger.info(f"ChromaDBRetriever: Returning texts_map with {len(texts_map)} entries.")
            return texts_map

        except Exception as e:
            logger.error(f"ChromaDBRetriever: Error during get_texts_by_ids: {e}", exc_info=True)
            return {id_val: f"[Error retrieving content for ID {id_val}]" for id_val in ids}

```

        |-- embedding_functions.py

``` py
# 文件: zhz_rag/core_rag/retrievers/embedding_functions.py

import logging
from typing import List, Dict, TYPE_CHECKING, Optional, Sequence
import numpy as np
from chromadb import Documents, Embeddings
import asyncio # 确保 asyncio 已导入
from cachetools import TTLCache

if TYPE_CHECKING:
    from zhz_rag.llm.local_model_handler import LocalModelHandler

logger = logging.getLogger(__name__)

def l2_normalize_embeddings(embeddings: List[List[float]]) -> List[List[float]]:
    """对一批嵌入向量进行L2归一化。"""
    if not embeddings or not isinstance(embeddings, list):
        return []
    
    normalized_embeddings = []
    for emb_list in embeddings:
        if not emb_list or not isinstance(emb_list, list): 
            normalized_embeddings.append([])
            continue
        try:
            emb_array = np.array(emb_list, dtype=np.float32)
            norm = np.linalg.norm(emb_array)
            if norm == 0: 
                normalized_embeddings.append(emb_list) 
            else:
                normalized_embeddings.append((emb_array / norm).tolist())
        except Exception as e_norm:
            logger.error(f"Error during L2 normalization of an embedding: {e_norm}", exc_info=True)
            normalized_embeddings.append(emb_list) 
    return normalized_embeddings



class LlamaCppEmbeddingFunction:
    """
    一个与 LangChain 兼容的 ChromaDB 嵌入函数。
    V3: 恢复为原生异步，以解决同步/异步桥接导致的死锁问题。
    """
    def __init__(self, model_handler: 'LocalModelHandler'):
        if model_handler is None:
            raise ValueError("LocalModelHandler is required.")
        self.model_handler = model_handler
        self._dimension: Optional[int] = None
        self._query_cache: TTLCache = TTLCache(maxsize=200, ttl=3600)
        self._cache_lock = asyncio.Lock()
        
        try:
            self._dimension = self.model_handler.get_embedding_dimension()
            if self._dimension:
                 logger.info(f"LlamaCppEmbeddingFunction initialized. Dimension from handler: {self._dimension}")
        except Exception as e_dim_init:
            logger.warning(f"LlamaCppEmbeddingFunction: Error trying to get dimension during init: {e_dim_init}.")

    # --- 核心修改：恢复为 async def ---
    async def __call__(self, input: Documents) -> Embeddings:
        if not input:
            return []
        logger.info(f"LlamaCppEmbeddingFunction (ASYNC __call__): Generating embeddings for {len(input)} documents.")
        # 直接 await 异步方法
        return await self.model_handler.embed_documents(list(input))

    async def embed_documents(self, texts: List[str]) -> List[List[float]]:
        return await self.__call__(texts)

    async def embed_query(self, text: str) -> List[float]:
        async with self._cache_lock:
            cached_result = self._query_cache.get(text)
        
        if cached_result is not None:
            logger.info(f"Query Vector CACHE HIT for query: '{text[:50]}...'")
            return cached_result
        
        logger.info(f"Query Vector CACHE MISS for query: '{text[:50]}...'. Generating new embedding.")
        embedding_vector = await self.model_handler.embed_query(text)
        
        if embedding_vector:
            async with self._cache_lock:
                self._query_cache[text] = embedding_vector
        else:
            embedding_vector = [0.0] * (self._dimension or 1024)

        return embedding_vector
```

        |-- file_bm25_retriever.py

``` py
# 文件: zhz_rag/core_rag/retrievers/file_bm25_retriever.py

from typing import List, Dict, Any, Optional
import jieba
import bm25s
import pickle
import os
import logging
import numpy as np
import traceback
import asyncio
from cachetools import TTLCache # <--- 添加这一行

# 配置日志记录器
logger = logging.getLogger(__name__)

class FileBM25Retriever:
    def __init__(
        self,
        index_directory: str,
    ):
        """
        初始化 FileBM25Retriever。

        Args:
            index_directory (str): 存储 BM25 索引文件的目录路径。
        """
        self.index_directory_path = index_directory

        self._bm25_model: Optional[bm25s.BM25] = None
        self._doc_ids: Optional[List[str]] = None
        # --- 使用 TTLCache 初始化缓存 ---
        self._retrieval_cache: TTLCache = TTLCache(maxsize=100, ttl=300)
        self._initialize_retriever()

    def _initialize_retriever(self):
        """
        加载 BM25 模型和文档ID。
        """
        if not os.path.isdir(self.index_directory_path):
            logger.error(f"BM25 index directory not found at: {self.index_directory_path}")
            raise FileNotFoundError(f"BM25 index directory not found: {self.index_directory_path}")

        try:
            logger.info(f"Loading BM25 model from directory: {self.index_directory_path}")
            self._bm25_model = bm25s.BM25.load(
                self.index_directory_path,
                load_corpus=False,
            )
            
            if self._bm25_model is None:
                logger.error("Failed to load BM25 model (returned None).")
                raise ValueError("Failed to load BM25 model.")
            logger.info("BM25 model loaded successfully.")

            doc_ids_path = os.path.join(self.index_directory_path, "doc_ids.pkl")
            if not os.path.exists(doc_ids_path):
                logger.error(f"doc_ids.pkl not found in {self.index_directory_path}")
                raise FileNotFoundError(f"doc_ids.pkl not found in {self.index_directory_path}")
            
            with open(doc_ids_path, 'rb') as f_in:
                self._doc_ids = pickle.load(f_in)
            
            if self._doc_ids is None:
                logger.warning(f"doc_ids.pkl loaded, but it was empty or invalid.")
                self._doc_ids = []
            logger.info(f"Document IDs loaded successfully. Number of indexed documents: {len(self._doc_ids)}")

        except Exception as e:
            logger.error(f"Failed to load BM25 index or document IDs: {e}", exc_info=True)
            raise

    def retrieve(self, query_text: str, n_results: int = 5) -> List[Dict[str, Any]]:
        """
        根据查询文本使用BM25检索相关的文档块ID和分数。

        Args:
            query_text (str): 用户查询的文本。
            n_results (int): 希望返回的最大结果数量。

        Returns:
            List[Dict[str, Any]]: 检索到的文档块列表。每个字典包含：
                                'id' (chunk_id),
                                'score' (BM25分数),
                                'source_type' (固定为 "keyword_bm25")
        """
        if self._bm25_model is None or self._doc_ids is None:
            logger.error("BM25 Retriever is not properly initialized.")
            return []

        # --- 更新: 使用 TTLCache 进行缓存检查 ---
        cache_key = f"{query_text}_{n_results}"
        # BM25是同步的，所以我们不需要异步锁，可以直接访问缓存
        cached_result = self._retrieval_cache.get(cache_key)
        if cached_result is not None:
            logger.info(f"BM25 CACHE HIT for key: '{cache_key[:100]}...'")
            return cached_result
        logger.info(f"BM25 CACHE MISS for key: '{cache_key[:100]}...'. Performing retrieval.")
        # --- 缓存检查结束 ---

        if not self._doc_ids:
            logger.info("BM25 index is empty, no results to retrieve.")
            return []

        logger.info(f"Retrieving documents with BM25 for query: '{query_text[:100]}...' with n_results={n_results}")

        try:
            query_tokenized = list(jieba.cut_for_search(query_text))
            logger.debug(f"Tokenized query (jieba for BM25): {query_tokenized}")

            # 调用 bm25s 模型获取分数
            all_scores = self._bm25_model.get_scores(query_tokenized)
            
            actual_n_results = min(n_results, len(self._doc_ids))
            if actual_n_results <= 0:
                return []
            
            # 获取分数最高的n个结果的索引
            top_n_indices = np.argsort(all_scores)[-actual_n_results:][::-1]

            retrieved_docs = []
            for index in top_n_indices:
                if 0 <= index < len(self._doc_ids):
                    doc_id = self._doc_ids[index]
                    score = float(all_scores[index])
                    retrieved_docs.append({
                        "id": doc_id,
                        "score": score,
                        "source_type": "keyword_bm25"
                    })
                else:
                    logger.warning(f"BM25 retrieval: Index {index} out of bounds for doc_ids list (len: {len(self._doc_ids)}). Skipping.")

            # --- 更新: 存储到 TTLCache ---
            self._retrieval_cache[cache_key] = retrieved_docs
            logger.info(f"BM25 CACHED {len(retrieved_docs)} results for key: '{cache_key[:100]}...'")
            # --- 缓存存储结束 ---
            
            logger.info(f"Retrieved {len(retrieved_docs)} documents using BM25.")
            return retrieved_docs

        except Exception as e:
            logger.error(f"Error during BM25 retrieval: {e}", exc_info=True)
            return []
        


```

    |-- rag_eval_data/
    |-- __init__.py

``` py
# /home/zhz/zhz_agent/zhz_rag/llm/__init__.py

from .llm_interface import call_llm_via_openai_api_local_only # 导入新函数

call_sglang_llm = call_llm_via_openai_api_local_only # 别名指向新函数

from .llm_interface import (
    generate_answer_from_context,
    # generate_cypher_query, # 已停用
    generate_expanded_queries,
    generate_intent_classification, # 这个现在直接用 litellm 调用 Gemini
    generate_clarification_question,
    generate_clarification_options,
    NO_ANSWER_PHRASE_ANSWER_CLEAN,
    # NO_ANSWER_PHRASE_KG_CLEAN # 已停用
)
```

    |-- custom_crewai_llms.py

``` py
#/home/zhz/zhz_agent/custom_llm.py
import os
import json
import httpx
import asyncio
import traceback
from typing import List, Dict, Any, Optional, Union, Sequence, Type 
# --- CrewAI & LiteLLM Imports ---
from crewai.tools import BaseTool
from crewai.llms.base_llm import BaseLLM as CrewAIBaseLLM
import litellm

# --- [修改] Local Imports -> 改为绝对导入 ---
from zhz_rag.llm.llm_interface import call_sglang_llm # For SGLang LLM
from dotenv import load_dotenv

load_dotenv()

# --- SGLang Config ---
SGLANG_API_URL_FOR_LLM = os.getenv("SGLANG_API_URL", "http://localhost:30000/generate")

# --- CustomGeminiLLM (from ceshi/run_agent.py with fixes) ---
class CustomGeminiLLM(CrewAIBaseLLM):
    model_name: str
    api_key: str
    max_tokens: Optional[int] = 2048
    tool_config: Optional[Dict[str, Any]] = None
    stop: Optional[List[str]] = None
    _gemini_tools_cache: Optional[List[Dict[str, Any]]] = None

    def __init__(self, model: str, api_key: str, temperature: float = 0.1, max_tokens: Optional[int] = 2048, tool_config: Optional[Dict[str, Any]] = None, stop: Optional[List[str]] = None, agent_tools: Optional[List[BaseTool]] = None, **kwargs):
        super().__init__(model=model, temperature=temperature)
        self.model_name = model
        self.api_key = api_key
        self.max_tokens = max_tokens
        self.tool_config = tool_config or {"function_calling_config": {"mode": "AUTO"}}
        self.stop = stop
        if agent_tools:
            self._gemini_tools_cache = self._convert_crewai_tools_to_gemini_format(agent_tools)
            print(f"CustomGeminiLLM __init__: Cached {len(self._gemini_tools_cache)} tools.")
        else:
            print("CustomGeminiLLM __init__: No agent_tools provided for caching.")

    def _remove_unwanted_fields(self, schema: Dict[str, Any]) -> Dict[str, Any]:
        if not isinstance(schema, dict):
            return schema

        schema.pop('title', None)

        if "properties" in schema:
            if "type" not in schema:
                schema["type"] = "object"
            for prop_name, prop_def in list(schema["properties"].items()):
                if isinstance(prop_def, dict):
                    prop_def.pop('default', None)
                    prop_def.pop('title', None)
                    self._remove_unwanted_fields(prop_def)
        elif schema.get("type") == "object" and "properties" not in schema:
            schema["properties"] = {}

        keys_to_delete = [k for k, v in schema.items() if k == 'default']
        for k in keys_to_delete:
            del schema[k]

        for k, v in schema.items():
            if isinstance(v, dict):
                self._remove_unwanted_fields(v)
            elif isinstance(v, list):
                for i, item in enumerate(v):
                    if isinstance(item, dict):
                        v[i] = self._remove_unwanted_fields(item)
        return schema

    def _convert_crewai_tools_to_gemini_format(self, tools: Optional[List[BaseTool]]) -> Optional[List[Dict[str, Any]]]:
        if not tools:
            return None
        gemini_tool_declarations = []
        for tool_instance in tools:
            tool_name = tool_instance.name
            tool_description = tool_instance.description
            if not hasattr(tool_instance, 'args_schema') or not tool_instance.args_schema:
                parameters_schema = {"type": "object", "properties": {}}
            else:
                try:
                    if hasattr(tool_instance.args_schema, 'model_json_schema'):
                        pydantic_schema = tool_instance.args_schema.model_json_schema()
                    else:
                        pydantic_schema = tool_instance.args_schema.schema()
                    cleaned_schema = self._remove_unwanted_fields(pydantic_schema.copy())
                    parameters_schema = cleaned_schema
                except Exception as e:
                    print(f"Error processing schema for tool {tool_name}: {e}")
                    parameters_schema = {"type": "object", "properties": {}}
            gemini_tool_declarations.append({
                "name": tool_name,
                "description": tool_description,
                "parameters": parameters_schema
            })
        final_tools_for_litellm = []
        for declaration in gemini_tool_declarations:
            final_tools_for_litellm.append({
                "type": "function",
                "function": declaration
            })
        return final_tools_for_litellm

    def call(self, messages: Union[str, List[Dict[str, str]]], tools: Optional[List[dict]] = None, callbacks: Optional[List[Any]] = None, **kwargs: Any) -> Union[str, Any]:
        print(f"CustomGeminiLLM CALL method invoked.")
        print(f"  CALL - Tools received by CustomLLM.call: {'Yes' if tools else 'No'}")
        print(f"  CALL - Callbacks received by CustomLLM.call: {'Yes' if callbacks else 'No'}")

        if isinstance(messages, str):
            processed_messages = [{"role": "user", "content": messages}]
        else:
            processed_messages = messages

        litellm_params = {
            "model": self.model_name,
            "messages": processed_messages,
            "api_key": self.api_key,
            "temperature": self.temperature,
            "max_tokens": self.max_tokens,
            "stop": self.stop
        }

        # --- Proxy Addition ---
        proxy_url = os.getenv("LITELLM_PROXY_URL")
        if proxy_url:
            litellm_params["proxy"] = {
                "http": proxy_url,
                "https": proxy_url,
            }
            print(f"CustomGeminiLLM.call - Using proxy: {proxy_url}")
        else:
            print("CustomGeminiLLM.call - No proxy configured (LITELLM_PROXY_URL not set).")

        # --- Tool Handling (tools: null fix) ---
        final_tools_for_litellm = None
        received_tools_to_process = tools
        if not received_tools_to_process and self._gemini_tools_cache:
            print("  CALL - INFO: Tools argument was None, using cached tools.")
            received_tools_to_process = self._gemini_tools_cache

        if received_tools_to_process:
            cleaned_tools_for_litellm = []
            for tool_dict in received_tools_to_process:
                current_tool_def = tool_dict.copy()
                if current_tool_def.get("type") == "function" and "function" in current_tool_def:
                    func_def = current_tool_def["function"].copy()
                    if "parameters" in func_def:
                        func_def["parameters"] = self._remove_unwanted_fields(func_def["parameters"].copy())
                    current_tool_def["function"] = func_def
                    cleaned_tools_for_litellm.append(current_tool_def)
                else:
                    cleaned_tools_for_litellm.append(tool_dict)
            final_tools_for_litellm = cleaned_tools_for_litellm

        if final_tools_for_litellm:
            litellm_params["tools"] = final_tools_for_litellm
            fc_config = self.tool_config.get("function_calling_config", {})
            mode = fc_config.get("mode", "AUTO").upper()
            allowed_names = fc_config.get("allowed_function_names")

            if mode == "ANY" and allowed_names:
                litellm_params["tool_choice"] = {
                    "type": "function",
                    "function": {"name": allowed_names[0]}
                }
            elif mode in ["AUTO", "ANY", "NONE"]:
                litellm_params["tool_choice"] = mode.lower()
            else:
                litellm_params["tool_choice"] = "auto"
            print(f"CustomGeminiLLM DEBUG: Setting tool_choice to: {litellm_params['tool_choice']}")

        if callbacks:
            litellm_params["callbacks"] = callbacks

        try:
            print(f"CustomGeminiLLM.call - LiteLLM PARAMS (Preview): model={litellm_params['model']}, msgs_count={len(litellm_params['messages'])}, tools={'Yes' if 'tools' in litellm_params else 'No'}, tool_choice={litellm_params.get('tool_choice')}, proxy={'Yes' if 'proxy' in litellm_params else 'No'}")
            response = litellm.completion(**litellm_params)
        except Exception as e:
            print(f"CRITICAL ERROR: LiteLLM completion call failed: {e}")
            if callbacks:
                for handler in callbacks:
                    if hasattr(handler, 'on_llm_error'):
                        try:
                            handler.on_llm_error(error=e, llm=self, **kwargs)
                        except Exception as cb_err:
                            print(f"Error in callback on_llm_error: {cb_err}")
            raise

        llm_message_response = response.choices[0].message
        if hasattr(llm_message_response, 'tool_calls') and llm_message_response.tool_calls:
            print(f"CustomGeminiLLM.call - Detected tool_calls: {llm_message_response.tool_calls}")
            # --- ReAct Format Workaround (AttributeError fix) ---
            tool_call = llm_message_response.tool_calls[0]
            action = tool_call.function.name
            action_input = tool_call.function.arguments
            react_string = f"Action: {action}\nAction Input: {action_input}"
            print(f"CustomGeminiLLM.call - Returning ReAct string: {react_string}")
            return react_string
        else:
            print(f"CustomGeminiLLM.call - Returning text content.")
            return llm_message_response.content or ""

    def get_token_counter_instance(self):
        class GeminiTokenCounter:
            def __init__(self, model_name):
                self.model_name = model_name

            def count_tokens(self, text: Union[str, List[Dict[str,str]]]) -> int:
                try:
                    if isinstance(text, list):
                        return litellm.token_counter(model=self.model_name, messages=text)
                    return litellm.token_counter(model=self.model_name, text=str(text))
                except Exception as e:
                    print(f"Warning: Token counting failed ({e}), falling back to rough estimate.")
                    if isinstance(text, list):
                        return sum(len(str(m.get("content","")).split()) for m in text)
                    return len(str(text).split())
        return GeminiTokenCounter(model_name=self.model_name)


# --- CustomSGLangLLM (from hybrid_rag/custom_llm.py) ---
class CustomSGLangLLM(CrewAIBaseLLM):
    endpoint_url: str = SGLANG_API_URL_FOR_LLM
    model_name: str = "qwen2-3b-instruct"
    temperature: float = 0.1
    max_new_tokens_val: int = 1024

    def __init__(self, endpoint: Optional[str] = None, model: Optional[str] = None, temperature: Optional[float] = None, max_new_tokens: Optional[int] = None, **kwargs: Any):
        super().__init__(**kwargs)
        if endpoint: self.endpoint_url = endpoint
        if model: self.model_name = model
        if temperature is not None: self.temperature = temperature
        if max_new_tokens is not None: self.max_new_tokens_val = max_new_tokens
        print(f"CustomSGLangLLM initialized. Endpoint: {self.endpoint_url}, Model: {self.model_name}, Temp: {self.temperature}, MaxTokens: {self.max_new_tokens_val}")

    def _prepare_sglang_prompt(self, messages: Sequence[Dict[str, str]]) -> str:
        prompt_str = ""
        for message in messages:
            role = message.get("role")
            content = message.get("content")
            if role and content:
                prompt_str += f"<|im_start|>{role}\n{content}<|im_end|>\n"
        prompt_str += "<|im_start|>assistant\n"
        return prompt_str

    def call(self, messages: Sequence[Dict[str, str]], **kwargs: Any) -> str:
        print(f"CustomSGLangLLM.call received messages: {messages}")
        sglang_prompt = self._prepare_sglang_prompt(messages)
        print(f"CustomSGLangLLM.call prepared sglang_prompt (first 200 chars): {sglang_prompt[:200]}...")
        stop_sequences_for_sglang = kwargs.get("stop", ["<|im_end|>", "<|endoftext|>"])

        try:
            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                loop = None

            async def async_runner():
                return await call_sglang_llm(
                    prompt=sglang_prompt,
                    temperature=self.temperature,
                    max_new_tokens=self.max_new_tokens_val,
                    stop_sequences=stop_sequences_for_sglang
                )

            if loop and loop.is_running():
                import concurrent.futures
                with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
                    future = executor.submit(asyncio.run, async_runner())
                    response_text = future.result(timeout=120)
            else:
                response_text = asyncio.run(async_runner())

        except Exception as e:
            print(f"CustomSGLangLLM.call: Error during SGLang call: {type(e).__name__} - {e}")
            traceback.print_exc()
            return f"LLM_CALL_ERROR: 调用SGLang服务失败 - {str(e)}"

        if response_text is None:
            print("CustomSGLangLLM.call: SGLang returned None.")
            return "LLM_CALL_ERROR: SGLang服务未返回任何文本。"

        print(f"CustomSGLangLLM.call: SGLang returned text (first 200 chars): {response_text[:200]}...")
        return response_text

    def get_token_ids(self, text: str) -> List[int]:
        print("CustomSGLangLLM.get_token_ids: Not implemented, returning empty list.")
        return []

    @property
    def support_function_calling(self) -> bool:
        return False

    @property
    def support_stop_words(self) -> bool:
        return True

    @property
    def available_models(self) -> List[str]:
        return [self.model_name]

    @property
    def context_window(self) -> int:
        return 32768

    @property
    def identifying_params(self) -> Dict[str, Any]:
        return {
            "model": self.model_name,
            "endpoint_url": self.endpoint_url,
            "temperature": self.temperature,
            "max_new_tokens": self.max_new_tokens_val,
        }
```

    |-- embedding_process_worker.py

``` py
# 文件: zhz_rag/llm/embedding_process_worker.py

import os
import logging
from typing import List, Dict, Any, Optional
from llama_cpp import Llama
import numpy as np

# --- 全局变量，用于在子进程中缓存模型实例 ---
# 注意: 每个进程池中的工作进程会有自己的这个变量副本
_process_local_model_cache: Dict[str, Llama] = {}
_process_local_model_dimension_cache: Dict[str, int] = {}

# --- 日志配置 (与 LocalModelHandler 类似，但确保独立) ---
worker_logger = logging.getLogger("EmbeddingProcessWorker")
# 避免重复添加处理器，如果此模块被多次导入或以某种方式重新加载
if not worker_logger.hasHandlers():
    worker_logger.setLevel(logging.INFO) # 或者 DEBUG
    # 注意：在多进程环境中，日志输出到控制台可能交错。
    # 对于生产环境，可能需要更复杂的日志策略（如QueueHandler）。
    # 但对于调试，StreamHandler 也可以。
    stream_handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - PID:%(process)d - %(levelname)s - %(message)s')
    stream_handler.setFormatter(formatter)
    worker_logger.addHandler(stream_handler)
    worker_logger.propagate = False


def l2_normalize_embeddings_worker(embeddings: List[List[float]]) -> List[List[float]]:
    if not embeddings or not isinstance(embeddings, list):
        return []
    normalized_embeddings = []
    for emb_list in embeddings:
        if not emb_list or not isinstance(emb_list, list) or not all(isinstance(x, (float, int)) for x in emb_list):
            worker_logger.warning(f"L2_NORM_WORKER: Skipping invalid or empty inner list: {emb_list}")
            normalized_embeddings.append([])
            continue
        try:
            emb_array = np.array(emb_list, dtype=np.float32)
            norm = np.linalg.norm(emb_array)
            if norm == 0:
                normalized_embeddings.append(emb_list)
            else:
                normalized_embeddings.append((emb_array / norm).tolist())
        except Exception as e_norm:
            worker_logger.error(f"Error during L2 normalization in EmbeddingProcessWorker: {e_norm}", exc_info=True)
            normalized_embeddings.append(emb_list)
    return normalized_embeddings


def _get_embedding_model_instance_in_worker(
    model_path: str,
    n_ctx: int,
    n_gpu_layers: int,
    pooling_type: int
) -> Optional[Llama]:
    """
    在当前工作进程中获取或创建并缓存 Llama 嵌入模型实例。
    使用 model_path 作为缓存键。
    """
    global _process_local_model_cache
    global _process_local_model_dimension_cache

    if model_path in _process_local_model_cache:
        worker_logger.info(f"WORKER: Reusing cached embedding model for path: {model_path}")
        return _process_local_model_cache[model_path]

    worker_logger.info(f"WORKER: Attempting to load embedding model in process: {model_path}")
    try:
        model = Llama(
            model_path=model_path,
            n_ctx=n_ctx,
            n_gpu_layers=n_gpu_layers,
            embedding=True,
            pooling_type=pooling_type,
            verbose=False # 在工作进程中减少冗余日志
        )
        dimension = model.n_embd()
        if not dimension or dimension <= 0:
            worker_logger.error(f"WORKER: Loaded model from {model_path} but got invalid dimension {dimension}.")
            return None
        
        _process_local_model_cache[model_path] = model
        _process_local_model_dimension_cache[model_path] = dimension
        worker_logger.info(f"WORKER: Embedding model loaded and cached for {model_path}. Dimension: {dimension}, Pooling: {pooling_type}")
        return model
    except Exception as e:
        worker_logger.error(f"WORKER: Failed to load embedding model in process for path {model_path}: {e}", exc_info=True)
        return None


def embed_texts_in_subprocess(
    texts: List[str],
    embedding_model_path: str,
    n_ctx_embed: int,
    n_gpu_layers_embed: int,
    pooling_type_embed: int
) -> List[List[float]]:
    """
    在子进程中执行批量文本嵌入。
    """
    worker_logger.info(f"WORKER: embed_texts_in_subprocess received {len(texts)} texts.")
    model = _get_embedding_model_instance_in_worker(
        embedding_model_path, n_ctx_embed, n_gpu_layers_embed, pooling_type_embed
    )
    if not model:
        worker_logger.error("WORKER: Failed to get model instance in subprocess. Returning empty embeddings.")
        return [[] for _ in texts]
    
    dimension = _process_local_model_dimension_cache.get(embedding_model_path)
    if not dimension: # 应该不会发生，因为 _get_embedding_model_instance_in_worker 会设置它
        worker_logger.error("WORKER: Model dimension not found in cache after model load. Critical error.")
        return [[] for _ in texts]

    default_zero_vector = [0.0] * dimension
    
    # 与 LocalModelHandler._blocking_embed_documents_internal 类似的处理逻辑
    valid_texts_with_indices: List[tuple[int, str]] = []
    for i, text in enumerate(texts):
        if text and text.strip():
            valid_texts_with_indices.append((i, text))
        else:
            worker_logger.warning(f"WORKER: Input text at original index {i} is empty or invalid. Will use zero vector. Text: '{text}'")

    if not valid_texts_with_indices:
        return [list(default_zero_vector) for _ in texts]

    valid_texts_to_embed = [text for _, text in valid_texts_with_indices]
    raw_embeddings_for_valid_texts: List[List[float]] = []

    try:
        response = model.create_embedding(input=valid_texts_to_embed)
        # ... (此处省略与 LocalModelHandler._blocking_embed_documents_internal 中类似的详细的响应解析和错误处理逻辑)
        # 为了简洁，我们先做一个简化版的解析，假设一切顺利
        # 在实际应用中，需要复制 LocalModelHandler 中对 response 的完整健壮性检查

        if response and "data" in response and isinstance(response["data"], list):
            embeddings_data = response["data"]
            if len(embeddings_data) == len(valid_texts_to_embed):
                for item_idx, item in enumerate(embeddings_data):
                    if isinstance(item, dict) and "embedding" in item and \
                       isinstance(item["embedding"], list) and len(item["embedding"]) == dimension:
                        raw_embeddings_for_valid_texts.append([float(x) for x in item["embedding"]])
                    else:
                        worker_logger.warning(f"WORKER: Valid text at valid_idx {item_idx} got invalid embedding. Using zero vector.")
                        raw_embeddings_for_valid_texts.append(list(default_zero_vector))
            else:
                worker_logger.error(f"WORKER: Mismatch in num embeddings received. Using zero vectors.")
                raw_embeddings_for_valid_texts = [list(default_zero_vector) for _ in valid_texts_to_embed]
        else:
            worker_logger.error(f"WORKER: Invalid response from create_embedding. Using zero vectors.")
            raw_embeddings_for_valid_texts = [list(default_zero_vector) for _ in valid_texts_to_embed]
            
    except Exception as e_batch_embed:
        worker_logger.error(f"WORKER: Error during batch embedding: {e_batch_embed}", exc_info=True)
        raw_embeddings_for_valid_texts = [list(default_zero_vector) for _ in valid_texts_to_embed]

    final_embeddings_ordered: List[List[float]] = [list(default_zero_vector) for _ in texts]
    valid_embedding_idx = 0
    for original_idx, _ in valid_texts_with_indices:
        if valid_embedding_idx < len(raw_embeddings_for_valid_texts):
            final_embeddings_ordered[original_idx] = raw_embeddings_for_valid_texts[valid_embedding_idx]
            valid_embedding_idx += 1
        else:
            final_embeddings_ordered[original_idx] = list(default_zero_vector)
            
    normalized_embeddings = l2_normalize_embeddings_worker(final_embeddings_ordered)
    worker_logger.info(f"WORKER: Successfully processed and normalized {len(normalized_embeddings)} document embeddings in subprocess.")
    return normalized_embeddings


def embed_query_in_subprocess(
    text: str,
    embedding_model_path: str,
    n_ctx_embed: int,
    n_gpu_layers_embed: int,
    pooling_type_embed: int
) -> List[float]:
    """
    在子进程中执行单个查询文本嵌入。
    """
    worker_logger.info(f"WORKER: embed_query_in_subprocess received query (first 100): '{text[:100]}'")
    model = _get_embedding_model_instance_in_worker(
        embedding_model_path, n_ctx_embed, n_gpu_layers_embed, pooling_type_embed
    )
    if not model:
        worker_logger.error("WORKER: Failed to get model instance for query. Returning empty embedding.")
        return []
        
    dimension = _process_local_model_dimension_cache.get(embedding_model_path)
    if not dimension:
        worker_logger.error("WORKER: Model dimension not found in cache for query. Critical error.")
        return []
    
    default_zero_vector = [0.0] * dimension

    if not text or not text.strip():
        worker_logger.warning("WORKER: Received empty or invalid text for query embedding. Returning zero vector.")
        return list(default_zero_vector)

    try:
        # 使用 create_embedding 来保持与批量接口的一致性，即使是单个查询
        # 因为我们观察到 Llama.embed() 可能不稳定
        response = model.create_embedding(input=[text])
        if response and "data" in response and isinstance(response["data"], list) and len(response["data"]) == 1:
            item = response["data"][0]
            if isinstance(item, dict) and "embedding" in item and \
               isinstance(item["embedding"], list) and len(item["embedding"]) == dimension:
                embedding_vector = [float(x) for x in item["embedding"]]
                normalized_list_of_list = l2_normalize_embeddings_worker([embedding_vector])
                final_embedding = normalized_list_of_list[0] if normalized_list_of_list and normalized_list_of_list[0] else list(default_zero_vector)
                worker_logger.info(f"WORKER: Successfully processed query embedding in subprocess. Dimension: {len(final_embedding)}")
                return final_embedding
            else:
                worker_logger.warning(f"WORKER: Query embedding response invalid format/dim. Using zero vector.")
                return list(default_zero_vector)
        else:
            worker_logger.error(f"WORKER: Invalid or empty response from create_embedding for query. Using zero vector.")
            return list(default_zero_vector)
    except Exception as e_query_embed:
        worker_logger.error(f"WORKER: Error during query embedding: {e_query_embed}", exc_info=True)
        return list(default_zero_vector)
```

    |-- llm_interface.py

``` py
# zhz_agent/llm.py (renamed to llm_interface.py as per typical module naming)

import pandas as pd
from cachetools import TTLCache
import os
import httpx  # 用于异步HTTP请求
import json  # 用于处理JSON数据
import asyncio  # 用于 asyncio.to_thread
from typing import List, Dict, Any, Optional, Union, Callable 
from dotenv import load_dotenv
import traceback  # Ensure traceback is imported
from pydantic import ValidationError
from zhz_rag.utils.interaction_logger import log_interaction_data # 导入修复后的健壮日志函数
from zhz_rag.config.constants import NEW_KG_SCHEMA_DESCRIPTION # <--- 确保导入这个常量

from zhz_rag.config.pydantic_models import ExtractedEntitiesAndRelationIntent, RagQueryPlan
# 提示词导入
from llama_cpp import Llama, LlamaGrammar 
from zhz_rag.llm.rag_prompts import (
    get_answer_generation_messages, 
    get_clarification_question_messages,
    get_query_expansion_messages,
    get_suggestion_generation_messages,
    get_fusion_messages,
    get_document_summary_messages # <--- 添加这一行
)
import logging
import re
import uuid  # 用于生成 interaction_id
from datetime import datetime, timezone  # 用于生成时间戳
import litellm # <--- 确保这个导入存在

# --- 全局 GBNF 模型实例管理 (性能优化) ---
_llm_gbnf_instance: Optional[Llama] = None
_llm_gbnf_instance_lock = asyncio.Lock()

def _get_gbnf_llm_instance() -> Llama:
    """
    获取一个单例的、线程安全的 Llama GBNF 模型实例。
    在第一次调用时初始化。
    """
    global _llm_gbnf_instance
    if _llm_gbnf_instance is None:
        model_path_from_env = os.getenv("LOCAL_LLM_GGUF_MODEL_PATH")
        if not model_path_from_env or not os.path.exists(model_path_from_env):
            llm_py_logger.critical(f"关键错误: GBNF 调用的 LLM 模型路径未设置或无效: {model_path_from_env}")
            raise ValueError("LOCAL_LLM_GGUF_MODEL_PATH 环境变量未配置或路径无效。")
        
        llm_py_logger.info(f"--- 正在加载 GBNF LLM 模型，请稍候... Path: {model_path_from_env} ---")
        _llm_gbnf_instance = Llama(
            model_path=model_path_from_env,
            n_gpu_layers=int(os.getenv("LLM_N_GPU_LAYERS", 0)),
            n_ctx=int(os.getenv("LLM_N_CTX", 4096)),
            verbose=False
        )
        llm_py_logger.info("--- GBNF LLM 模型加载成功 ---")
    return _llm_gbnf_instance
# --- 全局 GBNF 模型实例管理结束 ---

load_dotenv()  # 确保加载.env文件

_LLM_DIR = os.path.dirname(os.path.abspath(__file__))
RAG_INTERACTION_LOGS_DIR = os.path.join(_LLM_DIR, '..', '..', 'stored_data', 'rag_interaction_logs')


if not os.path.exists(RAG_INTERACTION_LOGS_DIR):
    try:
        os.makedirs(RAG_INTERACTION_LOGS_DIR)
    except Exception:
        pass

def get_llm_log_filepath() -> str:
    """获取当前LLM交互日志文件的完整路径，按天分割。"""
    today_str = datetime.now(timezone.utc).strftime("%Y%m%d")
    return os.path.join(RAG_INTERACTION_LOGS_DIR, f"rag_interactions_{today_str}.jsonl")

async def log_llm_interaction_to_jsonl(interaction_data: Dict[str, Any]):
    """
    将单条LLM交互数据异步追加到JSONL文件中。
    (This function might be part of what log_interaction_data uses, or an alternative logger. Keeping for completeness from original llm.py)
    """
    filepath = get_llm_log_filepath()
    try:
        def _write_sync():
            with open(filepath, 'a', encoding='utf-8') as f:
                f.write(json.dumps(interaction_data, ensure_ascii=False) + "\n")
        await asyncio.to_thread(_write_sync)
        llm_py_logger.debug(f"Successfully logged LLM interaction to {filepath}")
    except Exception as e:
        llm_py_logger.error(f"Failed to log LLM interaction to {filepath}: {e}", exc_info=True)

llm_py_logger = logging.getLogger("LLMUtilsLogger")
llm_py_logger.setLevel(os.getenv("LLM_LOG_LEVEL", "INFO").upper())

if not llm_py_logger.hasHandlers():
    _llm_console_handler = logging.StreamHandler()
    _llm_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _llm_console_handler.setFormatter(_llm_formatter)
    llm_py_logger.addHandler(_llm_console_handler)
    llm_py_logger.propagate = False

llm_py_logger.info("--- LLMUtilsLogger configured ---")

NO_ANSWER_PHRASE_ANSWER_CLEAN = "根据目前提供的资料，我无法找到关于您问题的明确信息。"
NO_ANSWER_PHRASE_KG_CLEAN = "从知识图谱中未找到直接相关信息。"
UNIQUE_STOP_TOKEN = "<|im_endofunable|>"
NO_ANSWER_PHRASE_ANSWER_WITH_STOP_TOKEN = f"{NO_ANSWER_PHRASE_ANSWER_CLEAN}{UNIQUE_STOP_TOKEN}"
# NO_ANSWER_PHRASE_KG_WITH_STOP_TOKEN = f"{NO_ANSWER_PHRASE_KG_CLEAN}{UNIQUE_STOP_TOKEN}"

# # Placeholder for the schema description. Replace with actual schema.
# NEW_KG_SCHEMA_DESCRIPTION = """
# {
#   "node_labels": ["Person", "Project", "Task", "Document", "Region", "SalesAmount", "Product"],
#   "relationship_types": ["WORKS_ON", "ASSIGNED_TO", "HAS_DOCUMENT", "HAS_SALES_AMOUNT", "RELATED_TO"],
#   "node_properties": {
#     "Person": [{"property": "name", "type": "STRING"}, {"property": "role", "type": "STRING"}],
#     "Project": [{"property": "name", "type": "STRING"}, {"property": "status", "type": "STRING"}],
#     "Task": [{"property": "name", "type": "STRING"}, {"property": "status", "type": "STRING"}, {"property": "priority", "type": "STRING"}],
#     "Document": [{"property": "id", "type": "STRING"}, {"property": "title", "type": "STRING"}, {"property": "type", "type": "STRING"}],
#     "Region": [{"property": "name", "type": "STRING"}],
#     "SalesAmount": [{"property": "period", "type": "STRING"}, {"property": "numeric_amount", "type": "FLOAT"}, {"property": "unit", "type": "STRING"}],
#     "Product": [{"property": "name", "type": "STRING"}, {"property": "category", "type": "STRING"}]
#   },
#   "relationship_properties": {},
#   "output_format_guidance": {
#     "description": "Your response MUST be a JSON object with two fields: 'status' and 'query'.",
#     "status_field": {
#       "description": "The 'status' field can be one of two values: 'success' or 'unable_to_generate'.",
#       "success": "If you can generate a Cypher query, status should be 'success'.",
#       "unable_to_generate": "If you cannot generate a Cypher query based on the question and schema, status should be 'unable_to_generate'."
#     },
#     "query_field": {
#       "description": "The 'query' field contains the Cypher query as a string if status is 'success'.",
#       "success_example": "MATCH (n) RETURN n LIMIT 1",
#       "unable_to_generate_example": "无法生成Cypher查询."
#     }
#   },
#   "examples": [
#     {
#       "User Question": "Who is task 'FixBug123' assigned to?",
#       "Your EXACT Response": {
#         "status": "success",
#         "query": "MATCH (t:Task {name: 'FixBug123'})<-[:ASSIGNED_TO]-(p:Person) RETURN p.name AS assignedTo"
#       }
#     },
#     {
#       "User Question": "What is the color of the sky?",
#       "Your EXACT Response": {
#         "status": "unable_to_generate",
#         "query": "无法生成Cypher查询."
#       }
#     }
#   ]
# }
# """

LLM_API_URL = os.getenv("SGLANG_API_URL", "http://localhost:8088/v1/chat/completions")

async def call_llm_via_openai_api_local_only( # 改个名字以示区分
    prompt: Union[str, List[Dict[str, str]]], # prompt 可以是字符串或消息列表
    temperature: float = 0.2,
    max_new_tokens: Optional[int] = 1024,
    stop_sequences: Optional[List[str]] = None,
    task_type: str = "unknown_local_llm_call",
    user_query_for_log: Optional[str] = None,
    model_name_for_log: str = "local_qwen_via_openai_api_compat",
    application_version_for_log: str = "0.1.0_local_compat"
) -> Optional[str]:
    llm_py_logger.info(f"Calling LOCAL LLM ({model_name_for_log}) for task: {task_type}, Target API: {LLM_API_URL}")

    current_messages: List[Dict[str, str]]
    original_prompt_for_log: str

    if isinstance(prompt, str): # 假设旧的SGLang风格的prompt字符串
        original_prompt_for_log = prompt
        # 尝试从SGLang格式转换为OpenAI messages格式
        # 这个转换逻辑需要根据您SGLang prompt的具体格式来定
        # 一个简化的例子，可能需要调整：
        current_messages = []
        # 简单的假设：如果prompt以<|im_start|>system开头，则提取system和user部分
        if prompt.startswith("<|im_start|>system"):
            parts = prompt.split("<|im_start|>")
            for part in parts:
                if not part.strip(): continue
                role_content = part.split("<|im_end|>")[0].strip()
                if "\n" in role_content:
                    role, content = role_content.split("\n", 1)
                    current_messages.append({"role": role.strip().lower(), "content": content.strip()})
        if not current_messages: # 如果转换失败或不是SGLang格式，则认为是单个user消息
            current_messages = [{"role": "user", "content": prompt}]
    elif isinstance(prompt, list):
        current_messages = prompt
        original_prompt_for_log = "Messages list provided directly."
    else:
        llm_py_logger.error(f"Invalid 'prompt' argument type: {type(prompt)}")
        return None

    payload = {
        "model": model_name_for_log, # 这个model名会被本地服务忽略，但符合OpenAI格式
        "messages": current_messages,
        "temperature": temperature,
        "max_tokens": max_new_tokens,
    }
    if stop_sequences:
        payload["stop"] = stop_sequences

    headers = {"Content-Type": "application/json"}
    llm_parameters_for_log = {k:v for k,v in payload.items() if k not in ['messages', 'model']} # model已在顶层记录
    raw_llm_output_text = None
    error_info = None

    try:
        async with httpx.AsyncClient(timeout=120.0) as client:
            response = await client.post(LLM_API_URL, json=payload, headers=headers) # LLM_API_URL 指向本地服务
            response.raise_for_status()
            response_json = response.json()
            if response_json.get("choices") and response_json["choices"][0].get("message"):
                raw_llm_output_text = response_json["choices"][0]["message"].get("content", "")
            else:
                raw_llm_output_text = "[[LLM_RESPONSE_MALFORMED_CHOICES_OR_MESSAGE_LOCAL]]"
            llm_py_logger.info(f"FULL Local LLM Raw Output for task '{task_type}': >>>{raw_llm_output_text}<<<")

    except Exception as e:
        llm_py_logger.error(f"Error calling local LLM service: {e}", exc_info=True)
        error_info = str(e)
        # 确保记录错误
        log_error_data = {
            "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
            "task_type": task_type + "_local_error", "user_query_for_task": user_query_for_log,
            "llm_input_messages": current_messages,
            "llm_input_original_prompt_if_string": original_prompt_for_log if isinstance(prompt, str) else None,
            "llm_parameters": llm_parameters_for_log,
            "raw_llm_output": f"Error: {error_info}. Partial raw output: {str(raw_llm_output_text)[:200] if raw_llm_output_text else 'N/A'}",
            "error_details": traceback.format_exc(), "application_version": application_version_for_log
        }
        await log_interaction_data(log_error_data)
        return None # 出错时返回None

    # 记录成功的调用
    log_success_data = {
        "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "task_type": task_type, "user_query_for_task": user_query_for_log,
        "llm_input_messages": current_messages,
        "llm_input_original_prompt_if_string": original_prompt_for_log if isinstance(prompt, str) else None,
        "llm_parameters": llm_parameters_for_log,
        "raw_llm_output": raw_llm_output_text, "application_version": application_version_for_log
    }
    await log_interaction_data(log_success_data)
    return raw_llm_output_text

# async def generate_cypher_query(user_question: str) -> Optional[str]: # kg_schema_description 参数可以移除了，因为它已包含在新的prompt函数中
#     llm_py_logger.info(f"Attempting to generate Cypher query (template-based) for: '{user_question}' via local service.")

#     messages_for_llm = get_cypher_generation_messages_with_templates(user_question)

#     cypher_stop_sequences = ['<|im_end|>', '```'] # 如果输出包含markdown的json块

#     llm_response_json_str = await call_llm_via_openai_api_local_only( 
#         prompt=messages_for_llm,
#         temperature=0.0, # 对于精确的JSON和Cypher生成，温度设为0
#         max_new_tokens=1024, # 允许足够的空间输出JSON和Cypher
#         stop_sequences=cypher_stop_sequences,
#         task_type="cypher_generation_template_based_local_service",
#         user_query_for_log=user_question,
#         model_name_for_log="qwen3_gguf_cypher_template_local"
#     )

#     if not llm_response_json_str:
#         llm_py_logger.warning(f"LLM call for Cypher (template-based) returned None or empty. User question: '{user_question}'")
#         return json.dumps({"status": "unable_to_generate", "query": "无法生成Cypher查询."}) # 始终返回JSON字符串

#     cleaned_json_str = llm_response_json_str.strip()
#     if cleaned_json_str.startswith("```json"):
#         cleaned_json_str = cleaned_json_str[len("```json"):].strip()
#     if cleaned_json_str.endswith("```"):
#         cleaned_json_str = cleaned_json_str[:-len("```")].strip()

#     try:

#         parsed_for_validation = json.loads(cleaned_json_str)
#         if isinstance(parsed_for_validation, dict) and \
#            "status" in parsed_for_validation and \
#            "query" in parsed_for_validation:
#             llm_py_logger.info(f"LLM returned valid JSON for Cypher (template-based): {cleaned_json_str}")
#             return cleaned_json_str
#         else:
#             llm_py_logger.warning(f"LLM output for Cypher (template-based) was JSON but not expected structure: {cleaned_json_str}")
#             return json.dumps({"status": "unable_to_generate", "query": "LLM输出JSON结构错误."})
#     except json.JSONDecodeError:
#         llm_py_logger.error(f"Failed to parse JSON response for Cypher (template-based): '{cleaned_json_str}'", exc_info=True)
#         # 如果不是有效的JSON，但包含"MATCH"，可能LLM直接输出了Cypher，尝试包装它
#         if "MATCH" in cleaned_json_str.upper() or "RETURN" in cleaned_json_str.upper():
#              llm_py_logger.warning("LLM output for Cypher (template-based) was not JSON but looks like Cypher, wrapping it.")
#              return json.dumps({"status": "success", "query": cleaned_json_str})
#         return json.dumps({"status": "unable_to_generate", "query": "LLM输出非JSON格式."})

async def generate_answer_from_context(
    user_query: str,
    context_str: str,
    prompt_builder: Optional[Callable[[str, str], List[Dict[str, str]]]] = None
) -> Optional[str]:
    """
    Generates an answer from context.
    V2: Can accept a dynamic prompt builder for specialized tasks like Table-QA.
    """
    from .rag_prompts import get_answer_generation_messages # 默认的 prompt builder

    # 如果没有提供特定的 prompt_builder，就使用默认的通用版本
    if prompt_builder is None:
        prompt_builder = get_answer_generation_messages
    
    llm_py_logger.info(f"Generating answer for query: '{user_query[:50]}...' using prompt builder: {prompt_builder.__name__}")
    
    # 使用 prompt_builder 来构建 messages
    messages = prompt_builder(user_query, context_str)
    
    final_answer = await call_llm_via_openai_api_local_only(
        prompt=messages, # <--- 将 messages 列表传递给 prompt 参数
        task_type=f"answer_generation_using_{prompt_builder.__name__}",
        model_name_for_log="qwen3_gguf_answer_gen_v2"
        # 其他参数如 temperature, max_tokens 会使用该函数的默认值
    )
    
    if final_answer and final_answer != NO_ANSWER_PHRASE_ANSWER_CLEAN:
        return final_answer
    elif final_answer: # 如果是 "无法找到信息"
        return final_answer
    else: # 如果返回None或空字符串
        llm_py_logger.warning("Answer generation returned None or empty string. Falling back to default no-answer phrase.")
        return NO_ANSWER_PHRASE_ANSWER_CLEAN

# async def generate_simulated_kg_query_response(user_query: str, kg_schema_description: str, kg_data_summary_for_prompt: str) -> Optional[str]:
#     prompt_str = f"""<|im_start|>system
# 你是一个知识图谱查询助手。你的任务是根据用户提出的问题、知识图谱Schema描述和图谱中的数据摘要，直接抽取出与问题最相关的1-2个事实片段作为答案。
# 只输出事实片段，不要解释，不要生成Cypher语句，不要包含任何额外对话或标记。
# 如果找不到直接相关的事实，请**直接且完整地**回答：“{NO_ANSWER_PHRASE_KG_WITH_STOP_TOKEN}”<|im_end|>
# <|im_start|>user
# 知识图谱Schema描述:
# {kg_schema_description}

# 知识图谱数据摘要: 
# {kg_data_summary_for_prompt}

# 用户问题: {user_query}<|im_end|>
# <|im_start|>assistant
# """
#     stop_sequences = ["<|im_end|>", UNIQUE_STOP_TOKEN]
#     return await call_llm_via_openai_api_local_only(
#         prompt=prompt_str,
#         temperature=0.5,
#         max_new_tokens=256,
#         stop_sequences=stop_sequences,
#         task_type="simulated_kg_query_response",
#         user_query_for_log=user_query
#     )


async def generate_clarification_question(original_query: str, uncertainty_reason: str) -> Optional[str]:
    llm_py_logger.info(f"调用LLM API生成澄清问题。原始查询: '{original_query}', 原因: '{uncertainty_reason}'")
    messages_for_llm = get_clarification_question_messages(original_query, uncertainty_reason)

    clarification_question_raw = await call_llm_via_openai_api_local_only(
        prompt=messages_for_llm,
        temperature=0.5,
        max_new_tokens=128,
        stop_sequences=['<|im_end|>'], # 对于Qwen系列，<|im_end|> 是一个常见的结束标记
        task_type="clarification_question_generation",
        user_query_for_log=original_query
    )
    
    if not clarification_question_raw or not clarification_question_raw.strip():
        llm_py_logger.warning("LLM未能生成澄清问题，返回默认提示。")
        return "抱歉，我不太理解您的意思，请您再具体说明一下。"  
    cleaned_question_from_llm = clarification_question_raw.strip()
    llm_py_logger.debug(f"LLM原始澄清输出 (清理后): '{cleaned_question_from_llm}'")
    potential_lines = cleaned_question_from_llm.splitlines()
    
    final_extracted_question = None

    for line in reversed(potential_lines):
        line_stripped = line.strip()
        if not line_stripped: # 跳过空行
            continue
        if line_stripped.endswith("？") or line_stripped.endswith("?"):
            if not (line_stripped.startswith("好的，") or \
                    line_stripped.startswith("首先，") or \
                    line_stripped.startswith("因此，") or \
                    line_stripped.startswith("所以，") or \
                    line_stripped.startswith("根据这个原因，") or \
                    "我需要生成一个" in line_stripped or \
                    "可能的澄清问题是" in line_stripped or \
                    "澄清问题应该是" in line_stripped or \
                    "接下来，" in line_stripped):
                final_extracted_question = line_stripped
                llm_py_logger.info(f"通过行分割和问号结尾提取到澄清问题: '{final_extracted_question}'")
                break 
        elif any(line_stripped.startswith(prefix) for prefix in ["请问您", "您对", "您具体指的是"]):
            final_extracted_question = line_stripped
            llm_py_logger.info(f"通过行分割和特定前缀提取到澄清问题: '{final_extracted_question}'")
            break

    if final_extracted_question:
        llm_py_logger.info(f"LLM成功生成并提取到最终澄清问题: {final_extracted_question}")
        return final_extracted_question
    else:
        potential_sentences = re.split(r'(?<=[。？！?])\s*', cleaned_question_from_llm)
        for sentence in reversed(potential_sentences):
            sentence_stripped = sentence.strip()
            if not sentence_stripped:
                continue
            if sentence_stripped.endswith("？") or sentence_stripped.endswith("?") or \
               any(sentence_stripped.startswith(prefix) for prefix in ["请问您", "您是想", "您具体指的是", "关于您提到的"]):
                if not (sentence_stripped.startswith("好的，") or \
                        sentence_stripped.startswith("首先，") or \
                        "我需要生成一个" in sentence_stripped or \
                        "可能的澄清问题是" in sentence_stripped): # 避免选择思考过程
                    final_extracted_question = sentence_stripped
                    llm_py_logger.info(f"通过句子分割和启发式规则提取到澄清问题: '{final_extracted_question}'")
                    break
        
        if final_extracted_question:
            llm_py_logger.info(f"LLM成功生成并提取到最终澄清问题 (后备逻辑): {final_extracted_question}")
            return final_extracted_question
        else:
            llm_py_logger.warning(f"未能通过所有启发式规则从LLM输出中提取明确的澄清问句。原始输出为: '{cleaned_question_from_llm}'。将返回默认澄清。")

            if len(cleaned_question_from_llm) < 70 and (cleaned_question_from_llm.endswith("？") or cleaned_question_from_llm.endswith("?")): # 70是个经验值
                 llm_py_logger.info(f"原始输出较短且以问号结尾，将其作为澄清问题返回: '{cleaned_question_from_llm}'")
                 return cleaned_question_from_llm
            return "抱歉，我不太理解您的意思，请您再具体说明一下。"


async def generate_clarification_options(original_query: str, uncertainty_reason: str) -> List[str]:
    prompt_str = f"""<|im_start|>system
你是一个智能助手，擅长根据用户查询的模糊性提供具体的澄清选项。
你的任务是根据用户原始查询和系统检测到的不确定性原因，生成3-5个具体的、可供用户选择的澄清选项。
每个选项都应该是一个简洁的短语或问题，帮助用户明确其意图。
你的回答必须是一个JSON数组（列表），其中每个元素是一个字符串（澄清选项）。
只输出JSON数组，不要包含任何其他解释、对话标记或代码块。

示例:
用户查询: "帮我预定机票。"
不确定性原因: "缺少出发城市、目的地、日期等信息。"
助手:
[
  "请问您想从哪个城市出发？",
  "请问您的目的地是哪里？",
  "请问您希望在哪一天出行？",
  "您有偏好的航空公司或舱位等级吗？"
]<|im_end|>
<|im_start|>user
用户原始查询: {original_query}
不确定性原因: {uncertainty_reason}

请生成澄清选项:<|im_end|>
<|im_start|>assistant
"""
    stop_sequences = ["<|im_end|>"]
    llm_py_logger.info(f"调用LLM API生成澄清选项 (Prompt长度: {len(prompt_str)} 字符)...")
    llm_output = await call_llm_via_openai_api_local_only(
        prompt=prompt_str,
        temperature=0.7,
        max_new_tokens=256,
        stop_sequences=stop_sequences,
        task_type="clarification_options_generation",
        user_query_for_log=original_query
    )

    options = []
    if llm_output:
        try:
            json_str = llm_output.strip()
            if json_str.startswith("```json"):
                json_str = json_str[len("```json"):].strip()
            if json_str.endswith("```"):
                json_str = json_str[:-len("```")].strip()
            
            parsed_options = json.loads(json_str)
            if isinstance(parsed_options, list) and all(isinstance(o, str) for o in parsed_options):
                options = parsed_options
                llm_py_logger.info(f"LLM成功生成 {len(options)} 个澄清选项。")
            else:
                llm_py_logger.warning(f"LLM生成的澄清选项JSON格式不符合预期 (不是字符串列表): {llm_output[:200]}...")
        except json.JSONDecodeError as e:
            llm_py_logger.error(f"解析LLM澄清选项JSON失败: {e}. 原始输出: {llm_output[:200]}...", exc_info=True)
        except Exception as e:
            llm_py_logger.error(f"处理LLM澄清选项时发生未知错误: {e}. 原始输出: {llm_output[:200]}...", exc_info=True)
    else:
        llm_py_logger.warning("LLM未能生成澄清选项。")
    
    if not options:
        options.append("请提供更多详细信息。")
    
    return options


INTENT_CLASSIFICATION_JSON_SCHEMA = {
    "type": "object",
    "properties": {
        "clarification_needed": {"type": "boolean"},
        "reason": {"type": "string"}
    },
    "required": ["clarification_needed", "reason"]
}

async def generate_intent_classification(user_query: str) -> Dict[str, Any]:
    llm_py_logger.info(f"Generating intent classification for query: '{user_query[:100]}...' using Gemini.")
    
    # 针对Gemini优化的Prompt，强调直接输出JSON
    system_prompt_for_intent = f"""你是一个智能意图分类器。你的任务是分析用户查询，判断该查询是否清晰明确，或者是否存在歧义、信息不足导致需要进一步澄清。
如果查询包含具体的命名实体（如人名“张三”、项目名“项目X”、产品名“新产品A”等），并且问题是关于这些实体的特定信息（例如“张三的职位是什么？”、“项目X的截止日期是哪天？”、“新产品A的功能有哪些？”），则通常认为查询是清晰的，不需要澄清。
只有当查询缺少定位关键信息所必需的核心实体，或者询问的范围过于宽泛无法直接操作时，才需要澄清。

如果查询需要澄清，请说明原因。
你的【唯一输出】必须是一个严格符合以下结构的JSON对象，不要包含任何其他文本、解释或markdown标记:
{{
  "clarification_needed": true/false,
  "reason": "如果需要澄清，请简要说明原因；如果不需要，则为空字符串。"
}}

示例1 (需要澄清 - 信息不足):
用户查询: "帮我预定明天去上海的机票。"
助手 JSON 输出:
{{
  "clarification_needed": true,
  "reason": "缺少出发城市、具体时间（上午/下午/晚上）、舱位等级等信息。"
}}

示例2 (不需要澄清 - 清晰):
用户查询: "公司最新的销售额报告在哪里可以找到？"
助手 JSON 输出:
{{
  "clarification_needed": false,
  "reason": ""
}}
"""
    
    messages_for_gemini = [
        {"role": "system", "content": system_prompt_for_intent},
        {"role": "user", "content": f"用户查询: {user_query}"}
    ]

    # 从环境变量获取Gemini配置
    gemini_model_name = os.getenv("CLOUD_LLM_MODEL_NAME_FOR_LITELLM", "gemini/gemini-1.5-flash-latest")
    gemini_api_key = os.getenv("GEMINI_API_KEY") # 或者 GOOGLE_API_KEY
    proxy_url = os.getenv("LITELLM_PROXY_URL")

    litellm_params: Dict[str, Any] = {
        "model": gemini_model_name,
        "messages": messages_for_gemini,
        "api_key": gemini_api_key,
        "temperature": 0.1, 
        "max_tokens": 256,  # 意图分类的JSON输出通常较短
        # "response_format": {"type": "json_object"} # LiteLLM的Gemini集成可能尚不支持此参数，暂时注释
    }
    if proxy_url:
        # LiteLLM 的 proxy 参数期望一个字典，或者直接是一个字符串URL (取决于LiteLLM版本和具体实现)
        # 为保险起见，我们按文档常见的字典格式提供
        litellm_params["proxy"] = {
            "http": proxy_url,
            "https": proxy_url,
        }
        # 或者，如果您的LiteLLM版本支持直接传递字符串URL作为代理：
        # litellm_params["api_base"] = proxy_url # 这会将代理用于所有请求，如果Gemini也通过此代理
        # litellm_params["base_url"] = proxy_url # 有些版本用 base_url
        # 更通用的方式是设置环境变量 HTTP_PROXY 和 HTTPS_PROXY，LiteLLM通常会读取它们
        # 但为了显式，我们这里尝试通过参数传递给litellm.acompletion

    llm_py_logger.info(f"Calling Gemini (via LiteLLM) for intent classification. Model: {gemini_model_name}")
    debug_params = {k:v for k,v in litellm_params.items() if k not in ['messages', 'api_key']}
    llm_py_logger.debug(f"LiteLLM params for intent (excluding messages & api_key): {debug_params}")
    
    raw_gemini_output_text = None
    error_info_intent = None
    parsed_result_dict: Optional[Dict[str, Any]] = None # 用于存储最终解析结果

    try:
        response = await litellm.acompletion(**litellm_params)
        if response and response.choices and response.choices[0].message and response.choices[0].message.content:
            raw_gemini_output_text = response.choices[0].message.content.strip()
            llm_py_logger.info(f"Gemini intent classification raw output: {raw_gemini_output_text[:300]}...")
            
            # 尝试解析JSON (与之前的提取逻辑类似)
            json_str_candidate = raw_gemini_output_text
            # 1. 尝试从 markdown block 中提取
            markdown_match = re.search(r"```json\s*(\{[\s\S]*?\})\s*```", json_str_candidate, re.DOTALL)
            if markdown_match:
                json_str_candidate = markdown_match.group(1)
                llm_py_logger.debug(f"Extracted JSON candidate from markdown: {json_str_candidate[:200]}...")
            
            # 2. 如果没有markdown，或者提取后仍然不是纯JSON，尝试直接解析或查找第一个 '{' 和最后一个 '}'
            try:
                parsed_result_dict = json.loads(json_str_candidate)
            except json.JSONDecodeError: # 如果直接解析失败
                first_brace = json_str_candidate.find('{')
                last_brace = json_str_candidate.rfind('}')
                if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                    json_str_candidate = json_str_candidate[first_brace : last_brace+1]
                    llm_py_logger.debug(f"Extracted JSON candidate by braces: {json_str_candidate[:200]}...")
                    try:
                        parsed_result_dict = json.loads(json_str_candidate)
                    except json.JSONDecodeError as e_json_brace:
                        error_info_intent = f"Failed to decode JSON from Gemini intent (braces): {e_json_brace}"
                        llm_py_logger.error(error_info_intent, exc_info=True)
                else: # 没有找到有效的花括号对
                    error_info_intent = "No valid JSON object found in Gemini intent output."
                    llm_py_logger.error(error_info_intent + f" Raw: {raw_gemini_output_text[:200]}")
            
            # 验证解析后的JSON结构
            if parsed_result_dict and isinstance(parsed_result_dict, dict) and \
               "clarification_needed" in parsed_result_dict and \
               "reason" in parsed_result_dict:
                llm_py_logger.info(f"Gemini successfully classified intent: {parsed_result_dict}")
                # 记录成功的调用
                log_data_intent = {
                    "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
                    "task_type": "intent_classification_gemini", "user_query_for_task": user_query,
                    "llm_input_messages": messages_for_gemini, "llm_parameters": {k:v for k,v in litellm_params.items() if k not in ['messages', 'api_key', 'proxy']},
                    "raw_llm_output": raw_gemini_output_text, "application_version": "0.1.0_intent_gemini"
                }
                await log_interaction_data(log_data_intent)
                return parsed_result_dict
            else: # 解析成功但结构不对
                if parsed_result_dict: # 避免对None调用get
                    error_info_intent = f"Gemini intent output JSON structure mismatch. Parsed: {parsed_result_dict}"
                else: # parsed_result_dict 为 None (例如，花括号提取失败后)
                    error_info_intent = "Gemini intent output JSON structure mismatch (parsed_result_dict is None)."
                llm_py_logger.warning(error_info_intent)
        else: # response.choices[0].message.content 为空或不存在
            error_info_intent = "Gemini intent call returned empty or malformed response content."
            llm_py_logger.error(f"{error_info_intent} Full response object: {response}")

    except Exception as e_gemini_call:
        error_info_intent = f"Error calling Gemini for intent: {e_gemini_call}"
        llm_py_logger.error(error_info_intent, exc_info=True)

    # 如果执行到这里，说明出错了或者没有得到期望的JSON
    log_error_data_intent = {
        "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "task_type": "intent_classification_gemini_error", "user_query_for_task": user_query,
        "llm_input_messages": messages_for_gemini, "llm_parameters": {k:v for k,v in litellm_params.items() if k not in ['messages', 'api_key', 'proxy']},
        "raw_llm_output": raw_gemini_output_text or "N/A", "error_details": error_info_intent,
        "application_version": "0.1.0_intent_gemini"
    }
    await log_interaction_data(log_error_data_intent)
    
    llm_py_logger.warning(f"Gemini failed to generate valid intent classification, defaulting to no clarification needed. Error: {error_info_intent or 'Unknown reason'}")
    return {"clarification_needed": False, "reason": f"Intent classification by Gemini failed: {error_info_intent or 'Unknown reason'}"}

# --- 新增：用于提取实体和关系意图的函数 ---
# async def extract_entities_for_kg_query(user_question: str) -> Optional[ExtractedEntitiesAndRelationIntent]:
#     llm_py_logger.info(f"Attempting to extract entities and relation intent for KG query (with GBNF) from: '{user_question}'")

#     # --- 使用您在 test_gbnf_extraction.py 中验证成功的 One-Shot Prompt 构建逻辑 ---
#     one_shot_example = """
# --- 示例 ---
# 输入文本: "Alice在ACME公司担任工程师。"
# 输出JSON:
# {
#   "entities": [
#     {"text": "Alice", "label": "PERSON"},
#     {"text": "ACME公司", "label": "ORGANIZATION"},
#     {"text": "工程师", "label": "TASK"}
#   ],
#   "relations": [
#     {"head_entity_text": "Alice", "head_entity_label": "PERSON", "relation_type": "WORKS_AT", "tail_entity_text": "ACME公司", "tail_entity_label": "ORGANIZATION"}
#   ]
# }
# --- 任务开始 ---"""
    
#     # system_content 部分与您的测试脚本保持一致
#     system_content_for_prompt = (
#         f"你是一个严格的JSON知识图谱提取器。请根据用户提供的文本，严格按照示例格式，生成一个包含'entities'和'relations'的JSON对象。\n"
#         f"{one_shot_example}"
#     )

#     # user_content 部分也与您的测试脚本保持一致
#     user_content_for_prompt = (
#         f"输入文本: \"{user_question}\"\n" # 注意：这里用的是 user_question，而不是固定的 sample_text_to_extract
#         f"输出JSON:\n"
#     )

#     full_prompt_for_extraction = (
#         f"<|im_start|>system\n{system_content_for_prompt}<|im_end|>\n"
#         f"<|im_start|>user\n{user_content_for_prompt}<|im_end|>\n"
#         f"<|im_start|>assistant\n"
#     )
#     # --- Prompt 构建结束 ---

#     llm_response_str = await call_local_llm_with_gbnf(
#         full_prompt=full_prompt_for_extraction,
#         grammar_str=KG_EXTRACTION_GBNF_STRING, # 使用我们定义的GBNF字符串
#         temperature=0.1,
#         max_tokens=1024, # 与您的测试脚本一致
#         repeat_penalty=1.2, # 与您的测试脚本一致
#         stop_sequences=["<|im_end|>"], # Qwen的停止标记
#         task_type="kg_entity_relation_extraction_gbnf",
#         user_query_for_log=user_question,
#         model_name_for_log="qwen3_gguf_kg_ext_gbnf"
#     )

#     if not llm_response_str:
#         llm_py_logger.warning(f"LLM call for KG entity/relation extraction (GBNF) returned None or empty. User question: '{user_question}'")
#         return None

    # GBNF应该确保输出是有效的JSON，所以我们可以直接尝试解析
    try:
        # .strip() 以防万一有额外的空白被GBNF的 space 规则匹配但未被移除
        parsed_data = json.loads(llm_response_str.strip())
        extracted_info = ExtractedEntitiesAndRelationIntent(**parsed_data)
        llm_py_logger.info(f"Successfully parsed Pydantic model from GBNF LLM output: {extracted_info.model_dump_json(indent=2)}")
        return extracted_info
    except json.JSONDecodeError as e_json:
        llm_py_logger.error(f"Failed to decode JSON from GBNF LLM output: '{llm_response_str}'. Error: {e_json}", exc_info=True)
        return None
    except Exception as e_pydantic: # Catch Pydantic validation errors
        llm_py_logger.error(f"Failed to validate Pydantic model from GBNF LLM JSON: '{llm_response_str}'. Error: {e_pydantic}", exc_info=True)
        return None
    

async def call_local_llm_with_gbnf(
    llm_instance: Llama, # <--- 接受一个已加载的实例作为参数
    full_prompt: str,
    grammar_str: str,
    temperature: float = 0.1,
    max_tokens: int = 1024,
    repeat_penalty: float = 1.2,
    stop_sequences: Optional[List[str]] = None,
    task_type: str = "gbnf_constrained_generation",
    user_query_for_log: Optional[str] = None,
    model_name_for_log: str = "local_qwen_gguf_gbnf",
    application_version_for_log: str = "0.1.0_gbnf"
) -> Optional[str]:
    llm_py_logger.info(f"Calling LOCAL LLM with GBNF for task: {task_type}. Prompt length: {len(full_prompt)}")

    raw_llm_output_text = None
    error_info = None
    
    try:
        compiled_grammar = LlamaGrammar.from_string(grammar_str)
        
        # 不再需要获取实例，直接使用传入的 llm_instance
        if llm_instance is None:
            raise ValueError("LLM GBNF instance is not available in the application context.")

        def _blocking_llm_call():
            response = llm_instance.create_completion(
                prompt=full_prompt,
                grammar=compiled_grammar,
                temperature=temperature,
                max_tokens=max_tokens,
                repeat_penalty=repeat_penalty,
                stop=stop_sequences or []
            )
            return response['choices'][0]['text']

        raw_llm_output_text = await asyncio.to_thread(_blocking_llm_call)
        llm_py_logger.info(f"GBNF Call: Raw LLM Output for task '{task_type}': >>>{raw_llm_output_text}<<<")

    except Exception as e:
        llm_py_logger.error(f"Error calling local LLM service with GBNF: {e}", exc_info=True)
        error_info = str(e)
        log_error_data = {
            "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
            "task_type": task_type + "_error", "user_query_for_task": user_query_for_log,
            "llm_input_prompt": full_prompt[:500] + "...",
            "llm_parameters": {"temperature": temperature, "max_tokens": max_tokens, "repeat_penalty": repeat_penalty, "stop": stop_sequences},
            "raw_llm_output": f"Error: {error_info}. Partial raw output: {str(raw_llm_output_text)[:200] if raw_llm_output_text else 'N/A'}",
            "error_details": traceback.format_exc(), "application_version": application_version_for_log
        }
        await log_interaction_data(log_error_data)
        return None

    log_success_data = {
        "interaction_id": str(uuid.uuid4()), "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "task_type": task_type, "user_query_for_task": user_query_for_log,
        "llm_input_prompt": full_prompt[:500] + "...",
        "llm_parameters": {"temperature": temperature, "max_tokens": max_tokens, "repeat_penalty": repeat_penalty, "stop": stop_sequences, "grammar_used": True},
        "raw_llm_output": raw_llm_output_text, "application_version": application_version_for_log
    }
    await log_interaction_data(log_success_data)
    return raw_llm_output_text


async def generate_query_plan(llm_instance: Llama, user_query: str) -> Optional[RagQueryPlan]:
    """
    Analyzes the user query and generates a structured plan for retrieval,
    containing a core query string and a metadata filter.
    Uses GBNF for reliable JSON output.
    """
    # 导入我们新定义的 Prompt, GBNF Schema 和 Pydantic 模型
    from .rag_prompts import V2_PLANNING_PROMPT_TEMPLATE, V2_PLANNING_GBNF_SCHEMA
    from ..config.pydantic_models import RagQueryPlan

    llm_py_logger.info(f"Generating RAG query plan for: '{user_query[:100]}...'")

    # 1. 使用新的模板准备 Prompt
    full_prompt = V2_PLANNING_PROMPT_TEMPLATE.format(user_query=user_query)

    # 2. 调用带有 GBNF 约束的本地 LLM
    llm_response_str = await call_local_llm_with_gbnf(
        llm_instance=llm_instance,
        full_prompt=full_prompt,
        grammar_str=V2_PLANNING_GBNF_SCHEMA,
        temperature=0.0,  # 对于精确的JSON生成，使用零温度
        max_tokens=512,  # 为过滤器和查询提供足够的空间
        task_type="rag_query_planning", # 更新任务类型
        user_query_for_log=user_query,
        model_name_for_log="qwen3_gguf_rag_planner"
    )

    if not llm_response_str:
        llm_py_logger.warning("LLM query planner call returned no response. Falling back to simple query.")
        return RagQueryPlan(query=user_query, metadata_filter={})

    # 3. 解析结果并返回 Pydantic 对象
    try:
        # 清理LLM可能返回的 markdown 代码块标记
        cleaned_response = llm_response_str.strip()
        if cleaned_response.startswith("```json"):
            cleaned_response = cleaned_response[len("```json"):].strip()
        if cleaned_response.endswith("```"):
            cleaned_response = cleaned_response[:-3].strip()
            
        parsed_data = json.loads(cleaned_response)
        query_plan = RagQueryPlan(**parsed_data)
        
        llm_py_logger.info(f"Successfully generated query plan. Query: '{query_plan.query}', Filter: {query_plan.metadata_filter}")
        return query_plan
        
    except (json.JSONDecodeError, TypeError, ValidationError) as e:
        llm_py_logger.error(f"Failed to parse or validate LLM query plan. Error: {e}. Raw output: '{llm_response_str}'. Falling back to simple query.", exc_info=True)
        # 即使解析失败，也要保证RAG流程能继续，返回一个基础的计划
        return RagQueryPlan(query=user_query, metadata_filter={})
    

# --- V4 - Table QA Instruction Generation (Validated by PoC) ---

TABLE_QA_INSTRUCTION_PROMPT_TEMPLATE = """
# 指令
你是一个专门从用户问题中提取表格查询指令的AI。你的唯一任务是分析【用户问题】和【表格列名】，然后输出一个包含`row_identifier`和`column_identifier`的JSON对象。

## 表格信息
【表格列名】: {column_names}

## 用户问题
【用户问题】: "{user_query}"

## 输出要求
请严格按照以下格式输出一个JSON对象，不要包含任何其他文字或解释。
```json
{{
  "row_identifier": "string, 用户问题中提到的具体行名",
  "column_identifier": "string, 用户问题中提到的具体列名"
}}
```
你的JSON输出:
"""
# 使用主项目中已验证过的、最健壮的通用JSON GBNF Schema
from .rag_prompts import V2_PLANNING_GBNF_SCHEMA as TABLE_QA_INSTRUCTION_GBNF_SCHEMA


async def generate_table_lookup_instruction(llm_instance: Llama, user_query: str, table_column_names: List[str]) -> Optional[Dict[str, str]]:
    """
    Uses LLM to generate a structured instruction for table lookup, based on the user query and table columns.
    Returns a dictionary like {"row_identifier": "...", "column_identifier": "..."}.
    """
    llm_py_logger.info(f"Generating table lookup instruction for query: '{user_query}'")
    
    prompt = TABLE_QA_INSTRUCTION_PROMPT_TEMPLATE.format(
        column_names=", ".join(table_column_names),
        user_query=user_query
    )

    llm_response_str = await call_local_llm_with_gbnf(
        llm_instance=llm_instance,
        full_prompt=prompt,
        grammar_str=TABLE_QA_INSTRUCTION_GBNF_SCHEMA,
        temperature=0.0,
        max_tokens=256,
        task_type="table_qa_instruction_generation",
        user_query_for_log=user_query
    )
    if not llm_response_str:
        llm_py_logger.warning("LLM call for table instruction generation returned None.")
        return None
    try:
        instruction_json = json.loads(llm_response_str)
        if "row_identifier" in instruction_json and "column_identifier" in instruction_json:
            llm_py_logger.info(f"Successfully generated table lookup instruction: {instruction_json}")
            return instruction_json
        else:
            llm_py_logger.warning(f"Generated JSON is missing required keys: {instruction_json}")
            return None
    except json.JSONDecodeError:
        llm_py_logger.error(f"Failed to decode JSON from LLM for table instruction: {llm_response_str}")
        return None
    

async def generate_actionable_suggestion(llm_instance: Llama, user_query: str, failure_reason: str) -> Optional[str]:
    """
    Generates actionable suggestions for the user when the RAG system fails to find a direct answer.
    """
    llm_py_logger.info(f"Generating actionable suggestion for query: '{user_query}' due to: {failure_reason}")
    
    messages = get_suggestion_generation_messages(user_query, failure_reason)
    
    # 注意：这个函数生成的是自然语言，不需要 GBNF 约束，所以我们使用通用的 OpenAI API 格式调用。
    # 这里我们假设 `call_llm_via_openai_api_local_only` 内部最终会使用一个不需要 GBNF 的 Llama 实例，
    # 或者它是一个指向不同 LLM 服务的调用。为了保持当前架构，我们暂时不修改它。
    suggestion = await call_llm_via_openai_api_local_only(
        prompt=messages,
        temperature=0.7,
        max_new_tokens=512,
        task_type="suggestion_generation",
        user_query_for_log=user_query,
        model_name_for_log="qwen3_gguf_suggestion_gen"
    )

    if suggestion:
        cleaned_suggestion = re.sub(r"^(好的，|当然，|这里有一些建议：)\s*", "", suggestion.strip(), flags=re.IGNORECASE)
        return cleaned_suggestion
    
    return "您可以尝试换个问法，或检查相关文档是否已在知识库中。"


async def generate_expanded_queries(llm_instance: Llama, original_query: str) -> List[str]:
    """
    Expands a single user query into multiple related sub-queries to enhance retrieval coverage.
    Uses GBNF for reliable JSON output and caches the results.
    V2: Enhanced parsing to handle malformed JSON from the LLM.
    """
    llm_py_logger.info(f"Attempting to generate expanded queries for: '{original_query}'")
    
    from .rag_prompts import get_query_expansion_messages, V2_PLANNING_GBNF_SCHEMA 

    messages = get_query_expansion_messages(original_query)
    
    full_prompt = "".join([f"<|im_start|>{m['role']}\n{m['content']}<|im_end|>\n" for m in messages])
    full_prompt += "<|im_start|>assistant\n"

    llm_response_str = await call_local_llm_with_gbnf(
        llm_instance=llm_instance,
        full_prompt=full_prompt,
        grammar_str=V2_PLANNING_GBNF_SCHEMA,
        temperature=0.6,
        max_tokens=1024,
        task_type="query_expansion_gbnf",
        user_query_for_log=original_query
    )

    expanded_queries = []
    if llm_response_str:
        cleaned_response = llm_response_str.strip()
        try:
            parsed_data = json.loads(cleaned_response)
            
            if isinstance(parsed_data, list):
                expanded_queries = [q for q in parsed_data if isinstance(q, str)]
            elif isinstance(parsed_data, dict):
                # --- 新增的“特种手术”解析逻辑 ---
                # 尝试将字典的键作为JSON数组进行解析
                for key, value in parsed_data.items():
                    if isinstance(key, str) and key.strip().startswith('[') and key.strip().endswith(']'):
                        try:
                            # 找到了! 那个作为键的JSON数组字符串
                            potential_queries = json.loads(key)
                            if isinstance(potential_queries, list):
                                expanded_queries = [q for q in potential_queries if isinstance(q, str)]
                                llm_py_logger.info(f"Successfully extracted queries from a malformed JSON dictionary key.")
                                break # 找到就跳出循环
                        except json.JSONDecodeError:
                            continue # 这个键不是有效的JSON，继续检查下一个
                
                # 如果上述方法失败，尝试从常见的键中提取
                if not expanded_queries:
                    for key_option in ["queries", "sub_queries", "expanded_queries", "result"]:
                        if key_option in parsed_data and isinstance(parsed_data[key_option], list):
                            expanded_queries = parsed_data[key_option]
                            break
            
            if not expanded_queries:
                llm_py_logger.warning(f"Could not extract a list of strings from the parsed JSON: {parsed_data}")

        except (json.JSONDecodeError, TypeError) as e:
            llm_py_logger.error(f"Failed to decode JSON for query expansion: {cleaned_response}. Error: {e}")

    # 确保原始查询总是第一个
    final_queries = [original_query]
    for q in expanded_queries:
        # 确保不添加重复的查询
        if q.strip() and q.strip() not in final_queries:
            final_queries.append(q.strip())
    
    llm_py_logger.info(f"Final list of queries ({len(final_queries)} total, deduplicated): {final_queries}")
    return final_queries


async def generate_document_summary(llm_instance: Llama, user_query: str, document_content: str) -> str:
    """
    Generates a single, concise summary sentence for a document based on the user query.
    """
    llm_py_logger.info(f"Generating summary for document based on query: '{user_query[:50]}...'")
    
    messages = get_document_summary_messages(user_query, document_content)
    
    # 摘要任务是自然语言生成，不需要 GBNF
    summary = await call_llm_via_openai_api_local_only(
        prompt=messages,
        temperature=0.1, # 摘要需要精确，低温度
        max_new_tokens=150, # 限制输出长度
        stop_sequences=["\n", "。", "."], # 一句话结束就停止
        task_type="document_summary_generation",
        user_query_for_log=user_query
    )

    if summary and summary.strip().lower() != "irrelevant":
        return summary.strip()
    
    return "" # 返回空字符串表示不相关或生成失败


#### 
```

    |-- local_model_handler.py

``` py
# zhz_rag/llm/local_model_handler.py
# 版本: 简化版，不再处理多进程，仅用于定义 LlamaCppEmbeddingFunction

import os
import sys
import logging
from typing import List, Optional, Any, Sequence
import numpy as np
from cachetools import TTLCache
import asyncio

# --- 日志配置 ---
handler_logger = logging.getLogger("LocalModelHandler") # 日志名可以保持
if not handler_logger.hasHandlers():
    handler_logger.setLevel(logging.INFO)
    stream_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(name)s - PID:%(process)d - %(levelname)s - %(message)s')
    stream_handler.setFormatter(formatter)
    handler_logger.addHandler(stream_handler)
    handler_logger.propagate = False

# 为了避免与 core_rag 中的 LlamaCppEmbeddingFunction 混淆，
# 我们可以考虑重命名这个类，例如 MyModelHandlerForEmbeddings，
# 或者确保它的接口与 'LocalModelHandler' 类型提示兼容。
# 我们先保持类名，但确保它有 'embedding_model_path' 属性。
class LlamaCppEmbeddingFunction: # 这个类将作为 "model_handler"
    """
    一个与 Dagster 资源交互的嵌入函数包装器。
    它不直接创建模型，而是通过 GGUFEmbeddingResource 与工作进程通信。
    这个类将扮演 'LocalModelHandler' 的角色，被 core_rag 中的 LlamaCppEmbeddingFunction 使用。
    """
    def __init__(self, resource: Any, embedding_model_path_for_handler: Optional[str] = None): # resource 是 GGUFEmbeddingResource
        if resource is None:
            raise ValueError("GGUFEmbeddingResource is required.")
        self.resource = resource
        # CoreRetriever_LlamaCppEmbeddingFunction 期望 model_handler 有 embedding_model_path 属性
        self.embedding_model_path = embedding_model_path_for_handler if embedding_model_path_for_handler else os.getenv("EMBEDDING_MODEL_PATH")
        if not self.embedding_model_path:
             handler_logger.warning("embedding_model_path not provided to LocalModelHandler's LlamaCppEmbeddingFunction and not found in env. This might be an issue if downstream components expect it.")

        self._dimension: Optional[int] = None
        self._query_cache: TTLCache = TTLCache(maxsize=200, ttl=3600)
        self._cache_lock = asyncio.Lock()
        
        # 尝试在初始化时获取维度
        try:
            # 注意：resource.get_embedding_dimension() 是同步的，在异步 __init__ 中应小心
            # 但由于 __init__ 本身不是 async，这里直接调用是OK的
            # 如果 resource.get_embedding_dimension() 内部做了异步转同步，那也没问题
            dim = self.resource.get_embedding_dimension()
            if dim is not None:
                self._dimension = dim
                handler_logger.info(f"LocalModelHandler's LlamaCppEmbeddingFunction initialized. Dimension from resource: {self._dimension}")
            else:
                handler_logger.info("LocalModelHandler's LlamaCppEmbeddingFunction initialized. Dimension not immediately available from resource.")
        except Exception as e:
             handler_logger.warning(f"Error getting dimension from resource during init: {e}. Will fetch on first use.")


    async def __call__(self, input: Sequence[str]) -> List[List[float]]:
        if not input:
            return []
        handler_logger.info(f"LocalModelHandler's LlamaCppEmbeddingFunction: Generating embeddings for {len(input)} documents (via resource).")
        # 直接调用 Dagster 资源的 encode 方法
        # GGUFEmbeddingResource.encode 是同步包装的异步，所以 to_thread 是合适的
        embeddings = await asyncio.to_thread(self.resource.encode, list(input))
        return embeddings

    async def embed_documents(self, texts: Sequence[str]) -> List[List[float]]:
        return await self.__call__(list(texts))

    async def embed_query(self, text: str) -> List[float]:
        async with self._cache_lock:
            cached_result = self._query_cache.get(text)
        if cached_result is not None:
            handler_logger.info(f"Query Vector CACHE HIT for query (LocalModelHandler): '{text[:50]}...'")
            return cached_result
        
        handler_logger.info(f"Query Vector CACHE MISS for query (LocalModelHandler): '{text[:50]}...'. Generating new embedding.")
        embedding_list = await asyncio.to_thread(self.resource.encode, [text])
        
        if embedding_list and embedding_list[0]:
            embedding_vector = embedding_list[0]
            async with self._cache_lock:
                self._query_cache[text] = embedding_vector
            return embedding_vector
        
        dim = await self.get_dimension()
        return [0.0] * (dim or 1024) # Fallback to 1024 if dim is None

    def get_embedding_dimension(self) -> Optional[int]: # 改为同步，因为它在 __init__ 和 CoreRetriever 中被同步调用
        if self._dimension is None:
            try:
                dim_from_res = self.resource.get_embedding_dimension()
                if dim_from_res is not None:
                    self._dimension = dim_from_res
                    handler_logger.info(f"Dimension fetched from resource (sync): {self._dimension}")
            except Exception as e:
                handler_logger.error(f"Error fetching dimension from resource (sync): {e}")
        return self._dimension

    async def _get_embedding_dimension_from_worker_once(self) -> Optional[int]: # 辅助异步获取方法
         if self._dimension is None:
             try:
                 # GGUFEmbeddingResource.get_embedding_dimension() 是同步的
                 # 如果要在异步方法中调用，需要 to_thread
                 dim = await asyncio.to_thread(self.resource.get_embedding_dimension)
                 if dim is not None:
                     self._dimension = dim
                     handler_logger.info(f"Dimension fetched from resource (async helper): {self._dimension}")
             except Exception as e:
                 handler_logger.error(f"Error fetching dimension from resource (async helper): {e}")
         return self._dimension
```

    |-- rag_prompts.py

``` py
from typing import List, Dict, Any
# from zhz_rag.config.constants import NEW_KG_SCHEMA_DESCRIPTION


# 可以将 NO_ANSWER_PHRASE_ANSWER_CLEAN 也移到这里，或者从 constants.py 导入
NO_ANSWER_PHRASE_ANSWER_CLEAN = "根据目前提供的资料，我无法找到关于您问题的明确信息。" # 保持与 llm_interface.py 一致

def get_answer_generation_messages(user_query: str, context_str: str) -> List[Dict[str, str]]:
    """
    构建用于从上下文中生成答案的LLM输入messages。
    V3: 引入“元数据优先”的思维链，指导模型首先检查元数据，然后再分析文本内容。
    """
    system_prompt_for_answer = f"""
你是一个非常严谨、客观且专业的AI问答助手。你的核心任务是根据一份或多份【上下文信息】来回答【用户问题】。

**思维链 (Chain-of-Thought) 指导:**

1.  **理解问题**: 首先，完全理解【用户问题】的核心意图。问题是关于文档的内容，还是关于文档本身的属性（如作者、创建日期、文件名等）？

2.  **【元数据优先】检查**:
    *   遍历每一份【上下文信息】中的 `Source Document Metadata` JSON对象。
    *   判断【用户问题】是否能直接通过这些元数据字段（如 `filename`, `author`, `creation_date`, `last_modified` 等）来回答。
    *   **如果能**: 直接使用元数据中的信息来构建答案，并停止后续步骤。例如，如果用户问“作者是谁？”，而元数据中有`"author": "张三"`，则直接回答。

3.  **【文本内容】分析**:
    *   **如果元数据无法回答**: 仔细阅读每一份【上下文信息】中的 `Document Content` 部分。
    *   基于文本内容，综合分析并生成对【用户问题】的回答。

**核心指令与行为准则：**

*   **【绝对忠实于上下文】**: 你的回答【必须且只能】使用【上下文信息】（包括元数据和文本内容）中明确提供的文字和事实。严禁进行任何形式的推断、联想或引入外部知识。
*   **【处理无法回答的情况】**: 如果在元数据和文本内容中都找不到足够的信息来回答问题，请使用这个固定的句子开头：“{NO_ANSWER_PHRASE_ANSWER_CLEAN}”，并可以给出一句简短、有帮助的建议。
*   **【答案风格：专业、简洁】**: 直接针对用户问题，避免不必要的寒暄。

请严格遵循以上指令，以最高的准确性和忠实度来完成回答。
"""
    messages = [
        {"role": "system", "content": system_prompt_for_answer},
        {"role": "user", "content": f"用户问题: {user_query}\n\n上下文信息:\n{context_str}"}
    ]
    return messages


def get_clarification_question_messages(original_query: str, uncertainty_reason: str) -> List[Dict[str, str]]:
    """
    构建用于生成澄清问题的LLM输入messages。
    """
    system_prompt_for_clarification = f"""你的【唯一任务】是根据用户提供的【用户原始查询】和【不确定性原因】，生成一个【简洁、明确、友好且直接的澄清问句】。
    

**【严格的输出要求】**
* 你的【最终且唯一】的输出【必须】是这个澄清问句本身。
* 【绝对禁止】输出任何思考过程、解释、前缀、后缀或任何与澄清问句无关的文字。
* 澄清问句本身不应包含用户的原始查询或不确定性原因的复述。
/no_think


**示例：**

<example>
  <user_original_query>帮我查查天气</user_original_query>
  <uncertainty_reason>缺少地点信息</uncertainty_reason>
  <assistant_clarification_question>请问您想查询哪个城市的天气呢？</assistant_clarification_question>
</example>

<example>
  <user_original_query>分析一下销售数据</user_original_query>
  <uncertainty_reason>用户没有说明具体想对销售数据做什么操作，例如是汇总、筛选还是查找特定记录。</uncertainty_reason>
  <assistant_clarification_question>请问您希望对销售数据进行哪种具体操作，例如汇总统计、筛选特定条件，还是查找某些记录？</assistant_clarification_question>
</example>

<example>
  <user_original_query>给我推荐一些关于人工智能的书籍</user_original_query>
  <uncertainty_reason>用户没有说明偏好的人工智能子领域或书籍类型（入门/进阶/技术/哲学等）。</uncertainty_reason>
  <assistant_clarification_question>您对人工智能的哪个子领域或什么类型的书籍（如入门、技术实践、哲学探讨等）更感兴趣？</assistant_clarification_question>
</example>

<example>
  <user_original_query>我们公司的年假政策是怎么样的？</user_original_query>
  <uncertainty_reason>缺少公司名称，无法定位到具体的年假政策文档。</uncertainty_reason>
  <assistant_clarification_question>请问您的公司全称是什么？</assistant_clarification_question>
</example>

<example>
  <user_original_query>处理一下这个文件。</user_original_query>
  <uncertainty_reason>用户没有说明要对文件进行何种处理，也没有指明是哪个文件。</uncertainty_reason>
  <assistant_clarification_question>请问您希望对哪个文件进行什么具体操作呢？</assistant_clarification_question>
</example>
"""
    user_content = f"""用户原始查询: {original_query}
不确定性原因: {uncertainty_reason}

你应该输出的澄清问句:""" # 改为“澄清问句”

    messages = [
        {"role": "system", "content": system_prompt_for_clarification},
        {"role": "user", "content": user_content}
    ]
    return messages

# --- 精简的Cypher模板定义 (只保留一个核心模板) ---
# SIMPLIFIED_CYPHER_TEMPLATES = [
#     {
#         "id": "template_find_entity_attributes_by_text_label",
#         "description": "根据提供的实体文本和实体标签，查找该实体的所有基本属性。",
#         "template": "MATCH (n:ExtractedEntity {{text: $entity_text, label: $entity_label}}) RETURN n.text AS text, n.label AS label, n.id_prop AS id_prop LIMIT 1",
#         "params_needed": ["entity_text", "entity_label"]
#     }
# ]

# def get_cypher_generation_messages_with_templates(user_question: str) -> List[Dict[str, str]]: # 函数名保持一致
#     """
#     构建用于（基于【单个指定模板】）生成Cypher查询的LLM输入messages。
#     这个版本用于测试模型对单个模板的参数提取能力。
#     """
    
#     # 在这个测试版本中，我们假设总是使用第一个（也是唯一一个）模板
#     selected_template = SIMPLIFIED_CYPHER_TEMPLATES[0]
    
#     template_description_for_prompt = f"""你将使用以下Cypher查询模板：
# Template ID: {selected_template['id']}
# Description: {selected_template['description']}
# Cypher Structure: {selected_template['template']}
# Parameters Needed: {', '.join(selected_template['params_needed'])}
# """

#     system_prompt_for_cypher = f"""你是一个精确的参数提取助手。你的任务是根据用户问题，为下面提供的【唯一Cypher查询模板】提取参数，并构建一个Cypher查询。

# **【图谱Schema核心部分参考】**
# (你主要关注 `:ExtractedEntity` 节点及其属性: `text`, `label`, `id_prop`。其中 `label` 的常见值是 "PERSON", "ORGANIZATION", "TASK"。)
# {NEW_KG_SCHEMA_DESCRIPTION} 
# # ^^^ Schema描述已包含输出JSON格式 {{"status": "success/unable_to_generate", "query": "..."}} 的指导，请严格遵循该JSON输出格式。

# **【你的任务与输出要求】**
# 1.  仔细分析【用户问题】，理解其核心查询意图。
# 2.  判断该意图是否与提供的【当前需要填充的Cypher查询模板】描述相符。
# 3.  如果相符：
#     a.  从【用户问题】中提取填充该模板所需的所有【Parameters Needed】。确保参数值与Schema中的实体文本和标签格式相符（例如，标签应为大写 "PERSON", "ORGANIZATION", "TASK"）。
#     b.  将提取的参数值替换到模板的Cypher语句中（例如，`$entity_text` 替换为提取到的实体名）。
#     c.  最终输出一个JSON对象，格式为：`{{"status": "success", "query": "填充好参数的Cypher语句"}}`。
# 4.  如果不相符（例如，用户问题意图与模板描述不符，或无法从问题中提取到模板所需的所有关键参数）：
#     a.  最终输出一个JSON对象，格式为：`{{"status": "unable_to_generate", "query": "无法生成Cypher查询."}}`。
# 5.  【绝对禁止】输出任何除了上述指定JSON对象之外的文本、解释或思考过程。


# **【处理示例】**
# <example>
#   <user_question>我想知道张三的详细信息。</user_question>
#   <assistant_output_json>{{
#     "status": "success",
#     "query": "MATCH (n:ExtractedEntity {{text: '张三', label: 'PERSON'}}) RETURN n.text AS text, n.label AS label, n.id_prop AS id_prop LIMIT 1"
#   }}</assistant_output_json>
# </example>
# <example>
#   <user_question>项目Alpha的文档编写任务是什么？</user_question>
#   <assistant_output_json>{{
#     "status": "success",
#     "query": "MATCH (n:ExtractedEntity {{text: '项目alpha的文档编写任务', label: 'TASK'}}) RETURN n.text AS text, n.label AS label, n.id_prop AS id_prop LIMIT 1"
#   }}</assistant_output_json>
# </example>
# <example>
#   <user_question>法国的首都是哪里？</user_question>
#   <assistant_output_json>{{
#     "status": "unable_to_generate",
#     "query": "无法生成Cypher查询."
#   }}</assistant_output_json>
# </example>
# """
#     user_content = f"用户问题: {user_question}"

#     messages = [
#         {"role": "system", "content": system_prompt_for_cypher},
#         {"role": "user", "content": user_content}
#     ]
#     return messages

# --- 新增：实体与关系意图提取的提示词生成函数 ---
# def get_entity_relation_extraction_messages(user_question: str) -> List[Dict[str, str]]:
#     """
#     构建用于从用户查询中提取核心实体和关系意图的LLM输入messages。
#     目标是输出一个符合 ExtractedEntitiesAndRelationIntent Pydantic 模型结构的纯净JSON对象。
#     这个版本的Prompt极度强调JSON输出格式。
#     """
#     import re
#     match = re.search(r'label\s*:\s*STRING\s*\(实体类型。\s*允许的值\s*:\s*("([^"]+)"(?:,\s*"([^"]+)")*)\)', NEW_KG_SCHEMA_DESCRIPTION)
#     allowed_entity_labels_str = "PERSON, ORGANIZATION, TASK, DOCUMENT, PROJECT, REGION, PRODUCT, OTHER"
#     if match:
#         labels_group = match.group(1)
#         extracted_labels = re.findall(r'"([^"]+)"', labels_group)
#         if extracted_labels:
#             allowed_entity_labels_str = ", ".join(extracted_labels)
#             if "OTHER" not in extracted_labels:
#                 allowed_entity_labels_str += ", OTHER"

#     # --- V3 "最最严格" Prompt ---
#     system_prompt_for_entity_extraction = f"""<|im_start|>system
# USER_QUERY_TO_PROCESS:
# {user_question}

# TASK: Analyze USER_QUERY_TO_PROCESS. Output ONLY a valid JSON object.
# NO EXPLANATIONS. NO EXTRA TEXT. NO MARKDOWN. JUST JSON.

# JSON_OUTPUT_SCHEMA:
# {{
#   "entities": [
#     {{"text": "string, extracted entity text from USER_QUERY_TO_PROCESS", "label": "string, entity type from: [{allowed_entity_labels_str}], or OTHER"}}
#   ],
#   "relation_hint": "string, relation described in USER_QUERY_TO_PROCESS, or empty string"
# }}

# RULES:
# 1. Max 2 entities in "entities" array. If none, "entities" is `[]`.
# 2. "label" MUST be from the provided list or "OTHER".
# 3. If no relation_hint, value is `""`.
# 4. If USER_QUERY_TO_PROCESS yields no entities or relation, output: `{{"entities": [], "relation_hint": ""}}`

# YOUR_VALID_JSON_OUTPUT_ONLY:<|im_end|>""" # <--- 结尾引导更加直接

#     messages = [
#         {"role": "system", "content": system_prompt_for_entity_extraction}
#     ]
#     return messages


# =================================================================================================
# V2 - RAG Query Planner with Metadata Filtering Prompts
# =================================================================================================
V2_PLANNING_PROMPT_TEMPLATE = """
# 指令
你是一个专业的RAG查询规划专家。你的任务是分析用户的提问，并将其分解为一个结构化的JSON对象，该对象包含两个字段：`query` 和 `metadata_filter`。

## JSON结构说明
1.  `query` (字符串): 提炼出的核心搜索关键词。如果问题是关于文档的元数据（如作者、创建日期），这个字段可以是通用描述，如“文档元数据”。
2.  `metadata_filter` (JSON对象): 一个用于ChromaDB的`where`过滤器。
    - 可用字段: `filename`, `page_number`, `paragraph_type` ('text', 'table', 'title'), `author`。

## 示例
### 示例 1: 普通内容查询
用户提问: "RAG框架的核心优势是什么？"
AI输出:
```json
{{
    "query": "RAG框架的核心优势",
    "metadata_filter": {{}}
}}
### 示例 2: 带文件名和内容类型的复杂查询
用户提问: "给我看看'年度报告.pdf'第二章关于销售分析的表格"
AI输出:
{{
    "query": "销售分析 表格",
    "metadata_filter": {{
        "$and": [
            {{"filename": {{"$eq": "年度报告.pdf"}}}},
            {{"title_hierarchy_2": {{"$like": "%销售分析%"}}}},
            {{"paragraph_type": {{"$eq": "table"}}}}
        ]
    }}
}}
### 示例 3: 纯元数据查询 (新！)
用户提问: "complex_layout.docx的作者是谁？"
AI输出:
{{
    "query": "文档作者和贡献者信息",
    "metadata_filter": {{
        "filename": {{"$eq": "complex_layout.docx"}}
    }}
}}
### 用户问题
现在，请根据以下用户提问，生成对应的JSON对象。
用户提问: "{user_query}"
AI输出:
"""


# 用于约束规划器输出的GBNF Schema
V2_PLANNING_GBNF_SCHEMA = r'''
root   ::= object
value  ::= object | array | string | number | "true" | "false" | "null"
ws ::= ([ \t\n\r])*
object ::= "{" ws ( member ("," ws member)* )? ws "}"
member ::= string ws ":" ws value
array  ::= "[" ws ( value ("," ws value)* )? ws "]"
string ::= "\"" ( [^"\\\x7F\x00-\x1F] | "\\" ( ["\\/bfnrt] | "u" [0-9a-fA-F]{4} ) )* "\""
number ::= "-"? ([0-9] | [1-9] [0-9]*) ("." [0-9]+)? ([eE] [-+]? [0-9]+)?
'''

def get_table_qa_messages(user_query: str, context_str: str) -> List[Dict[str, str]]:
    """
    构建一个专门用于处理表格问答（Table-QA）的LLM输入messages。
    V4: 融合Qwen3官方文档的最佳实践，使用 /think 和 /no_think 标签精确控制模型行为。
    """
    system_prompt_for_table_qa = f"""
你是一个极其精确的Markdown表格数据提取专家。你的任务是严格遵循指令，为【用户问题】找到答案。

**指令:**

1.  **/think**
    *   **识别查询目标 (Identify Target):** 从【用户问题】“{user_query}”中，识别出**行标识**和**列名**。
    *   **扫描表格 (Scan Table):** 在【上下文信息】的表格中，找到**行标识**所在的那一行。
    *   **定位数值 (Locate Value):** 在该行中，找到**列名**对应的那一列，并提取其**单元格的值**。

2.  **/no_think**
    *   **如果成功找到值**: 使用模板 `"[行标识]的[列名]是[提取的值]。"` 来构建最终答案。
    *   **如果找不到**: 直接回答：“根据提供的表格，我无法找到关于'{user_query}'的信息。”

你的回答必须严格遵循先思考、后回答的格式，不要输出任何与最终答案无关的额外内容。
"""
    messages = [
        {"role": "system", "content": system_prompt_for_table_qa},
        {"role": "user", "content": f"用户问题: {user_query}\n\n上下文信息:\n{context_str}"}
    ]
    return messages

def get_suggestion_generation_messages(user_query: str, failure_reason: str) -> List[Dict[str, str]]:
    """
    构建用于在问答失败时生成智能建议的LLM输入messages。
    """
    system_prompt_for_suggestion = f"""
你是一个经验丰富、乐于助人且善于沟通的IT支持专家。你的任务是帮助一个因特定原因未能得到答案的用户。

**你的输入:**
1.  【用户原始问题】: 用户最初想问什么。
2.  【失败原因】: 系统为什么没能找到答案。

**你的任务:**
根据上述输入，生成一个简短、友好、包含**2-3个具体、可操作建议**的段落。这些建议应该能真正帮助“办公室电脑小白用户”解决问题。

**输出要求:**
*   **不要**复述“我找不到答案”这句话。你的输出将直接附加在这句话后面。
*   **不要**包含任何抱歉或客套话。直接给出建议。
*   建议必须具体且具有启发性。

**输出风格示例:**

*   **如果失败原因是“上下文信息不足”:**
    *   "您可以尝试换一种更宽泛的问法，或者检查一下您上传的《{'{document_name}'}》文件中是否确实包含了相关内容。"

*   **如果失败原因是“表格中找不到对应的行或列”:**
    *   "您可以核对一下问题中的实体名称（例如“产品B”）是否与表格中的完全一致，或者确认一下您想查询的列名（例如“价格”）是否存在于表格中。"

*   **如果失败原因是“检索结果为空”:**
    *   "这可能是因为知识库中还没有包含相关主题的文档。您可以尝试上传相关文件，或者调整一下问题的关键词，以便更好地匹配现有内容。"

请严格按照要求，生成有用的建议。
"""
    messages = [
        {"role": "system", "content": system_prompt_for_suggestion},
        {"role": "user", "content": f"【用户原始问题】: \"{user_query}\"\n\n【失败原因】: \"{failure_reason}\""}
    ]
    return messages


def get_query_expansion_messages(original_query: str) -> List[Dict[str, str]]:
    """
    构建用于将原始查询扩展为多个子问题的LLM输入messages。
    """
    system_prompt_for_expansion = """
你是一个专家级的查询分析师。你的任务是根据用户提供的【原始查询】，生成3个不同但相关的子问题，以探索原始查询的不同方面，从而帮助信息检索系统找到更全面、更深入的答案。

**输出要求:**
*   你的回答【必须】是一个JSON数组（列表），其中只包含字符串（子问题）。
*   【绝对禁止】输出任何除了这个JSON数组之外的文本、解释、对话标记或代码块。

**示例:**
【原始查询】: "介绍一下RAG技术及其在金融领域的应用"
【你的JSON输出】:
[
  "RAG技术的基本原理和核心组件是什么？",
  "RAG相比传统的模型微调有哪些优势和劣势？",
  "在金融领域，RAG技术有哪些具体的应用案例，例如风险评估或智能投顾？"
]
"""
    messages = [
        {"role": "system", "content": system_prompt_for_expansion},
        {"role": "user", "content": f"【原始查询】: \"{original_query}\""}
    ]
    return messages

def get_fusion_messages(original_query: str, fusion_context: str) -> List[Dict[str, str]]:
    """
    构建用于将多个子答案融合成一个最终报告的LLM输入messages。
    """
    system_prompt_for_fusion = """
你是一个顶级的【信息整合与报告撰写专家】。
你的任务是将一系列针对【原始问题】的【子问题与子答案】进行分析、整合、去重，并最终撰写成一份逻辑清晰、内容全面、专业且连贯的【最终报告】。

**核心指令:**

1.  **目标导向**: 你的【最终报告】必须直接、完整地回答【原始问题】。
2.  **信息来源**: 你【只能】使用【子问题与子答案】中提供的信息。严禁引入任何外部知识或进行不合理的推断。
3.  **整合与去重**: 将不同子答案中的相关信息进行逻辑上的连接和整合。如果多个子答案提到相同的事实，请在最终报告中只提及一次，避免重复。
4.  **结构化输出**: 如果内容复杂，请使用标题、列表（如 1., 2., ... 或 -）等方式来组织你的【最终报告】，使其易于阅读。
5.  **专业风格**: 保持客观、中立的语气。直接开始撰写报告内容，不要添加如“好的，这是您的报告”等多余的开场白。
6.  **处理矛盾/不足**: 如果提供的子答案信息不足以形成一份有意义的报告，或者信息之间存在明显矛盾，请直接回答“根据现有信息，无法就您的问题给出一个全面统一的答案。”

请现在基于以下信息，开始你的报告撰写工作。
"""
    
    user_content = f"""
【原始问题】:
{original_query}

【子问题与子答案】:
{fusion_context}

---
【你的最终报告】:
"""

    messages = [
        {"role": "system", "content": system_prompt_for_fusion},
        {"role": "user", "content": user_content}
    ]
    return messages


def get_document_summary_messages(user_query: str, document_content: str) -> List[Dict[str, str]]:
    """
    构建用于“为单个文档，针对用户问题，生成一句核心摘要”的LLM输入messages。
    """
    system_prompt_for_summary = f"""
你是一个高度专注的【信息摘要AI】。你的唯一任务是阅读一份【文档内容】，并根据【用户原始问题】，用一句话总结出该文档中与问题最相关的核心信息。

**核心指令:**

1.  **绝对相关**: 你的摘要【必须】直接回应【用户原始问题】。
2.  **绝对简洁**: 你的回答【只能】是一句话，不能超过50个字。
3.  **基于原文**: 你的摘要【必须】完全基于【文档内容】。
4.  **无相关信息处理**: 如果文档内容与用户问题完全不相关，请【直接且仅】输出字符串："irrelevant"

**示例 1:**
【用户原始问题】: "RAG的优势是什么？"
【文档内容】: "...RAG技术通过结合检索器和生成器，显著提升了答案的准确性和时效性，这是它相较于传统微调方法的核心优势..."
【你的输出】:
RAG技术的核心优势在于通过结合检索与生成，提升了答案的准确性和时效性。

**示例 2:**
【用户原始问题】: "介绍一下ACME公司的组织架构。"
【文档内容】: "...RAG技术通过结合检索器和生成器，显著提升了答案的准确性和时效性..."
【你的输出】:
irrelevant
"""
    
    user_content = f"""
【用户原始问题】:
{user_query}

【文档内容】:
{document_content}

---
【你的输出】:
"""

    messages = [
        {"role": "system", "content": system_prompt_for_summary},
        {"role": "user", "content": user_content}
    ]
    return messages
```

    |-- __init__.py

``` py

```

    |-- db_models.py

``` py
# zhz_agent/database_models.py
from sqlalchemy import Column, String, DateTime, Integer, Text, Enum as SQLAlchemyEnum, ForeignKey, Boolean, JSON
from sqlalchemy.sql import func
import uuid

# --- [修改] 从 pydantic_models 导入枚举 -> 改为绝对导入 ---
from zhz_rag.config.pydantic_models import TaskStatus, ReminderMethod

# --- [修改] 从新的 database.py 导入 Base -> 改为绝对导入 ---
from zhz_rag.utils.db_utils import Base # <--- 确保只从这里导入 Base #

class TaskDB(Base): # 命名为 TaskDB 以区分 Pydantic 的 TaskModel
    __tablename__ = "tasks"

    id = Column(String, primary_key=True, index=True, default=lambda: str(uuid.uuid4()))
    title = Column(String, index=True, nullable=False)
    description = Column(Text, nullable=True) #
    status = Column(SQLAlchemyEnum(TaskStatus), default=TaskStatus.PENDING, nullable=False) #
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False) #
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False) #
    due_date = Column(DateTime(timezone=True), nullable=True) #
    reminder_time = Column(DateTime(timezone=True), nullable=True) #
    reminder_offset_minutes = Column(Integer, nullable=True) #
    reminder_methods = Column(JSON, default=[ReminderMethod.NOTIFICATION.value], nullable=False) #
    priority = Column(Integer, default=0, nullable=False) #
    tags = Column(JSON, default=[], nullable=False) #
    action_type = Column(String, nullable=True) #
    action_payload = Column(JSON, default={}, nullable=True) #
    execution_result = Column(Text, nullable=True) #
    last_executed_at = Column(DateTime(timezone=True), nullable=True) #

    def __repr__(self):
        return f"<TaskDB(id={self.id}, title='{self.title}', status='{self.status.value}')>"
```

    |-- jobs.py

``` py
# zhz_agent/task_jobs.py
from datetime import datetime
from typing import Dict, Any
import os
import traceback
import httpx # <--- 确保 httpx 已导入
import json # <--- 确保 json 已导入

# 从 .database 导入 database 对象以便查询任务详情
# 从 .pydantic_models 导入 TaskModel 以便类型转换
# 从 .main 导入 scheduler 以便在需要时重新调度（虽然通常作业函数不直接操作调度器）
# 更好的做法是通过参数传递必要的信息，而不是依赖全局导入
WINDOWS_HOST_IP = os.getenv("WINDOWS_HOST_IP_FOR_WSL", "192.168.3.11") # <--- 请务必替换为您真实的Windows IP
LOCAL_AGENT_PORT = os.getenv("LOCAL_AGENT_PORT", "8003") # 与 local_agent_app.py 中的端口一致

# 如果 WINDOWS_HOST_IP 仍然是占位符，给出提示
if WINDOWS_HOST_IP == "在此处填写您上一步找到的Windows主机IP":
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("REMINDER_JOB WARNING: WINDOWS_HOST_IP 未正确设置在 task_jobs.py 中!")
    print("请编辑 task_jobs.py 文件，将 '在此处填写您上一步找到的Windows主机IP' 替换为实际IP地址。")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")

LOCAL_AGENT_NOTIFY_URL = f"http://{WINDOWS_HOST_IP}:{LOCAL_AGENT_PORT}/notify"

async def send_task_reminder(task_id: str, task_title: str, reminder_methods: list):
    """
    实际发送任务提醒的函数。
    """
    print(f"REMINDER_JOB: [{datetime.utcnow()}] 正在为任务 '{task_id}' - '{task_title}' 发送提醒。")
    for method in reminder_methods:
        if method == "notification": # 假设 ReminderMethod.NOTIFICATION.value 是 "notification"
            print(f"  REMINDER_JOB: 尝试通过 Local Agent 发送桌面通知: '{task_title}'")
            try:
                async with httpx.AsyncClient(timeout=10.0) as client:
                    response = await client.post(
                        LOCAL_AGENT_NOTIFY_URL,
                        json={"title": f"任务提醒: {task_title}", "message": f"任务 '{task_title}' 即将到期或需要关注。"}
                    )
                    response.raise_for_status() # Raise an exception for bad status codes
                    print(f"  REMINDER_JOB: 本地代理通知请求发送成功. 状态: {response.status_code}")
            except httpx.RequestError as e:
                print(f"  REMINDER_JOB: 通过本地代理发送通知失败 (RequestError): {e}")
                traceback.print_exc()
            except Exception as e:
                print(f"  REMINDER_JOB: 通过本地代理发送通知失败 (General Error): {e}")
                traceback.print_exc()
        # elif method == "email": #
        #     print(f"  REMINDER_JOB: 模拟发送邮件提醒...")

async def execute_task_action(task_id: str, action_type: str, action_payload: Dict[str, Any]):
    """
    实际执行任务动作的函数。
    """
    print(f"EXECUTION_JOB: [{datetime.utcnow()}] 正在为任务 '{task_id}' 执行动作 '{action_type}'。")
    print(f"  EXECUTION_JOB: 动作参数: {action_payload}")

    final_result = f"动作 '{action_type}' 已模拟执行。"
    success = True

    if action_type == "navigate":
        destination = action_payload.get("destination")
        if destination:
            print(f"  EXECUTION_JOB: 模拟导航到 '{destination}'...")
            final_result = f"已模拟为导航到 '{destination}' 准备好路线。"
        else:
            final_result = "导航动作失败：缺少目的地。"
            success = False
    elif action_type == "log_event":
        event_details = action_payload.get("event_details", "无详情")
        print(f"  EXECUTION_JOB: 记录事件: '{event_details}'")
        final_result = f"事件 '{event_details}' 已记录。"
    else:
        final_result = f"未知的动作类型: {action_type}"
        success = False

    # 更新数据库中的任务状态和结果 (需要访问数据库)
    # 这部分逻辑最好通过API调用或服务层来完成，以避免循环导入和分散DB操作
    # 这里我们只打印信息，实际应用中需要实现DB更新
    print(f"  EXECUTION_JOB: 任务 '{task_id}' 执行完毕。结果: {final_result}, 状态: {'COMPLETED' if success else 'FAILED'}")

```

    |-- generated_data/
    |-- __init__.py

``` py

```

    |-- refine_answer_data.py

``` py
# zhz_agent/refine_answer_finetune_data.py
import json
import os
import pandas as pd
from typing import List, Dict, Any, Optional
import glob
from datetime import datetime

# 假设 utils.py 和 constants.py 在同一个 zhz_agent 包内
try:
    from zhz_rag.utils.common_utils import (
    RAG_INTERACTION_LOGS_DIR,
    EVALUATION_RESULTS_LOGS_DIR,
    FINETUNING_GENERATED_DATA_DIR,
    find_latest_rag_interaction_log # 确保这个也被导入
)
    from zhz_rag.config.pydantic_models import RetrievedDocument
    # NO_ANSWER_PHRASE_ANSWER_CLEAN 将从 llm.py 导入，或者在constants.py中定义
    # 我们需要与 llm.py -> generate_answer_from_context 一致的 "无法回答" 短语
    from zhz_rag.llm.llm_interface import NO_ANSWER_PHRASE_ANSWER_CLEAN 
except ImportError as e:
    print(f"ERROR: Could not import necessary modules for refine_answer_finetune_data: {e}")
    exit(1)

import logging

# 配置此脚本的logger
refine_answer_logger = logging.getLogger("RefineAnswerFinetuneDataLogger")
refine_answer_logger.setLevel(logging.INFO)
if not refine_answer_logger.hasHandlers():
    _console_handler = logging.StreamHandler()
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _console_handler.setFormatter(_formatter)
    refine_answer_logger.addHandler(_console_handler)
    refine_answer_logger.info("--- RefineAnswerFinetuneDataLogger configured ---")

# --- 配置 ---
RAG_LOG_DIR = "zhz_rag/stored_data/evaluation_results_logs/"
EVAL_LOG_DIR = "zhz_rag/stored_data/evaluation_results_logs/"
FINETUNE_DATA_DIR = "zhz_rag/finetuning/generated_data/"
os.makedirs(FINETUNE_DATA_DIR, exist_ok=True)

# --- 与 run_batch_answer_evaluation.py 中类似的上下文格式化函数 ---
def format_contexts_for_prompt(context_docs_raw: List[Dict[str, Any]]) -> str:
    """
    将从日志中解析出的上下文文档列表格式化为单一字符串，用于构建LLM的输入Prompt。
    这个格式应该与 llm.py -> generate_answer_from_context 中构建上下文的方式一致。
    """
    context_strings_for_llm = []
    if not context_docs_raw:
        return "No context provided."
        
    for i, doc_data in enumerate(context_docs_raw):
        try:
            # 尝试使用RetrievedDocument模型解析，如果原始日志中已经是这个结构
            # 但通常日志中可能是字典列表
            doc_content = doc_data.get("content", "[Content not available]")
            doc_source = doc_data.get("source_type", "unknown_source")
            doc_score = doc_data.get("score")
            
            # 与 rag_service.py 中准备上下文给LLM的格式保持一致
            # 在 rag_service.py 中是:
            # f"Source Type: {doc.source_type}, Score: {doc.score:.4f}\nContent: {doc.content}"
            # 我们这里也尽量模拟，但日志中的score可能不存在或格式不同
            header = f"Source Type: {doc_source}"
            if doc_score is not None:
                try:
                    header += f", Score: {float(doc_score):.4f}"
                except ValueError:
                    header += f", Score: {doc_score}" # 如果分数不是数字，直接用原始值
            
            context_strings_for_llm.append(f"{header}\nContent: {doc_content}")

        except Exception as e:
            refine_answer_logger.warning(f"Could not parse a context document fully for prompt: {doc_data}. Error: {e}")
            content = doc_data.get("content", "[Content not available]")
            context_strings_for_llm.append(f"Content: {content}") # 简化版

    return "\n\n---\n\n".join(context_strings_for_llm) if context_strings_for_llm else "No context provided."


def construct_qwen_answer_input_prompt(user_question: str, formatted_context: str) -> str:
    """
    根据用户问题和格式化的上下文构建Qwen生成答案时的完整输入Prompt。
    这个函数必须与 llm.py 中 generate_answer_from_context 内部构建Prompt的逻辑完全一致。
    """
    # --- 从 llm.py 的 generate_answer_from_context 函数复制并粘贴完整的 prompt 模板 ---
    # 注意：这里需要确保模板与 llm.py 中的完全一致
    prompt = f"""
<|im_start|>system
你是一个AI问答助手。你的任务是根据【上下文信息】回答【用户问题】。

**核心指令：**

1.  **尝试直接回答：** 请首先仔细阅读【上下文信息】，如果其中包含能直接回答【用户问题】的内容，请用上下文中的信息直接、简洁地回答。
2.  **忠实原文：** 你的回答必须严格基于【上下文信息】，禁止加入任何外部知识或个人观点。
3.  **如果无法回答：** 如果你分析了【上下文信息】后，确认其中确实没有能回答【用户问题】的明确信息，那么请只回答以下这句话：
    "根据目前提供的资料，我无法找到关于您问题的明确信息。"
    **不要添加任何其他解释、建议或反问。**

**请直接给出答案，或者只给出上述那句固定的“无法找到信息”的回复。**
<|im_start|>user
用户问题: {user_question}

上下文信息:
{formatted_context}
<|im_end|>
<|im_start|>assistant
"""
    return prompt

def load_logs_to_dict(filepath: str, key_field: str = "interaction_id") -> Dict[str, Dict[str, Any]]:
    """将JSONL文件加载到一个以指定字段为键的字典中。"""
    data_dict = {}
    if not os.path.exists(filepath):
        refine_answer_logger.error(f"Log file not found: {filepath}")
        return data_dict
    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                log_entry = json.loads(line.strip())
                if key_field in log_entry and log_entry[key_field]: # 确保key_field的值不是None或空
                    data_dict[log_entry[key_field]] = log_entry
                elif key_field == "original_interaction_id_ref" and log_entry.get("original_interaction_id_ref"):
                    data_dict[log_entry["original_interaction_id_ref"]] = log_entry
            except json.JSONDecodeError:
                refine_answer_logger.warning(f"Skipping malformed JSON line in {filepath}")
    return data_dict

def generate_finetune_samples_for_answer(
    rag_interaction_logs: Dict[str, Dict[str, Any]],
    answer_evaluation_logs: Dict[str, Dict[str, Any]]
) -> List[Dict[str, str]]:
    finetune_samples = []
    processed_ids = set()

    refine_answer_logger.info(f"Processing {len(rag_interaction_logs)} RAG interaction logs and {len(answer_evaluation_logs)} Answer evaluation logs.")

    for interaction_id, rag_log in rag_interaction_logs.items():
        if rag_log.get("task_type") != "rag_query_processing_success":
            continue

        if interaction_id in processed_ids:
            continue
        processed_ids.add(interaction_id)

        user_question = rag_log.get("user_query")
        qwen_generated_answer_raw = rag_log.get("processed_llm_output") # Qwen的原始答案
        # retrieved_context_docs 在 rag_log 中可能是 "retrieved_context_docs" 或 "retrieved_documents_summary"
        # 我们需要原始的、完整的上下文文档
        retrieved_context_docs_raw = rag_log.get("retrieved_context_docs") 
        
        if not retrieved_context_docs_raw and rag_log.get("debug_info"): # 尝试从debug_info获取
             retrieved_context_docs_raw = rag_log.get("debug_info",{}).get("retrieved_context_docs")


        if qwen_generated_answer_raw is None or not qwen_generated_answer_raw.strip():
            qwen_generated_answer = NO_ANSWER_PHRASE_ANSWER_CLEAN # 空答案视为无法回答
        else:
            qwen_generated_answer = qwen_generated_answer_raw.strip()

        if not user_question or not retrieved_context_docs_raw:
            refine_answer_logger.warning(f"Skipping RAG log {interaction_id} due to missing user_question or retrieved_context_docs.")
            continue
        
        # 构建Prompt
        formatted_contexts_for_prompt = format_contexts_for_prompt(retrieved_context_docs_raw)
        qwen_answer_input_prompt = construct_qwen_answer_input_prompt(user_question, formatted_contexts_for_prompt)

        ideal_answer_output = None
        source_of_ideal = "unknown"
        gemini_scores_for_log = {}

        eval_log = answer_evaluation_logs.get(interaction_id)

        if eval_log and eval_log.get("eval_llm_processed_output_json"):
            eval_json = eval_log["eval_llm_processed_output_json"]
            summary_eval = eval_json.get("evaluation_summary", {})
            dimensions_eval = eval_json.get("dimensions", {})
            
            overall_score_str = summary_eval.get("overall_answer_quality_score")
            faithfulness_score_str = dimensions_eval.get("faithfulness", {}).get("score")
            relevance_score_str = dimensions_eval.get("relevance", {}).get("score")
            completeness_score_str = dimensions_eval.get("completeness", {}).get("score")
            context_sufficiency = dimensions_eval.get("completeness", {}).get("context_sufficiency_assessment", "Unknown")
            gemini_suggestion_answer = eval_json.get("suggestion_for_answer_improvement", "").strip()

            try:
                overall_score = int(overall_score_str) if overall_score_str is not None else 0
                faithfulness_score = int(faithfulness_score_str) if faithfulness_score_str is not None else 0
                relevance_score = int(relevance_score_str) if relevance_score_str is not None else 0
                completeness_score = int(completeness_score_str) if completeness_score_str is not None else 0
                gemini_scores_for_log = {
                    "overall": overall_score,
                    "faithfulness": faithfulness_score,
                    "relevance": relevance_score,
                    "completeness": completeness_score,
                    "context_sufficiency": context_sufficiency
                }
            except (ValueError, TypeError) as e:
                refine_answer_logger.warning(f"Could not parse one or more scores for {interaction_id}: {e}")
                overall_score = faithfulness_score = relevance_score = completeness_score = 0
                gemini_scores_for_log = { # 记录解析失败
                    "overall": "parse_error", "faithfulness": "parse_error", 
                    "relevance": "parse_error", "completeness": "parse_error",
                    "context_sufficiency": context_sufficiency
                }
                
            # --- Completion选择逻辑 (改进版) ---
            ideal_answer_output = None # 重新初始化
            source_of_ideal = "unknown" # 重新初始化

            # 规则 0: Qwen的原始答案就是标准的“无法回答”短语
            is_qwen_standard_no_answer = (qwen_generated_answer == NO_ANSWER_PHRASE_ANSWER_CLEAN)

            # 规则 1: 上下文不足，且Qwen正确地给出了标准的“无法回答”
            if is_qwen_standard_no_answer and \
               context_sufficiency == "Insufficient" and \
               overall_score >= 4: # Gemini认为Qwen的这个“无法回答”是高质量的
                ideal_answer_output = NO_ANSWER_PHRASE_ANSWER_CLEAN
                source_of_ideal = "qwen_standard_no_answer_confirmed_by_gemini_context_insufficient"
            
            # 规则 2: 上下文不足，Qwen可能没有给出标准“无法回答”，但Gemini建议应指出信息不足
            elif not is_qwen_standard_no_answer and \
                 context_sufficiency == "Insufficient" and \
                 completeness_score <=2 and \
                 ("information is not available" in gemini_suggestion_answer.lower() or \
                  "context does not contain" in gemini_suggestion_answer.lower() or \
                  "cannot be answered from the context" in gemini_suggestion_answer.lower() or \
                  "should state that the information is not found" in gemini_suggestion_answer.lower()):
                ideal_answer_output = NO_ANSWER_PHRASE_ANSWER_CLEAN
                source_of_ideal = "gemini_suggests_no_answer_due_to_insufficient_context"

            # 规则 3: Gemini 整体评分很高 (例如 overall, faithfulness, relevance 都 >= 4)
            # 并且 Qwen 的答案不是标准的“无法回答”（如果已经是，则由规则1处理）
            elif not is_qwen_standard_no_answer and \
                 overall_score >= 4 and faithfulness_score >= 4 and relevance_score >= 4:
                ideal_answer_output = qwen_generated_answer
                source_of_ideal = "qwen_high_score_by_gemini"
                # 如果此时 Gemini 仍有改进建议，可以额外标记
                if gemini_suggestion_answer and \
                   gemini_suggestion_answer != "No improvement needed." and \
                   "suggestion" not in source_of_ideal: # 避免重复标记
                    source_of_ideal += "_with_minor_gemini_suggestion"


            # 规则 4: Qwen的答案评分不高，但Gemini给出了具体的改进建议
            # 我们将这类样本标记出来，completion暂时使用Qwen的答案，供人工审核和优化
            elif overall_score < 4 and \
                 gemini_suggestion_answer and \
                 gemini_suggestion_answer != "No improvement needed." and \
                 len(gemini_suggestion_answer) > 10: # 假设太短的建议可能不具体
                ideal_answer_output = qwen_generated_answer # 保留Qwen答案作为基础
                source_of_ideal = "qwen_low_score_with_gemini_suggestion_for_review"
                refine_answer_logger.info(f"Answer log {interaction_id} (Qwen: '{qwen_generated_answer[:100]}...') marked for review due to low score but has Gemini suggestion: '{gemini_suggestion_answer[:100]}...'")
            
            # 规则 5: 如果Qwen的答案是标准“无法回答”，但上下文其实是充分的，或者Gemini认为可以回答
            # 这通常意味着Qwen可能错误地判断无法回答，或者Gemini的评估与Qwen的判断不一致
            elif is_qwen_standard_no_answer and \
                 (context_sufficiency == "Sufficient" or (context_sufficiency == "Partially Sufficient" and completeness_score >=3)) and \
                 overall_score < 4 : # Gemini不认可这个“无法回答”
                ideal_answer_output = qwen_generated_answer # 保留Qwen的“无法回答”
                source_of_ideal = "qwen_no_answer_but_gemini_disagrees_or_context_sufficient_for_review"
                refine_answer_logger.info(f"Answer log {interaction_id}: Qwen said 'no answer', but Gemini scores/context sufficiency suggest it might be answerable. Marked for review. Gemini scores: {gemini_scores_for_log}, Suggestion: '{gemini_suggestion_answer[:100]}...'")

            # 规则 6: 其他所有情况，暂时跳过，等待更明确的规则或人工审核
            else:
                refine_answer_logger.info(f"Answer log {interaction_id} (Qwen: '{qwen_generated_answer[:100]}...') did not meet current finetune criteria. Needs manual review or rule adjustment. Gemini scores: {gemini_scores_for_log}, Suggestion: '{gemini_suggestion_answer[:100]}...'")
                continue

        else: # 没有有效的Gemini评估日志
            refine_answer_logger.warning(f"No valid Gemini evaluation found for Answer log {interaction_id}. Qwen's output: '{qwen_generated_answer[:100]}...'. Skipping for finetune data.")
            continue
            
        if ideal_answer_output is not None:
            finetune_samples.append({
                "prompt": qwen_answer_input_prompt,
                "completion": ideal_answer_output.strip(),
                "original_qwen_answer": qwen_generated_answer_raw.strip() if qwen_generated_answer_raw else NO_ANSWER_PHRASE_ANSWER_CLEAN, # 记录Qwen最原始的输出
                "gemini_scores": gemini_scores_for_log,
                "gemini_suggestion": gemini_suggestion_answer if eval_log and eval_log.get("eval_llm_processed_output_json") else None,
                "source_of_ideal": source_of_ideal,
                "interaction_id": interaction_id
            })

    refine_answer_logger.info(f"Generated {len(finetune_samples)} Answer finetuning samples.")
    return finetune_samples


if __name__ == "__main__":
    rag_log_file = find_latest_rag_interaction_log(RAG_INTERACTION_LOGS_DIR)
    
    eval_log_file = None
    if rag_log_file:
        rag_log_basename = os.path.basename(rag_log_file)
        date_str_match = "".join(filter(str.isdigit, rag_log_basename))
        if len(date_str_match) >= 8:
            date_str = date_str_match[:8]
            evaluation_name = "answer_gemini_flash" # 与 evaluation.py 中一致
            eval_file_name = f"eval_results_{evaluation_name}_{date_str}.jsonl"
            eval_log_file = os.path.join(EVAL_LOG_DIR, eval_file_name)
            refine_answer_logger.info(f"Attempting to load Answer evaluation results from: {eval_log_file}")
        else:
            refine_answer_logger.error(f"Could not reliably extract date from RAG log filename: {rag_log_basename}")

    if not rag_log_file or not eval_log_file or not os.path.exists(eval_log_file):
        refine_answer_logger.error("Required log files for answer finetune data generation not found. Exiting.")
    else:
        rag_interactions = load_logs_to_dict(rag_log_file, key_field="interaction_id")
        answer_evaluations = load_logs_to_dict(eval_log_file, key_field="original_interaction_id_ref")

        if rag_interactions and answer_evaluations:
            finetune_data = generate_finetune_samples_for_answer(rag_interactions, answer_evaluations)
            
            if finetune_data:
                today_for_filename = datetime.now().strftime("%Y%m%d")
                output_filepath = os.path.join(FINETUNING_GENERATED_DATA_DIR, f"answer_finetune_samples_{today_for_filename}.jsonl")
                
                with open(output_filepath, 'w', encoding='utf-8') as f_out:
                    for sample in finetune_data:
                        f_out.write(json.dumps(sample, ensure_ascii=False) + "\n")
                refine_answer_logger.info(f"Successfully saved {len(finetune_data)} Answer finetuning samples to: {output_filepath}")
                
                try:
                    df = pd.DataFrame(finetune_data)
                    csv_output_filepath = os.path.join(FINETUNING_GENERATED_DATA_DIR, f"answer_finetune_samples_review_{today_for_filename}.csv")
                    df.to_csv(csv_output_filepath, index=False, encoding='utf-8-sig')
                    refine_answer_logger.info(f"Reviewable CSV for answers saved to: {csv_output_filepath}")
                except Exception as e_csv:
                    refine_answer_logger.error(f"Failed to save answer review CSV: {e_csv}")
            else:
                refine_answer_logger.info("No answer finetuning samples were generated.")
        else:
            refine_answer_logger.error("Failed to load data from log files for answer finetuning.")
```

    |-- refine_cypher_data.py

``` py
# zhz_agent/refine_cypher_finetune_data.py
import json
import os
import pandas as pd
from typing import List, Dict, Any, Optional, Tuple
import glob
from datetime import datetime

# 假设 utils.py 和 constants.py 在同一个 zhz_agent 包内
try:
    from zhz_rag.utils.common_utils import get_interaction_log_filepath, get_evaluation_result_log_filepath, find_latest_rag_interaction_log # <--- 修改这里
    from zhz_rag.config.constants import NEW_KG_SCHEMA_DESCRIPTION
except ImportError as e:
    print(f"ERROR: Could not import necessary modules: {e}")
    # ... (错误处理)
    exit(1)

import logging

# 配置此脚本的logger
refine_logger = logging.getLogger("RefineFinetuneDataLogger")
refine_logger.setLevel(logging.INFO)
if not refine_logger.hasHandlers():
    _console_handler = logging.StreamHandler()
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _console_handler.setFormatter(_formatter)
    refine_logger.addHandler(_console_handler)
    refine_logger.info("--- RefineFinetuneDataLogger configured ---")

# --- 配置 ---
# 原始RAG交互日志的目录 (包含cypher_generation类型)
RAG_LOG_DIR = "zhz_rag/stored_data/rag_interaction_logs/"
# Gemini评估结果日志的目录
EVAL_LOG_DIR = "zhz_rag/stored_data/evaluation_results_logs/"
# 输出微调数据文件的目录
FINETUNE_DATA_DIR = "zhz_rag/finetuning/generated_data/"
os.makedirs(FINETUNE_DATA_DIR, exist_ok=True)


def load_logs_to_dict(filepath: str, key_field: str = "interaction_id") -> Dict[str, Dict[str, Any]]:
    """将JSONL文件加载到一个以指定字段为键的字典中。"""
    data_dict = {}
    if not os.path.exists(filepath):
        refine_logger.error(f"Log file not found: {filepath}")
        return data_dict
    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                log_entry = json.loads(line.strip())
                if key_field in log_entry:
                    data_dict[log_entry[key_field]] = log_entry
                # 对于评估日志，我们可能需要用 original_interaction_id_ref 作为键
                elif key_field == "original_interaction_id_ref" and log_entry.get("original_interaction_id_ref"):
                    data_dict[log_entry["original_interaction_id_ref"]] = log_entry
            except json.JSONDecodeError:
                refine_logger.warning(f"Skipping malformed JSON line in {filepath}")
    return data_dict

def construct_qwen_input_prompt(user_question: str, schema_description: str) -> str:
    """
    根据用户问题和Schema描述构建Qwen生成Cypher时的完整输入Prompt。
    这个函数应该与 llm.py 中 generate_cypher_query 内部构建Prompt的逻辑一致。
    """
    # 这是我们在 llm.py -> generate_cypher_query 中使用的Prompt模板
    # 我们需要确保这里的模板与Qwen实际接收到的一致
    # 注意：这里使用了最新的V7版本（或您当前使用的版本）的Schema描述作为基础
    # 如果您的 generate_cypher_query 中的模板不同，请相应调整
    prompt = f"""<|im_start|>system
你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。

**【核心指令与约束 - 必须严格遵守！】**

1.  **【Schema绝对绑定 - 最高优先级】**:
    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 "知识图谱Schema描述" 中。
    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**
    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**
    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。

2.  **【纯净输出格式 - 严格要求】**:
    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。
    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**
    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。

3.  **【属性与值的使用】**:
    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。
    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。

4.  **【查询构建逻辑指引】**:
    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。
    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。
    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。
    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。
    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。
    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。

**【知识图谱Schema描述】**:
{schema_description}

**【查询示例 - 严格基于上述Schema】**:

*   用户问题: "张三参与了哪个项目？"
    Cypher查询: MATCH (p:Person {{name: '张三'}})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName

*   用户问题: "华东区域2024年第一季度的销售额是多少？"
    Cypher查询: MATCH (r:Region {{name: '华东'}})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {{period: '2024年第一季度'}}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit

*   用户问题: "查询所有产品的名称。"
    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName

*   用户问题: "项目X有哪些人参与？"
    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {{name: '项目X'}}) RETURN p.name AS participantName

*   用户问题: "2024年第一季度所有区域的总销售额是多少？"
    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {{period: '2024年第一季度'}}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 
    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)

*   用户问题: "与新产品A相关的文档ID是什么？"
    Cypher查询: MATCH (p:Product {{name: '新产品A'}})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId

*   用户问题: "公司CEO是谁？" (假设Schema中没有CEO信息)
    Cypher查询: 无法生成Cypher查询。

现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。
<|im_end|>
<|im_start|>user
用户问题: {user_question}
<|im_end|>
<|im_start|>assistant
"""
    return prompt

def generate_finetune_samples_for_cypher(
    rag_interaction_logs: Dict[str, Dict[str, Any]],
    cypher_evaluation_logs: Dict[str, Dict[str, Any]]
) -> List[Dict[str, str]]:
    """
    根据原始交互日志和Gemini评估日志，生成用于Cypher微调的样本。
    返回一个列表，每个元素是 {"prompt": "...", "completion": "..."}
    """
    finetune_samples = []
    processed_ids = set()

    refine_logger.info(f"Processing {len(rag_interaction_logs)} RAG interaction logs and {len(cypher_evaluation_logs)} Cypher evaluation logs.")

    for interaction_id, rag_log in rag_interaction_logs.items():
        if rag_log.get("task_type") != "cypher_generation":
            continue

        if interaction_id in processed_ids:
            continue
        processed_ids.add(interaction_id)

        user_question = rag_log.get("user_query")
        qwen_generated_cypher_raw = rag_log.get("processed_llm_output") # 这是Qwen原始输出

        # --- 改进点: 处理Qwen输出为空或仅包含空白的情况 ---
        if qwen_generated_cypher_raw is None or not qwen_generated_cypher_raw.strip():
            qwen_generated_cypher = "无法生成Cypher查询." # 将空输出也视为无法生成
            refine_logger.info(f"Interaction {interaction_id}: Qwen output was empty/None, treating as '无法生成Cypher查询.'.")
        else:
            qwen_generated_cypher = qwen_generated_cypher_raw.strip()


        qwen_input_prompt = rag_log.get("llm_input_prompt")
        if not qwen_input_prompt:
            if user_question:
                qwen_input_prompt = construct_qwen_input_prompt(user_question, NEW_KG_SCHEMA_DESCRIPTION)
            else:
                refine_logger.warning(f"Skipping Cypher log {interaction_id} due to missing user_question for prompt reconstruction.")
                continue
        
        if not user_question: # qwen_generated_cypher 已确保非None
            refine_logger.warning(f"Skipping Cypher log {interaction_id} due to missing user_question.")
            continue

        ideal_cypher_output = None
        source_of_ideal = "unknown"
        gemini_score_for_log = None # 用于记录

        eval_log = cypher_evaluation_logs.get(interaction_id)

        if eval_log and eval_log.get("eval_llm_processed_output_json"):
            eval_json = eval_log["eval_llm_processed_output_json"]
            overall_score_str = eval_json.get("evaluation_summary", {}).get("overall_quality_score_cypher")
            gemini_suggestion_raw = eval_json.get("suggestion_for_improvement_cypher", "").strip()
            
            try:
                overall_score = int(overall_score_str)
                gemini_score_for_log = overall_score
            except (ValueError, TypeError):
                refine_logger.warning(f"Could not parse overall_quality_score_cypher for {interaction_id}: {overall_score_str}")
                overall_score = 0 # 默认给个低分
                gemini_score_for_log = 0

            # --- 规则1: Qwen自己就说无法生成 ---
            if qwen_generated_cypher == "无法生成Cypher查询.":
                # 如果Gemini也认为无法生成或评分低，那么采纳
                if "无法生成Cypher查询" in gemini_suggestion_raw or overall_score <= 2:
                    ideal_cypher_output = "无法生成Cypher查询."
                    source_of_ideal = "qwen_and_gemini_cannot_generate"
                # 如果Qwen说无法生成，但Gemini给出了高分建议，这很奇怪，需要人工看
                elif overall_score >=4 and "MATCH" in gemini_suggestion_raw.upper():
                     refine_logger.info(f"Cypher log {interaction_id}: Qwen said '无法生成', but Gemini suggested a high-score query '{gemini_suggestion_raw}'. Needs manual review.")
                     continue
                else: # Qwen说无法生成，Gemini建议不明确或中低分，也采纳Qwen的
                    ideal_cypher_output = "无法生成Cypher查询."
                    source_of_ideal = "qwen_cannot_generate_gemini_unclear"


            # --- 规则2: Qwen生成了查询，看Gemini评估 ---
            elif overall_score >= 4: # Gemini认为Qwen的输出质量高
                ideal_cypher_output = qwen_generated_cypher
                source_of_ideal = "qwen_high_score_by_gemini"

            
            # --- 规则3: Qwen的查询质量不高，但Gemini给出了具体的、看起来像Cypher的建议 ---
            elif gemini_suggestion_raw and \
                "无法生成Cypher查询" not in gemini_suggestion_raw and \
                "cannot be improved" not in gemini_suggestion_raw.lower() and \
                "needs to be extended" not in gemini_suggestion_raw.lower() and \
                ("MATCH " in gemini_suggestion_raw.upper() or \
                    "RETURN " in gemini_suggestion_raw.upper() or \
                    "CREATE " in gemini_suggestion_raw.upper() or \
                    "MERGE " in gemini_suggestion_raw.upper() or \
                    "WITH " in gemini_suggestion_raw.upper() or \
                    "OPTIONAL MATCH " in gemini_suggestion_raw.upper()
                ):

                # 简化处理：直接将 Gemini 的原始建议作为 completion 的候选
                # 清洗工作主要交给人工审核阶段
                # 我们仍然可以做非常基础的清理，比如首尾空格和常见的 markdown
                
                temp_completion = gemini_suggestion_raw.strip()
                if temp_completion.startswith("```") and temp_completion.endswith("```"):
                    temp_completion = temp_completion[3:-3].strip()
                    if temp_completion.lower().startswith("cypher"):
                        temp_completion = temp_completion[len("cypher"):].strip()
                elif temp_completion.startswith("`") and temp_completion.endswith("`"):
                    temp_completion = temp_completion[1:-1].strip()

                # 只要建议中包含核心Cypher关键字，我们就认为它有价值被审核
                core_cypher_keywords_check = ["MATCH", "RETURN", "CREATE", "MERGE", "WITH", "OPTIONAL MATCH"]
                suggestion_contains_cypher_keyword = False
                if temp_completion:
                    for core_keyword in core_cypher_keywords_check:
                        if core_keyword in temp_completion.upper():
                            suggestion_contains_cypher_keyword = True
                            break
                
                if suggestion_contains_cypher_keyword:
                    ideal_cypher_output = temp_completion # 使用初步清理后的建议
                    source_of_ideal = "gemini_suggestion_for_review" # 明确标记为需要审核
                    refine_logger.info(f"Interaction {interaction_id}: Gemini suggestion adopted for review. Raw: '{gemini_suggestion_raw[:150]}...', Processed for completion: '{ideal_cypher_output[:150]}...'")
                else:
                    refine_logger.warning(f"Interaction {interaction_id}: Gemini suggestion '{gemini_suggestion_raw[:150]}...' did not appear to contain core Cypher keywords after basic cleaning. Skipping.")
                    continue

            
            # --- 规则4: Gemini明确建议“无法生成” 或 Qwen的查询质量低且有严重问题 ---
            elif "无法生成Cypher查询" in gemini_suggestion_raw or \
                 (overall_score <= 2 and ("hallucinated" in eval_log.get("eval_llm_raw_output", "").lower() or \
                                         "schema violation" in eval_log.get("eval_llm_raw_output", "").lower() or \
                                         "syntax error" in eval_log.get("eval_llm_raw_output", "").lower())):
                ideal_cypher_output = "无法生成Cypher查询."
                source_of_ideal = "gemini_explicitly_cannot_generate_or_qwen_low_quality"
            
            # --- 规则5: 其他情况，需要人工审核 ---
            else:
                refine_logger.info(f"Cypher log {interaction_id} (Qwen: '{qwen_generated_cypher[:100]}...') needs manual review. Gemini score: {overall_score}, Suggestion: '{gemini_suggestion_raw[:100]}...'")
                continue 
        
        # --- 如果没有Gemini评估日志 ---
        else:
            refine_logger.warning(f"No valid Gemini evaluation found for Cypher log {interaction_id}. Qwen's output: '{qwen_generated_cypher[:100]}...'. Skipping for finetune data.")
            continue
            
        if ideal_cypher_output is not None:
            finetune_samples.append({
                "prompt": qwen_input_prompt,
                "completion": ideal_cypher_output.strip(), # 确保completion也strip
                "original_qwen_cypher": qwen_generated_cypher,
                "gemini_score": gemini_score_for_log,
                "source_of_ideal": source_of_ideal,
                "interaction_id": interaction_id
            })

    refine_logger.info(f"Generated {len(finetune_samples)} Cypher finetuning samples.")
    return finetune_samples


if __name__ == "__main__":
    # 1. 确定要处理的原始RAG交互日志文件 (包含cypher_generation)
    #    和对应的Gemini评估结果日志文件 (包含cypher_evaluation_result)
    
    # 自动查找最新的原始RAG交互日志
    rag_log_file = find_latest_rag_interaction_log(RAG_LOG_DIR) # utils.py中的函数
    
    # 构造对应的Gemini Cypher评估结果文件名
    # 假设评估文件名与原始日志文件名日期部分相同，且评估类型固定
    eval_log_file = None
    if rag_log_file:
        rag_log_basename = os.path.basename(rag_log_file)
        date_str_match = "".join(filter(str.isdigit, rag_log_basename)) # 提取文件名中的日期部分
        if len(date_str_match) >= 8: # 确保提取到至少YYYYMMDD
            date_str = date_str_match[:8]

            # 根据 evaluation.py 中 log_interaction_data 的 evaluation_name_for_file 参数构造
            evaluation_name = "cypher_gemini_flash" 
            eval_file_name = f"eval_results_{evaluation_name}_{date_str}.jsonl"
            
            eval_log_file = os.path.join(EVAL_LOG_DIR, eval_file_name)
            refine_logger.info(f"Attempting to load Cypher evaluation results from: {eval_log_file}")
        else:
            refine_logger.error(f"Could not reliably extract date from RAG log filename: {rag_log_basename}")
    
    if not rag_log_file or not eval_log_file or not os.path.exists(eval_log_file):
        refine_logger.error("Required log files not found. Exiting.")
        if not rag_log_file: refine_logger.error(f"RAG interaction log missing (expected pattern rag_interactions_*.jsonl in {RAG_LOG_DIR})")
        if rag_log_file and (not eval_log_file or not os.path.exists(eval_log_file)): refine_logger.error(f"Cypher evaluation result log missing (expected: {eval_log_file})")
    else:
        rag_interactions = load_logs_to_dict(rag_log_file, key_field="interaction_id")
        cypher_evaluations = load_logs_to_dict(eval_log_file, key_field="original_interaction_id_ref")

        if rag_interactions and cypher_evaluations:
            finetune_data = generate_finetune_samples_for_cypher(rag_interactions, cypher_evaluations)
            
            if finetune_data:
                # 获取当前日期用于文件名
                today_for_filename = datetime.now().strftime("%Y%m%d")
                output_filepath = os.path.join(FINETUNE_DATA_DIR, f"cypher_finetune_samples_{today_for_filename}.jsonl")
                
                with open(output_filepath, 'w', encoding='utf-8') as f_out:
                    for sample in finetune_data:
                        f_out.write(json.dumps(sample, ensure_ascii=False) + "\n")
                refine_logger.info(f"Successfully saved {len(finetune_data)} Cypher finetuning samples to: {output_filepath}")
                
                # 也可以同时保存一个CSV版本供人工审查
                try:
                    df = pd.DataFrame(finetune_data)
                    csv_output_filepath = os.path.join(FINETUNE_DATA_DIR, f"cypher_finetune_samples_review_{today_for_filename}.csv")
                    df.to_csv(csv_output_filepath, index=False, encoding='utf-8-sig')
                    refine_logger.info(f"Reviewable CSV saved to: {csv_output_filepath}")
                except Exception as e_csv:
                    refine_logger.error(f"Failed to save review CSV: {e_csv}")
            else:
                refine_logger.info("No finetuning samples were generated.")
        else:
            refine_logger.error("Failed to load data from log files.")
```

        |-- answer_finetune_samples_20250531.jsonl
        |-- answer_finetune_samples_review_20250531.csv
        |-- cypher_finetune_samples_20250531.jsonl
        |-- cypher_finetune_samples_review_20250531.csv
    |-- bm25_index/
    |-- chromadb_index/
    |-- evaluation_results_logs/
    |-- rag_interaction_logs/
    |-- __init__.py

``` py

```

        |-- rag_interactions_20250619.jsonl
        |-- rag_interactions_20250620.jsonl
        |-- rag_interactions_20250621.jsonl
        |-- eval_results_answer_gemini_flash_20250621.jsonl
        |-- 69b9f987-7d66-4aad-8090-c2a3a0fac67c/
        |-- chroma.sqlite3
            |-- data_level0.bin
            |-- header.bin
            |-- index_metadata.pickle
            |-- length.bin
            |-- link_lists.bin
        |-- data.csc.index.npy
        |-- doc_ids.pkl
        |-- indices.csc.index.npy
        |-- indptr.csc.index.npy
        |-- params.index.json

``` json
{
    "k1": 1.5,
    "b": 0.75,
    "delta": 0.5,
    "method": "lucene",
    "idf_method": "lucene",
    "dtype": "float32",
    "int_dtype": "int32",
    "num_docs": 46417,
    "version": "0.2.13",
    "backend": "numpy"
}
```

        |-- vocab.index.json

``` json
{"ex":0,"Low":1,"jective":2,"visually":3,"modernized":4,"Colloquially":5,"Words":6,"hasattr":7,"boxes1":8,"Unseen":9,"lib64":10,"seg":11,"check":12,"insidiously":13,"zx":14,"Cooling":15,"tables":16,"Discussions249":17,"BioNeMo":18,"receivable":19,"02210":20,"194":21,"183416":22,"MultivariateNormal":23,"Vanden":24,"jump":25,"lw":26,"440":27,"Founda":28,"portant":29,"very":30,"PLAINER":31,"requirement":32,"turning":33,"stakes":34,"CNNs":35,"后":36,"Melissa":37,"counter":38,"01":39,"unsecured":40,"propel":41,"Dhariwal":42,"outstanding":43,"Geoff":44,"Rung":45,"Terminating":46,"materials":47,"fraud":48,"67":49,"exercisability":50,"Removal":51,"forward":52,"434":53,"ViT":54,"timization":55,"posts":56,"Communication":57,"Owner":58,"Kulkarni":59,"ln1":60,"shrinking":61,"Inception":62,"diverse":63,"ample":64,"InProgress":65,"Export":66,"superseded":67,"cloze":68,"employees":69,"populations":70,"chained":71,"Gregory":72,"Liabilities":73,"internalize":74,"244":75,"studies":76,"ranks":77,"announce":78,"minimally":79,"024":80,"assistance":81,"Smallcap":82,"Mann":83,"promoted":84,"0.299":85,"Boxcar":86,"exec":87,"TransformerDecoderBlock":88,"integrating":89,"applicable":90,"ignore":91,"FMA":92,"Grave":93,"gentle":94,"gelu":95,"A.34":96,"cancel":97,"Alon":98,"beating":99,"boiler":100,"fluidly":101,"publicly":102,"payroll":103,"imations":104,"combinatorial":105,"Nominees":106,"Network":107,"alently":108,"illus":109,"knew":110,"8598":111,"Hundreds":112,"dive":113,"unless":114,"revised":115,"exemplified":116,"dependently":117,"Lightning":118,"、":119,"Neurobiologically":120,"compatible":121,"805":122,"下面":123,"jroberayalas":124,"hindering":125,"blocking":126,"exited":127,"gains":128,"tradeoffs":129,"San":130,"Barriers":131,"equilibrates":132,"INT4":133,"651K":134,"DCASE":135,"requests":136,"Biomedical":137,"Arm":138,"overparametrized":139,"Reds":140,"mutu":141,"traded":142,"lenpred":143,"Exequity":144,"slopes":145,"SquareRootScheduler":146,"ToPILImage":147,"discretized":148,"actual":149,"ineffectiveness":150,"semantically":151,"coercing":152,"Composition":153,"Interfaith":154,"Requirement":155,"378":156,"satisfy":157,"NRauschmayr":158,"denial":159,"Basics":160,"Nominating":161,"welfare":162,"parents":163,"738":164,"where":165,"Fran":166,"inbox":167,"1114831485450576":168,"812":169,"nonetheless":170,"degrades":171,"9912422":172,"controlling":173,"1028":174,"inversion":175,"voice":176,"prominence":177,"Trustee":178,"downturns":179,"Multitask":180,"formalize":181,"incapable":182,"13.06%":183,"6583":184,"338":185,"dropout2":186,"562":187,"Discussions216":188,"baseball":189,"misconduct":190,"PositiveDefiniteTransform":191,"credit":192,"12317":193,"C0":194,"01116":195,"global":196,"puts":197,"CA":198,"128":199,"suppres":200,"independent":201,"Laskin":202,"cartoons":203,"extensive":204,"packed":205,"lengths":206,"combines":207,"Replacing":208,"870":209,"putation":210,"July":211,"int64":212,"switches":213,"walking":214,"essential":215,"instructive":216,"tuition":217,"satis":218,"exploring":219,"residual":220,"in":221,"Densely":222,"Highlights":223,"stechnik":224,"Disagreements":225,"0.91":226,"stage":227,"Tu":228,"2223":229,"4284":230,"ACTIVERAG":231,"trieved":232,"Petton":233,"manipulations":234,"页脚":235,"samples":236,"1570":237,"donations":238,"join":239,"acc":240,"English":241,"fell":242,"Discussions228":243,"commencing":244,"ska":245,"Amodei":246,"Children":247,"Hui":248,"Genegpt":249,"amd64":250,"Interlocks":251,"Golmant":252,"involvement":253,"990":254,"trigrams":255,"maturities":256,"capital":257,"vkramdev":258,"Better":259,"barring":260,"monotonically":261,"MobileNet":262,"rejections":263,"originate":264,"by":265,"enhancement":266,"York":267,"LeakyReLU":268,"Interspeech":269,"timeframes":270,"matters":271,"Increasing":272,"investigated":273,"trips":274,"CBR":275,"pavelkomarov":276,"Barth":277,"0.99":278,"Climate":279,"threatened":280,"Value":281,"snli":282,"返回":283,"Cap":284,"reputational":285,"proprietary":286,"regime":287,"aerial":288,"asymptotically":289,"620":290,"configurable":291,"timize":292,"bmm":293,"Radosavovic":294,"0.001":295,"flexibilty":296,"ended":297,"folio63":298,"3.4":299,"Bunke":300,"319":301,"emergent":302,"gkutiel":303,"authors":304,"twice":305,"akash5474":306,"Multilayer":307,"contrastive":308,"Cost":309,"Searching":310,"size":311,"experience":312,"1602":313,"159662":314,"Town":315,"mathresearch":316,"Rink":317,"W3":318,"retaliatory":319,"Hai":320,"Decaf":321,"aspect":322,"Chunk":323,"develops":324,"15.1":325,"depth":326,"qualitative":327,"fractional":328,"preprocessing":329,"gas":330,"Tvqa":331,"ATMs":332,"Interfaces":333,"forfeited":334,"boot":335,"teaches":336,"0.608":337,"907":338,"writing":339,"Sequential":340,"Adagrad":341,"addnorm2":342,"Receives":343,"kxxt":344,"comparisons":345,"1030":346,"311":347,"iterators":348,"Stretch":349,"EWMA":350,"Siciliano":351,"guardrail":352,"affordable":353,"Hybridization":354,"pendencies":355,"dense1":356,"deletion":357,"just":358,"Indianapolis":359,"desc":360,"vention":361,"Pair":362,"v4":363,"07554":364,"TPAT":365,"3251":366,"Medical":367,"P3dn":368,"printoptions":369,"incompatible":370,"probs":371,"optim":372,"such":373,"boasts":374,"kumaraswamy":375,"saddled":376,"indx":377,"searchers":378,"Jay":379,"𝜸":380,"earn":381,"Initializing":382,"getitem":383,"Memberships":384,"2235":385,"Bud":386,"meticulous":387,"rates":388,"distinguishing":389,"Baptista":390,"CPU":391,"RAT":392,"RNNs":393,"tems":394,"cinematic":395,"dropped":396,"quick":397,"Lab":398,"inquiries":399,"Ying":400,"Identity":401,"subtracts":402,"caliber":403,"Doll":404,"sequential":405,"photorealistic":406,"productive":407,"Lai":408,"Daylight":409,"ReACT":410,"Sentence":411,"authoritative":412,"ting":413,"parame":414,"unigram":415,"locate":416,"darts":417,"Circuit":418,"l2":419,"unconstrained":420,"derivative":421,"Liu":422,"conflicts":423,"prev":424,"Lehrwerk":425,"Competitive":426,"PythonBackend":427,"materializing":428,"modeling":429,"R1":430,"kvpairs":431,"Institute":432,"finitely":433,"1042":434,"NSP":435,"electronics":436,"organize":437,"jacket":438,"0.0975":439,"imple":440,"output":441,"reliable":442,"works":443,"eigendecomposition":444,"RETRO":445,"scales":446,"1st":447,"Cer":448,"bits":449,"informed":450,"进入":451,"enqueued":452,"0.0360":453,"mouse":454,"recovery":455,"tween":456,"amendment":457,"Unlimiformer":458,"Needs":459,"election":460,"prepositions":461,"translate":462,"Rasmussen":463,"complex128":464,"2969":465,"devices":466,"Adriaan":467,"craft":468,"851":469,"011548051321691994":470,"1995":471,"speed":472,"chine":473,"626":474,"engagement":475,"Iteration":476,"Awards":477,"rural":478,"𝑍":479,"thereof":480,"believes":481,"85":482,"Track":483,"B.3":484,"4th":485,"4039":486,"supplies":487,"beginning":488,"Per":489,"852":490,"Declaration":491,"861":492,"Hidden":493,"alities":494,"respirator":495,"neurons":496,"Peng":497,"chapeter":498,"21776":499,"itself":500,"virtualshareholdermeeting":501,"BlueField":502,"Terry":503,"Reduce":504,"parameterized":505,"penalties":506,"Objective":507,"Tree":508,"destabilizing":509,"Semiconductor":510,"Sigma":511,"logging":512,"Defects":513,"rics":514,"Efros":515,"construction":516,"housing":517,"misclassify":518,"bird":519,"Revisiting":520,"rescaling":521,"Suggest":522,"-------":523,"994":524,"rejected":525,"pku":526,"多行":527,"Gevers":528,"Luu":529,"trun":530,"Decreases":531,"Heavily":532,"949":533,"Contracts":534,"Describing":535,"he":536,"al":537,"EmbeddingBackward0":538,"261541":539,"Albert":540,"1958":541,"portrait":542,"chapters":543,"taking":544,"Even":545,"reduction":546,"300d":547,"img":548,"ridge":549,"tem":550,"X2":551,"8000":552,"0.8635":553,"contrast":554,"extraction":555,"adjusting":556,"unprac":557,"Notebooks":558,"nonpara":559,"perturbations":560,"keep":561,"333":562,"Ave":563,"Partners":564,"principles":565,"seconds":566,"assembly":567,"Axiomatic":568,"banana":569,"87":570,"eventual":571,"wasteful":572,"theoretic":573,"covariograms":574,"Gaurav":575,"shrinks":576,"Sande":577,"04333":578,"amounts":579,"MT":580,"ICCV":581,"7944855690002441":582,"Huskies":583,"READSUM":584,"reuses":585,"font":586,"noisiness":587,"885":588,"predeter":589,"cheat":590,"criterion":591,"Millican":592,"After":593,"else":594,"Zipf":595,"II":596,"exchanged":597,"Gonzalez":598,"18":599,"Query2doc":600,"Let":601,"coronavirus":602,"promotes":603,"-------------":604,"interactions":605,"07641":606,"uniformly":607,"backward":608,"transitioned":609,"Ti":610,"Ran":611,"686":612,"Cartesian":613,"entangled":614,"Correspondingly":615,"Lee":616,"feat":617,"Vicente":618,"nu":619,"conjunction":620,"JJ":621,"Settlement":622,"Refer":623,"8080":624,"ymin":625,"5552":626,"chasing":627,"cars":628,"primary":629,"line":630,"BASHEXPLAINER":631,"catastroph":632,"ESPP":633,"MUST":634,"SliceBackward0":635,"archived":636,"nxby":637,"overflowing":638,"underpowered":639,"autoregressively":640,"Walker":641,"slew":642,"focal":643,"01846559300690354":644,"Firm":645,"reflect":646,"someone":647,"Hailin":648,"consumes":649,"Non":650,"onerous":651,"comparably":652,"407285":653,"Qin":654,"Orthopedist":655,"turbing":656,"Withholding":657,"motherboards":658,"axvline":659,"chi2":660,"facilitated":661,"E2":662,"1044":663,"Bastien":664,"buffer":665,"Host":666,"spell":667,"Latino":668,"MulBackward0":669,"Belonging":670,"Dividends":671,"第二":672,"moderating":673,"lenses":674,"布局":675,"Solving":676,"Cisco":677,"914":678,"Equation":679,"conversational":680,"Deployment":681,"delivered":682,"Bias":683,"axioms":684,"mechanisms":685,"Among":686,"synonyms":687,"Putting":688,"Prolificdreamer":689,"Stacking":690,"Giorn":691,"9114":692,"fail":693,"paired":694,"stem":695,"guided":696,"3311":697,"route":698,"lin2":699,"3430e":700,"supplied":701,"需求":702,"slippery":703,"PolyScheduler":704,"Alessandro":705,"summarizing":706,"Anguelov":707,"curtain":708,"drop":709,"07630":710,"disclosures":711,"sequent":712,"Capital":713,"Timing":714,"add":715,"Credit":716,"Queue":717,"along":718,"hvN":719,"Our":720,"Keutzer":721,"continu":722,"Weirdly":723,"recap":724,"TDNNs":725,"Schmid":726,"Convention":727,"Founders":728,"getargvalues":729,"64MB":730,"weakness":731,"Character":732,"753":733,"Either":734,"utilizes":735,"maturity":736,"Finardi":737,"R":738,"Cortes":739,"681%":740,"unranked":741,"trades":742,"preferential":743,"stacking":744,"Abadi":745,"Discussions257":746,"291":747,"disconnected":748,"ere":749,"selec":750,"Cover":751,"03000":752,"Messrs":753,"StevenJokes":754,"abstracts":755,"soon":756,"50th":757,"bug":758,"voc":759,"intrinsic":760,"averages":761,"apply":762,"automatically":763,"affiliated":764,"penalized":765,"conflict":766,"Reed":767,"Ravi":768,"normal":769,"derivation":770,"holds":771,"Brendel":772,"ahmaurya":773,"designation":774,"3.486784":775,"condi":776,"Specif":777,"textual":778,"gumbel":779,"lem":780,"cable":781,"Schuhmann":782,"34019846567238493":783,"generations":784,"RBFKernel":785,"Rong":786,"Relevance":787,"Tokenization":788,"Bear":789,"likened":790,"TIME":791,"Yin":792,"cap":793,"oranges":794,"Distributing":795,"negatively":796,"virtual":797,"169":798,"disgorgement":799,"denotes":800,"01933":801,"experimented":802,"transformations":803,"watching":804,"DRAM":805,"RTRL":806,"appropriateness":807,"photos":808,"decreasing":809,"sessing":810,"brettkoonce":811,"v0":812,"7470":813,"05313":814,"model88":815,"Further":816,"Mirhoseini":817,"u202f":818,"866":819,"hy":820,"BSEE":821,"formulation":822,"Russia":823,"Acquired":824,"dataloader":825,"Gamers":826,"Illustration":827,"计划":828,"excep":829,"dirichlet":830,"185":831,"Train":832,"ney":833,"coordinated":834,"Stockholders":835,"0.162":836,"appreciate":837,"creates":838,"Administers":839,"validated":840,"esoteric":841,"Tokenize":842,"contracting":843,"bayes":844,"9182":845,"converged":846,"signi":847,"11708":848,"Alexey":849,"060":850,"bly":851,"starters":852,"468":853,"giants":854,"ﬄ":855,"Unions":856,"eig":857,"Get":858,"28%":859,"Uszkoreit":860,"alternating":861,"racial":862,"2X":863,"18450":864,"circumstance":865,"Nogueira":866,"diffu":867,"losses":868,"failed":869,"2330":870,"Roberts":871,"Pricing":872,"compartmentalizes":873,"textualized":874,"instances300":875,"0.35":876,"stand":877,"0.1":878,"提升":879,"retrievable":880,"variables":881,"avatars":882,"establishing":883,"Learing":884,"lesser":885,"Alokla":886,"tailor":887,"446":888,"wentao":889,"digitalization":890,"2308":891,"adminis":892,"sors":893,"2023b":894,"Baidu":895,"672":896,"Vision":897,"governments":898,"Flamingo":899,"Regulation":900,"beach":901,"dived":902,"Deng":903,"330":904,"vn09":905,"664":906,"wished":907,"Unims":908,"smarter":909,"audited":910,"outlay":911,"A100":912,"Advising":913,"899922":914,"186":915,"Poodles":916,"dubbed":917,"infor":918,"initialize":919,"obtained":920,"13%":921,"parameters":922,"Invertibility":923,"trol":924,"Promotion":925,"approves":926,"gently":927,"nyi":928,"Reinvent":929,"Truncate":930,"0437":931,"𝐿":932,"Will":933,"0.0015":934,"Gardner":935,"Locally":936,"Line":937,"Discussions317":938,"witnessed":939,"senior":940,"cosine":941,"differs":942,"Ubuntu":943,"litigation":944,"Notes":945,"attacks":946,"0.6930":947,"clipping":948,"disproportionate":949,"178":950,"volatility":951,"trimming":952,"modifying":953,"rbfkernel":954,"political":955,"Associated":956,"bolded":957,"Ingredient":958,"hess":959,"Chinese":960,"problems":961,"leveraging":962,"horses":963,"Qualifying":964,"Lopez":965,"31":966,"Sawarkar":967,"quad":968,"0.248":969,"Kalman":970,"SIMD":971,"Skip":972,"genfromtxt":973,"926":974,"tooling":975,"Rtlfixer":976,"nothing":977,"28881":978,"rate":979,"leases":980,"ated":981,"vibration":982,"Observations":983,"ordinate":984,"su":985,"formulating":986,"c1":987,"sized":988,"Context":989,"HUANG":990,"reshaping":991,"Riesenhuber":992,"whip":993,"mes":994,"streamline":995,"Insert":996,"StackTransform":997,"Stores":998,"thumbs":999,"L3":1000,"Tips":1001,"725821":1002,"good":1003,"Gammon":1004,"arrangements":1005,"med":1006,"integers":1007,"carbon":1008,"𝑑":1009,"partnership":1010,"January":1011,"into":1012,"0.96":1013,"70%":1014,"Class":1015,"Extension":1016,"91":1017,"278":1018,"milestone":1019,"identities":1020,"gamers":1021,"also":1022,"Optional":1023,"OrderedDict":1024,"allies":1025,"admit":1026,"aim":1027,"Secondly":1028,"StoppingCriterion":1029,"199":1030,"concatenation":1031,"61":1032,"provides":1033,"detection":1034,"centred":1035,"conve":1036,"tokenizes":1037,"unusual":1038,"species":1039,"float32":1040,"WE":1041,"cash":1042,"Kahl":1043,"P5":1044,"amarazov":1045,"learnable":1046,"boom":1047,"2402":1048,"Box":1049,"cultural":1050,"CoVe":1051,"Discussions159":1052,"subject":1053,"Robert":1054,"PaLM":1055,"ond":1056,"onto":1057,"Fine":1058,"dur":1059,"inited":1060,"Artif":1061,"sibly":1062,"rack":1063,"Retrieved":1064,"origi":1065,"Sindhwani":1066,"plumbing":1067,"Load":1068,"Asai":1069,"megawatts":1070,"programming":1071,"salaries":1072,"salut":1073,"contextual":1074,"optimal":1075,"192":1076,"corpora":1077,"users":1078,"pivots":1079,"Uncer":1080,"fitness":1081,"America":1082,"corre":1083,"inspiration":1084,"1804":1085,"Priors":1086,"decorate":1087,"Compress":1088,"cd":1089,"Exupery":1090,"Quotient":1091,"transported":1092,"9979e":1093,"rons":1094,"Discussions233":1095,"Cars":1096,"honorary":1097,"famous":1098,"Likewise":1099,"0000001":1100,"Ideas":1101,"broadcasts":1102,"princi":1103,"NeurIPS":1104,"2869":1105,"Fur":1106,"034":1107,"Which":1108,"watches":1109,"Bhagavatula":1110,"Sand":1111,"reorder":1112,"Incep":1113,"error":1114,"1805.2267129073316":1115,"recommendation":1116,"adjacent":1117,"args":1118,"cleaning":1119,"GPs":1120,"Reacc":1121,"12.10":1122,"350W":1123,"Bookkeeping":1124,"CoCoMic":1125,"influences":1126,"mization":1127,"publicity":1128,"tFig":1129,"G":1130,"LogSoftmax":1131,"1B":1132,"4.5":1133,"15556":1134,"unhappy":1135,"fuel":1136,"consultants":1137,"enables":1138,"compensated":1139,"sublayers":1140,"organized":1141,"til":1142,"Declassified":1143,"01717":1144,"382563":1145,"question":1146,"8582.0341796875":1147,"twelve":1148,"thrill":1149,"dead":1150,"6008":1151,"Salut":1152,"kilometer":1153,"connec":1154,"inhibition":1155,"projects":1156,"Test":1157,"covariances":1158,"2.8290698237936858":1159,"Location":1160,"Accounts":1161,"unscrupulous":1162,"parison":1163,"Duc":1164,"ptimization":1165,"disciplinary":1166,"性能":1167,"on":1168,"643":1169,"emphasizing":1170,"Pathway":1171,"outmoded":1172,"17780":1173,"802":1174,"hh":1175,"HARVEY":1176,"Azure":1177,"MARK":1178,"√":1179,"06864":1180,"distillation":1181,"6.2":1182,"procedural":1183,"reciprocal":1184,"822":1185,"Rouder":1186,"nonlinear":1187,"modelling":1188,"MacArthur":1189,"unanticipated":1190,"preoccupy":1191,"12":1192,"Extended":1193,"7545":1194,"InfiniBand":1195,"Senior":1196,"Ellis":1197,"picked":1198,"NEOs":1199,"interface":1200,"A.3":1201,"241":1202,"tances":1203,"service":1204,"Titan":1205,"shoulder":1206,"hybrid":1207,"895":1208,"Driver":1209,"readers":1210,"War":1211,"LAB":1212,"controller":1213,"mobile":1214,"rep":1215,"Settlements":1216,"later":1217,"Convert":1218,"differentiable":1219,"transformation":1220,"0.7089":1221,"restriction":1222,"Ponwitayarat":1223,"lelism":1224,"wins":1225,"overseeing":1226,"subsequent":1227,"Career":1228,"916":1229,"11th":1230,"downsample":1231,"proposals":1232,"adver":1233,"rough":1234,"recover":1235,"monly":1236,"dilutive":1237,"771699":1238,"Hutter":1239,"therefore":1240,"organizations":1241,"wrong":1242,"Keskar":1243,"428":1244,"inferior":1245,"cedures":1246,"BCB":1247,"Smoothing":1248,"198":1249,"Geometry":1250,"Cie":1251,"Args":1252,"appoints":1253,"Cyberspace":1254,"inherent":1255,"component":1256,"setting":1257,"Pillow53":1258,"executions":1259,"Coordinating":1260,"wikipedia":1261,"copy":1262,"Tuning":1263,"broadcasting":1264,"nominating":1265,"resnet34":1266,"Products":1267,"copying":1268,"Country":1269,"prone":1270,"convenience":1271,"097":1272,"Morozov":1273,"trigonometry":1274,"mydict2":1275,"utilizing":1276,"values":1277,"Consolidated":1278,"layman":1279,"abstrac":1280,"delve":1281,"Considering":1282,"3c914d17d80b1459be871a5039ac23e752a53cbe":1283,"2681":1284,"pseudocode":1285,"Chairman":1286,"1500":1287,"end2end":1288,"convert":1289,"blunt":1290,"strives":1291,"296042":1292,"sometimes":1293,"crite":1294,"GQA":1295,"Diagnostic":1296,"deliberately":1297,"233":1298,"manages":1299,"coverage":1300,"realistic":1301,"4728":1302,"Scoring":1303,"distilling":1304,"Levy":1305,"entering":1306,"nor":1307,"及其":1308,"247":1309,"Overfitting":1310,"1806":1311,"counteract":1312,"nel":1313,"1065":1314,"2171":1315,"actively":1316,"offers":1317,"devote":1318,"≈":1319,"nevertheless":1320,"1966":1321,"resize":1322,"orientation":1323,"21501725.47":1324,"tic":1325,"jancio":1326,"bestows":1327,"burdensome":1328,"original":1329,"05310":1330,"Jassy":1331,"variances":1332,"knack":1333,"446396":1334,"reminder":1335,"guaranteeing":1336,"Quadratic":1337,"acquire":1338,"kbqa":1339,"squashes":1340,"Singular":1341,"brokers":1342,"badly":1343,"10997":1344,"continuing":1345,"boosting":1346,"areas2":1347,"primed":1348,"proximate":1349,"Git":1350,"decoders":1351,"cooling":1352,"risks":1353,"Lagrangian":1354,"IDs":1355,"错误处理":1356,"16137":1357,"Discussions288":1358,"Wxr":1359,"Three":1360,"gather":1361,"729":1362,"StudentT":1363,"touch":1364,"access":1365,"gorgeous":1366,"Industry":1367,"refine":1368,"Byrne":1369,"darker":1370,"Elementwise":1371,"cpu":1372,"validity":1373,"wind":1374,"Pretrained":1375,"embraced":1376,"1607":1377,"optics":1378,"48":1379,"scarce":1380,"----------":1381,"aligning":1382,"taxing":1383,"experiencing":1384,"Objectives":1385,"723":1386,"accompany":1387,"reserved":1388,"erator":1389,"seems":1390,"dart":1391,"sponse":1392,"asset":1393,"understandable":1394,"131072":1395,"posited":1396,"499":1397,"Discussions115":1398,"Identify":1399,"walls":1400,"964542":1401,"microscope":1402,"9038":1403,"flattened":1404,"Reducing":1405,"rethinking":1406,"x86":1407,"infringement":1408,"lihood":1409,"retainer":1410,"13.6":1411,"slots":1412,"Garry":1413,"casual":1414,"She":1415,"Decoupling":1416,"convincing":1417,"remarkable":1418,"Qualitative":1419,"037703019195187606":1420,"unvested":1421,"Parallel":1422,"configuring":1423,"selection":1424,"5228":1425,"560":1426,"legions":1427,"567":1428,"hierarchical":1429,"hurdles":1430,"holder":1431,"accompanied":1432,"Xiaoting":1433,"3":1434,"arithmetic":1435,"METHODOLOGIES":1436,"06317157191455719":1437,"deep":1438,"Investigate":1439,"handy":1440,"m":1441,"rungs":1442,"thrilling":1443,"parametriza":1444,"Election":1445,"buck":1446,"overshoot":1447,"Stewart":1448,"Hard":1449,"constituent":1450,"geographic":1451,"chips":1452,"fool":1453,"pointwise":1454,"interpolated":1455,"pack":1456,"endorse":1457,"Discussions95":1458,"structured":1459,"recov":1460,"xmin":1461,"contains":1462,"927":1463,"nowadays":1464,"chairs":1465,"fires":1466,"undetected":1467,"lists":1468,"uration":1469,"nations":1470,"powering":1471,"wildfire":1472,"Mutex":1473,"graphical":1474,"guaranteed":1475,"Tables":1476,"334":1477,"Ron":1478,"了":1479,"HGX":1480,"valuing":1481,"test274":1482,"prepaid":1483,"Dokl":1484,"t":1485,"Bergstra":1486,"sourcing":1487,"Initialize":1488,"trajectory":1489,"bursting":1490,"unobserved":1491,"A":1492,"0130":1493,"Niu":1494,"pictures":1495,"combining":1496,"however":1497,"broker":1498,"JPEG":1499,"disputes":1500,"Rule":1501,"AI":1502,"13547":1503,"Sketch":1504,"vehicles":1505,"flux":1506,"16.2":1507,"COM":1508,"willing":1509,"roots":1510,"ci":1511,"ATTN":1512,"LinearRegressionScratch":1513,"here":1514,"07339":1515,"Economic":1516,"restoring":1517,"sparing":1518,"ultimately":1519,"Volinsky":1520,"1101":1521,"0cb91d09b814ecdc07b50f31f8dcad3e81d6a86d":1522,"noisy":1523,"149425":1524,"Things":1525,"repository299":1526,"barrier":1527,"attracted":1528,"⟨":1529,"protected":1530,"og":1531,"BatchNorm2d":1532,"GPU":1533,"Armin":1534,"vast":1535,"Sys":1536,"2b2":1537,"fifo":1538,"reshuffle":1539,"Minibatch":1540,"factorial":1541,"9645419978270817":1542,"自动":1543,"Inferfix":1544,"opti":1545,"j":1546,"3D":1547,"sequently":1548,"reconstruction":1549,"Dwork":1550,"games":1551,"nonsensical":1552,"Ohm":1553,"executable":1554,"allude":1555,"MSEE":1556,"Andrew":1557,"EfficientNet":1558,"Versus":1559,"upload":1560,"harmonizing":1561,"hoonose":1562,"registration":1563,"sume":1564,"2988":1565,"974":1566,"MM":1567,"Fall":1568,"separates":1569,"benchmarks":1570,"11246":1571,"Zettlemoyer":1572,"Assembly":1573,"surprise":1574,"allowances":1575,"Yavuz":1576,"locations":1577,"BiGRU":1578,"inputs":1579,"Waabi":1580,"lifting":1581,"Advisors":1582,"exam":1583,"dress":1584,"fa":1585,"complied":1586,"nils":1587,"Interpreting":1588,"Construction":1589,"arms":1590,"routines":1591,"Influence":1592,"common":1593,"Jong":1594,"partners":1595,"hands":1596,"1GB":1597,"barely":1598,"CLS":1599,"ancestors":1600,"5267":1601,"cyberneticists":1602,"Tensilica":1603,"Israeli":1604,"sensitive":1605,"generating":1606,"MaskedSoftmaxCELoss":1607,"obvi":1608,"2%":1609,"laser":1610,"1898":1611,"discipline":1612,"normally":1613,"simulation":1614,"btae075":1615,"observing":1616,"True":1617,"offices":1618,"Labour":1619,"harmonized":1620,"abstractly":1621,"next1":1622,"public":1623,"sandwiched":1624,"have":1625,"Sergeev":1626,"pixel":1627,"xytext":1628,"Rev":1629,"Synchromesh":1630,"inevitably":1631,"float64":1632,"sufficiently":1633,"digression":1634,"town":1635,"Jelinek":1636,"A.18":1637,"algebraic":1638,"realizable":1639,"办公":1640,"00":1641,"describes":1642,"pendent":1643,"Reranking":1644,"555":1645,"differed":1646,"unfavorable":1647,"656":1648,"whopping":1649,"XOR":1650,"Wenxiang":1651,"Log":1652,"A.38":1653,"maximimum":1654,"889":1655,"compact":1656,"Nature":1657,"bank":1658,"decay":1659,"Challenge":1660,"9B":1661,"exhibits":1662,"182":1663,"Extending":1664,"appoint":1665,"CD":1666,"show":1667,"treasures":1668,"6364":1669,"Zhao":1670,"ExponentialFamily":1671,"Premise":1672,"166":1673,"126259":1674,"Analogy":1675,"2504":1676,"3361":1677,"mitigate":1678,"linguistics":1679,"Conagra":1680,"NMS":1681,"ploys":1682,"Chowdhury":1683,"alors":1684,"Peters":1685,"acquiring":1686,"Compressed":1687,"K80":1688,"severely":1689,"478":1690,"Morey":1691,"flattening":1692,"DKS":1693,"attributed":1694,"Altos":1695,"Activations":1696,"fasttext":1697,"auto":1698,"relax":1699,"0.17802":1700,"NOW":1701,"Crop":1702,"iment":1703,"recognition82":1704,"partnerships":1705,"Doan":1706,"Psychonomic":1707,"466":1708,"window":1709,"emphasizes":1710,"Unresolved":1711,"synchro":1712,"testimony":1713,"eleven":1714,"Mar":1715,"value":1716,"Shuangchi":1717,"choosing":1718,"unjust":1719,"dismissing":1720,"Proprietary":1721,"wishing":1722,"HPO":1723,"grained":1724,"interme":1725,"ordered":1726,"commutative":1727,"assurance":1728,"570":1729,"Often":1730,"Discussions160":1731,"Failure":1732,"Cyber":1733,"071":1734,"switched":1735,"linear":1736,"underfitting":1737,"pool":1738,"476":1739,"JAX":1740,"Form":1741,"":1742,"1909":1743,"scatter":1744,"Nair":1745,"Pixel":1746,"workshops":1747,"select":1748,"limita":1749,"ishes":1750,"poi":1751,"bounds":1752,"bn":1753,"PF":1754,"Gard":1755,"managers":1756,"Former":1757,"disagrees":1758,"genomics":1759,"Dosovitskiy":1760,"sources":1761,"maturing":1762,"MaskLM":1763,"yielding":1764,"speedier":1765,"operational":1766,"Chandrasekaran":1767,"Hello":1768,"Tukey":1769,"Graham":1770,"2232":1771,"walk":1772,"Terre":1773,"发进":1774,"pecuniary":1775,"Rhode":1776,"unsuitable":1777,"Lafferty":1778,"nar":1779,"intimately":1780,"Synthesized":1781,"words":1782,"005":1783,"intelligence":1784,"Discussions231":1785,"practices":1786,"royalties":1787,"real":1788,"gual":1789,"percentages":1790,"QuickTake":1791,"allocated":1792,"Discussions214":1793,"arranged":1794,"propriate":1795,"injected":1796,"622":1797,"intruders":1798,"Narrow":1799,"extended":1800,"attack":1801,"latency":1802,"Qualitatively":1803,"arrays":1804,"Parent":1805,"百分":1806,"Content":1807,"cantly":1808,"CARP":1809,"disposed":1810,"cluster":1811,"95110":1812,"Operating":1813,"interleaving":1814,"vitskiy":1815,"10b5":1816,"Due":1817,"parallelogram":1818,"2056":1819,"out":1820,"delving":1821,"checked":1822,"parametrizations":1823,"inferring":1824,"presented":1825,"80000":1826,"Gebiete":1827,"Intervalrank":1828,"unissued":1829,"modelers":1830,"str":1831,"zh":1832,"x5":1833,"CoRec":1834,"asynchrony":1835,"competitively":1836,"Simplify":1837,"potted":1838,"Excluding":1839,"EDITSUM":1840,"interact":1841,"listen":1842,"Only":1843,"IoU":1844,"bananas":1845,"jonbally":1846,"Balakrishnan":1847,"denote":1848,"Additional":1849,"aiming":1850,"5x":1851,"ec2":1852,"loops":1853,"JANUARY":1854,"underly":1855,"10th":1856,"consult":1857,"Katakis":1858,"Normalizing":1859,"wiring":1860,"Fedus":1861,"Automotive":1862,"intervening":1863,"community":1864,"serve":1865,"bulk":1866,"simulator":1867,"LG":1868,"usr":1869,"Adaptive":1870,"frames":1871,"..":1872,"Estimating":1873,"dynamically":1874,"normalizations":1875,"Gbps":1876,"augmented":1877,"analyses":1878,"severe":1879,"inevitable":1880,"noise":1881,"Cl":1882,"40%":1883,"gered":1884,"WARNING":1885,"accomplish":1886,"progressively":1887,"Vishaal":1888,"racially":1889,"3960":1890,"thoroughly":1891,"order":1892,"716":1893,"Recommender":1894,"boss":1895,"Star":1896,"Weissenborn":1897,"depreciable":1898,"Kandpal":1899,"SSDs":1900,"页码":1901,"denominated":1902,"Discussions296":1903,"Li":1904,"searches":1905,"gl":1906,"791":1907,"Van":1908,"kNM":1909,"Discussions181":1910,"Resilient":1911,"100000":1912,"transitions":1913,"08144":1914,"Qualification":1915,"Atlas":1916,"contain":1917,"spends":1918,"Weight":1919,"EC2":1920,"putational":1921,"diameter":1922,"track":1923,"Lazy":1924,"wealth":1925,"stance":1926,"corporum":1927,"6.3":1928,"consistently":1929,"1694":1930,"Se":1931,"logic":1932,"optimizations":1933,"Wiki":1934,"wet":1935,"L2":1936,"gan":1937,"Adopted":1938,"Mhanics":1939,"Net":1940,"wondering":1941,"predic":1942,"Accruals":1943,"denied":1944,"5B":1945,"Depending":1946,"02846298236356246":1947,"dial":1948,"Find":1949,"everywhere":1950,"basing":1951,"xaxis":1952,"message":1953,"∋":1954,"品名":1955,"646":1956,"relaxed":1957,"482":1958,"303746":1959,"Quantum":1960,"GoogleNet":1961,"𝚲":1962,"varies":1963,"KRG":1964,"overestimation":1965,"percentiles":1966,"ext":1967,"Beneficially":1968,"payment":1969,"Trustees":1970,"band":1971,"Mishkin":1972,"arising":1973,"4400":1974,"Simplicity":1975,"ViTs":1976,"Chassis":1977,"extractors":1978,"jerryjliu":1979,"frontiers":1980,"regularize":1981,"Broker":1982,"bill":1983,"Requests":1984,"Joshi":1985,"797":1986,"Seq2SeqEncoder":1987,"5402":1988,"cs":1989,"RECAP":1990,"Discussions287":1991,"Neu":1992,"Einstein":1993,"info":1994,"Actually":1995,"online":1996,"引擎":1997,"7354":1998,"Ranvier":1999,"realization":2000,"1803":2001,"parameter":2002,"Vert":2003,"mismatches":2004,"grams":2005,"bottle":2006,"semination":2007,"2508":2008,"1873":2009,"cooperative":2010,"Multivariate":2011,"centuries":2012,"501":2013,"A1":2014,"Nonparametric":2015,"university":2016,"trees":2017,"Lacroix":2018,"stinks":2019,"relation":2020,"redesign":2021,"chal":2022,"valid":2023,"nization":2024,"quency":2025,"9213":2026,"NASA":2027,"overlay":2028,"fundamental":2029,"关键":2030,"Guarantees":2031,"perhaps":2032,"until":2033,"LaTeX":2034,"cla":2035,"upperlefts":2036,"Recht":2037,"signify":2038,"curvature":2039,"shaded":2040,"PyTorch":2041,"Illustrating":2042,"Visualgpt":2043,"200k":2044,"laplace":2045,"dropping":2046,"Joint":2047,"earthquakes":2048,"13.1":2049,"heav":2050,"Discussion":2051,"brute":2052,"Perry":2053,"finite":2054,"585e9cc93e70b39160e7921475f9bcd7d31219ce":2055,"gave":2056,"activate":2057,"Subword":2058,"trade":2059,"Commitments":2060,"Ama":2061,"riding":2062,"updates":2063,"MA":2064,"Propose":2065,"08345":2066,"Swap":2067,"Polyak":2068,"utiliza":2069,"rejection":2070,"vectorize":2071,"Forget":2072,"recall":2073,"Everything":2074,"017898854850751864":2075,"tainty":2076,"collaborates":2077,"ways":2078,"50770":2079,"cept":2080,"661":2081,"way":2082,"SFI":2083,"Triton":2084,"consulting":2085,"2663":2086,"epsilons":2087,"yogi":2088,"encoders":2089,"YOUR":2090,"astrophysics":2091,"Discussions225":2092,"Uijlings":2093,"Submission":2094,"Struc":2095,"CPG":2096,"wiki":2097,"benefit":2098,"Samoyeds":2099,"stock":2100,"unnormalized":2101,"877":2102,"transposing":2103,"1928":2104,"173428":2105,"400m":2106,"Liao":2107,"breadth":2108,"QA":2109,"attract":2110,"sits":2111,"3097":2112,"Hotline":2113,"RandomSearcher":2114,"marginal":2115,"i9":2116,"Reasoning":2117,"laid":2118,"ral":2119,"purchasing":2120,"conducts":2121,"Dong":2122,"PAD":2123,"Personal":2124,"Allowances":2125,"invariance":2126,"Zaragoza":2127,"a1":2128,"Behavior":2129,"SYN":2130,"histor":2131,"4x":2132,"bot":2133,"%-":2134,"Environmental":2135,"Taxonomy":2136,"981":2137,"implies":2138,"Karl":2139,"‡":2140,"二节":2141,"Making":2142,"Book":2143,"undergraduate":2144,"574":2145,"multiple":2146,"anal":2147,"remembering":2148,"␣":2149,"compose":2150,"clarifications":2151,"203052":2152,"suf":2153,"benign":2154,"multilayer":2155,"recognizer":2156,"chor":2157,"上传":2158,"integrate":2159,"dence":2160,"Course":2161,"Schema":2162,"2.7072":2163,"says":2164,"rearrange":2165,"fp":2166,"2028":2167,"Ermon":2168,"wires":2169,"Oftentimes":2170,"Factor":2171,"performs":2172,"3380":2173,"threaten":2174,"828":2175,"b5":2176,"sustained":2177,"workhorse":2178,"forked":2179,"hyperparam":2180,"grossly":2181,"Smaller":2182,"Shu":2183,"Aggregated":2184,"patterns":2185,"Move":2186,"intelligently":2187,"beneficially":2188,"expressiveness":2189,"Mnih":2190,"reconfigures":2191,"regularization":2192,"符合":2193,"90278":2194,"Holoscan":2195,"plicable":2196,"424":2197,"Multimodal":2198,"obsolescence":2199,"140488":2200,"November":2201,"17.1":2202,"Qualifications":2203,"PRE":2204,"featured":2205,"grounds":2206,"short":2207,"subtle":2208,"2001":2209,"pendently":2210,"mirrors":2211,"MedWriter":2212,"dro":2213,"Recovery":2214,"headwinds":2215,"Sec":2216,"indivisible":2217,"refers":2218,"Seawell":2219,"sions":2220,"Ju":2221,"aforemen":2222,"resourced":2223,"响应":2224,"opportunity":2225,"10436":2226,"11074":2227,"context":2228,"equates":2229,"conditionally":2230,"facility":2231,"Orientation":2232,"c72329e68a732bef0452e4b96a1c341c8910f81f":2233,"thesized":2234,"Labs":2235,"RGB":2236,"Nasdaq":2237,"Italy":2238,"discriminated":2239,"absorb":2240,"APPS":2241,"consolidations":2242,"PositionalEncoding":2243,"Gigaflops":2244,"hybridize":2245,"Signatures":2246,"whenever":2247,"parametrizing":2248,"jumps":2249,"Corrupt":2250,"409":2251,"lib":2252,"deploying":2253,"3544906":2254,"Py":2255,"Axon":2256,"Descent":2257,"Webson":2258,"Generated":2259,"Cov":2260,"09519":2261,"detect":2262,"conditions":2263,"college":2264,"1902":2265,"tially":2266,"lems":2267,"Fukushima":2268,"London":2269,"Whf":2270,"Being":2271,"Liwicki":2272,"incremental":2273,"approximating":2274,"7903":2275,"struc":2276,"36":2277,"distributing":2278,"Weigh":2279,"745":2280,"Langchain":2281,"769":2282,"𝑈":2283,"MDP":2284,"voting":2285,"delineate":2286,"Tuytelaars":2287,"Transparency":2288,"counts":2289,"deems":2290,"Specific":2291,"Averages":2292,"7.6":2293,">":2294,"doubling":2295,"Pledging":2296,"Reconciliation":2297,"CBMI":2298,"inserting":2299,"Engi":2300,"Gym256":2301,"95":2302,"issuing":2303,"behaviors":2304,"face":2305,"10b":2306,"Storytelling":2307,"impulse":2308,"RoofType":2309,"1975":2310,"decades":2311,"chines":2312,"snippets":2313,"43%":2314,"survey":2315,"urge":2316,"broadcast":2317,"derstanding":2318,"Pursuant":2319,"parametric":2320,"els":2321,"pools":2322,"optional":2323,"witness":2324,"Siva":2325,"dip":2326,"557":2327,"0240":2328,"Baciu":2329,"replicate":2330,"∫":2331,"tens":2332,"Hardt":2333,"hospital":2334,"dummies":2335,"performance":2336,"affords":2337,"manufacturers":2338,"Inflation":2339,"researchers":2340,"Hochreiter":2341,"Divided":2342,"Stephen":2343,"placeholders":2344,"surements":2345,"0.6026":2346,"running":2347,"2018":2348,"Instagram":2349,"subcontractor":2350,"Vanschoren":2351,"Table":2352,"eventualities":2353,"Completion":2354,"285":2355,"AS":2356,"circles":2357,"fuse":2358,"mastery":2359,"equity":2360,"Asus":2361,"bins":2362,"Actions":2363,"539":2364,"occupying":2365,"sizable":2366,"B":2367,"expression":2368,"ResNetBlock":2369,"astray":2370,"sheath":2371,"2.6727":2372,"Addendum":2373,"B.2":2374,"biol":2375,"watched":2376,"proxies":2377,"HPOScheduler":2378,"Circle":2379,"Weiss":2380,"Bilingual":2381,"Assesses":2382,"Missing":2383,"Eli":2384,"5513":2385,"Cultural":2386,"Matern":2387,"cation":2388,"graytowne":2389,"Xing":2390,"Indenture":2391,"3167":2392,"KISS":2393,"rcParams":2394,"Primary":2395,"brand":2396,"16420":2397,"Fig":2398,"can":2399,"Providing":2400,"OpenAI":2401,"scratched":2402,"Theory":2403,"dtype":2404,"12.2":2405,"Roy":2406,"robots":2407,"FDII":2408,"installed":2409,"10790":2410,"1.2517":2411,"accessible":2412,"surprisal":2413,"762":2414,"organizes":2415,"Clip":2416,"hereby":2417,"Looking":2418,"knobs":2419,"trols":2420,"Organizing":2421,"paragraphs":2422,"imperfectly":2423,"reimplementing":2424,"reseller":2425,"Reward":2426,"Registered":2427,"ha":2428,"flawed":2429,"axes":2430,"Audio":2431,"founda":2432,"251":2433,"negotiated":2434,"W4":2435,"es":2436,"Alexander":2437,"naturally":2438,"reversing":2439,"deal":2440,"pendix":2441,"RNNS":2442,"constructs":2443,"blistering":2444,"3.1":2445,"operate":2446,"Integrity":2447,"-.":2448,"rediscovered":2449,"defining":2450,"Jeff":2451,"899":2452,"A.6":2453,"misshapen":2454,"converts":2455,"60%":2456,"Mr":2457,"SIGMOD":2458,"Irene":2459,"1950":2460,"manipulate":2461,"ranges":2462,"Starry":2463,"RepoFusion":2464,"once":2465,"1059":2466,"CLIP":2467,"hi":2468,"decomposes":2469,"dependence":2470,"wishart":2471,"Bertsch":2472,"Preprocess":2473,"desir":2474,"trans":2475,"Bradley":2476,"Pennsylvania":2477,"inside":2478,"sprinkled":2479,"compatability":2480,"Vocabulary":2481,"Codebert":2482,"missing":2483,"1139":2484,"940":2485,"43006":2486,"sis":2487,"Ma":2488,"licensed":2489,"iterator":2490,"Be":2491,"zebras":2492,"Tesla":2493,"rid":2494,"xxxvii":2495,"produc":2496,"CG":2497,"duced":2498,"Posterior":2499,"08774":2500,"Ctrl":2501,"03545":2502,"considerably":2503,"Road":2504,"Variation":2505,"237":2506,"MLLM":2507,"711":2508,"mediating":2509,"457":2510,"Olivier":2511,"014628124155727769":2512,"patience":2513,"swamped":2514,"Otherwise":2515,"synchronize":2516,"Continuing":2517,"#":2518,"strated":2519,"3212":2520,"580s":2521,"Neural":2522,"33GB":2523,"Analytic":2524,"informational":2525,"0.109":2526,"Following":2527,"3544903":2528,"physics":2529,"brightness":2530,"\u0001":2531,"prospect":2532,"trix":2533,"defaulted":2534,"reached":2535,"two":2536,"diverges":2537,"3316":2538,"Acquisition":2539,"0.456":2540,"1735":2541,"10666":2542,"planes":2543,"subfields":2544,"1A":2545,"第三段":2546,"Firat":2547,"zeros":2548,"strikes":2549,"the":2550,"3610":2551,"Buy":2552,"Tulder":2553,"961":2554,"HippoRAG":2555,"highlighted":2556,"gap":2557,"computed":2558,"el":2559,"Rectangle":2560,"481":2561,"28001":2562,"rectangles":2563,"Carlyle":2564,"diningtable":2565,"patents":2566,"paths":2567,"backported":2568,"SoftmaxRegression":2569,"trave":2570,"cycling":2571,"1479":2572,"conv":2573,"isotonic":2574,"convnets":2575,"Kepler":2576,"mizes":2577,"techniques":2578,"peruse":2579,"tency":2580,"RIGHT":2581,"StackedRNNScratch":2582,"issue":2583,"A.35":2584,"913":2585,"judgment":2586,"Compile":2587,"06211":2588,"Neither":2589,"Days":2590,"recognized":2591,"factorize":2592,"construct":2593,"dating":2594,"desk":2595,"PubMed":2596,"Bindel":2597,"4132":2598,"yielded":2599,"makedirs":2600,"intuitively":2601,"playing":2602,"Broyde":2603,"maximal":2604,"Certainly":2605,"camera":2606,"Mellanox":2607,"rvs":2608,"Syne":2609,"speaking":2610,"specialize":2611,"lenlabel":2612,"LION":2613,"investigation":2614,"memorizing":2615,"130":2616,"mathematicians":2617,"Turning":2618,"nonnegativity":2619,"align":2620,"19":2621,"872":2622,"domain":2623,"1962":2624,"uncertain":2625,"transforma":2626,"32":2627,"AdaptiveAvgPool1d":2628,"𝑊":2629,"Klein":2630,"annotating":2631,"Admission":2632,"gridwold":2633,"2.7":2634,"Tolstoy":2635,"Unpaired":2636,"gle":2637,"gra":2638,"15880":2639,"965637":2640,"XX":2641,"2.7281":2642,"Separate":2643,"voluntarily":2644,"spectacularly":2645,"Submitting":2646,"modulated":2647,"Rossiello":2648,"á":2649,"halves":2650,"universally":2651,"CMR":2652,"Friedland":2653,"208":2654,"12.1":2655,"renewable":2656,"belonging":2657,"Ames":2658,"53.576584339141846":2659,"Jacot":2660,"evaluations":2661,"Dogs":2662,"mainly":2663,"Superchip":2664,"indemnify":2665,"vent":2666,"th":2667,"sums":2668,"1Whi":2669,"Zemel":2670,"Rabinovich":2671,"COT":2672,"gyms":2673,"pts":2674,"03903577426988046":2675,"heritage":2676,"beled":2677,"surpassing":2678,"1456":2679,"folder":2680,"Codet5":2681,"1473":2682,"resistor":2683,"workings":2684,"unwieldy":2685,"adequacy":2686,"Distribution":2687,"upended":2688,"employee":2689,"spam":2690,"2016":2691,"22":2692,"lobbyists":2693,"gigaflops":2694,"Contradiction":2695,"Xu":2696,"1978":2697,"1945":2698,"20.2":2699,"227":2700,"SUPERCOMPUTING":2701,"RTX":2702,"publisher":2703,"Missiles":2704,"billing":2705,"delineation":2706,"Fortu":2707,"cstride":2708,"过程":2709,"department":2710,"StackSpotAI":2711,"jitter":2712,"totic":2713,"Weikum":2714,"rlrc":2715,"ecuted":2716,"mnist":2717,"trapped":2718,"NAACL":2719,"calculus":2720,"halve":2721,"Primeneniya":2722,"trousers":2723,"11761":2724,"plifying":2725,"classifying":2726,"deviation":2727,"Choices":2728,"scape":2729,"Amortization":2730,"cloning":2731,"catdoor":2732,"Conduct":2733,"Draw":2734,"AIBs":2735,"arbitrary":2736,"891":2737,"Sliding":2738,"dangerous":2739,"betas":2740,"mini2":2741,"company":2742,"phrase":2743,"structureless":2744,"1968":2745,"SumBackward0":2746,"Terminate":2747,"product":2748,"infinite":2749,"lite":2750,"amples":2751,"hypothesis":2752,"parallelism":2753,"items":2754,"rung":2755,"123379":2756,"staled":2757,"suffixes":2758,"slicing":2759,"strategy":2760,"1075":2761,"F6":2762,"intermediary":2763,"Unusual":2764,"Gonina":2765,"confident":2766,"sin":2767,"fine":2768,"Ryan":2769,"Module":2770,"Discussions289":2771,"piracy":2772,"dair":2773,"adaptations":2774,"Goodreads":2775,"ionMNIST":2776,"iamorphen":2777,"Were":2778,"744":2779,"MEETING":2780,"ANYWAY":2781,"Lamblin":2782,"preferentially":2783,"Administration":2784,"Bochkovskiy":2785,"nantekoto":2786,"blends":2787,"Sadly":2788,"899878":2789,"larly":2790,"silicon":2791,"oak":2792,"appli":2793,"RelaxedBernoulli":2794,"assume":2795,"Discussions131":2796,"1934":2797,"address":2798,"repeatedly":2799,"stored":2800,"ag":2801,"ours":2802,"Crossover":2803,"Anal":2804,"apple":2805,"21%":2806,"Chess":2807,"c1816da3821ae9f43899be655002f6c723e91b88":2808,"statement":2809,"Va":2810,"Calculated":2811,"226":2812,"Their":2813,"prioritizes":2814,"concerns":2815,"Depreciation":2816,"Stage":2817,"especially":2818,"00300":2819,"chen":2820,"stragglers":2821,"underlying":2822,"1417":2823,"4463":2824,"sequentiality":2825,"flatter":2826,"430578":2827,"classification81":2828,"subjects":2829,"contingencies":2830,"staff":2831,"cons":2832,"Discussions148":2833,"CF":2834,"thinking":2835,"nervous":2836,"liberty":2837,"Why":2838,"cancer":2839,"Mathemat":2840,"instructions":2841,"conclude":2842,"Matching":2843,"CVPR":2844,"𝝃":2845,"4032":2846,"Brain":2847,"prerequisites":2848,"ABC":2849,"illustrations":2850,"correc":2851,"innovate":2852,"paving":2853,"Suffice":2854,"ver":2855,"Finding":2856,"constitute":2857,"Jeon":2858,"JavaScript":2859,"unnecessarily":2860,"lives":2861,"worker":2862,"treatment":2863,"Norlund":2864,"务器":2865,"Maiorca":2866,"≻":2867,"Tensorflow":2868,"homes":2869,"2043":2870,"Inequality":2871,"variable":2872,"buyers":2873,"900570":2874,"diminish":2875,"THEIR":2876,"Aliasing":2877,"education":2878,"sweaters":2879,"covariate":2880,"Unused":2881,"adjustment":2882,"realism":2883,"𝛼":2884,"infected":2885,"Gap":2886,"SURF":2887,"unsatisfying":2888,"underpinned":2889,"Discussions271":2890,"Threshold":2891,"study":2892,"declaring":2893,"Confer":2894,"hosted":2895,"prohibitions":2896,"injective":2897,"56.3":2898,"RoBERTa":2899,"having":2900,"lens":2901,"RAMKG":2902,"outreach":2903,"systematically":2904,"801392782910287192":2905,"⊮":2906,"SUMMARY":2907,"approval":2908,"Yankee":2909,"Re2g":2910,"involved":2911,"511":2912,"discussing":2913,"molecule":2914,"DEFINITIONS":2915,"Tune":2916,"Jaitly":2917,"YOLOv3":2918,"Kirkland":2919,"unlabeled":2920,"Alias":2921,"enough":2922,"L":2923,"overlook":2924,"144834":2925,"294":2926,"How":2927,"emanating":2928,"ditioner":2929,"Vogels":2930,"rowed":2931,"terms":2932,"upfront":2933,"Chetlur":2934,"walks":2935,"Jan":2936,"Lausen":2937,"west":2938,"struction":2939,"paradigms":2940,"directional":2941,"extracting":2942,"commerce":2943,"rection":2944,"December":2945,"subsumes":2946,"aclImdb":2947,"indexing":2948,"TENCH":2949,"405545":2950,"asymmetric":2951,"02962":2952,"noting":2953,"hp":2954,"really":2955,"impacts":2956,"121330":2957,"associations":2958,"Kernels":2959,"sql":2960,"Teye":2961,"recent":2962,"95051":2963,"437":2964,"tackle":2965,"259171":2966,"RPM":2967,"outlook":2968,"∥":2969,"collaboratively":2970,"稳固":2971,"travel":2972,"Discussions97":2973,"his":2974,"Check":2975,"Civil":2976,"transformers":2977,"regulator":2978,"6712":2979,"618":2980,"4532":2981,"warm":2982,"perquisites":2983,"reprint":2984,"RefinedWeb":2985,"severance":2986,"Exemplar":2987,"WhiteD3vil":2988,"Haibin":2989,"6557":2990,"lurking":2991,"Nik":2992,"teacher":2993,"discovering":2994,"type":2995,"investing":2996,"buildout":2997,"occupy":2998,"1082":2999,"corporations":3000,"categorical":3001,"impairments":3002,"differential":3003,"ltered":3004,"Key":3005,"Fortran":3006,"00923":3007,"namics":3008,"hv1":3009,"spectively":3010,"1470":3011,"Adapting":3012,"NegativeBinomial":3013,"grids":3014,"unzip":3015,"Infor":3016,"lack":3017,"53":3018,"Networking":3019,"Erosion":3020,"remains":3021,"Rationale":3022,"deduction":3023,"Hopkins":3024,"wiggily":3025,"judging":3026,"repayments":3027,"REPLUG":3028,"517":3029,"lus":3030,"Domain":3031,"respec":3032,"Specia":3033,"Engine":3034,"Salimans":3035,"talent":3036,"acquirer":3037,"customizable":3038,"chain62":3039,"13.2":3040,"repeats":3041,"who":3042,"simulations":3043,"Turing":3044,"crash":3045,"somehow":3046,"TSR":3047,"cooperate":3048,"kiplus1":3049,"consid":3050,"tale":3051,"Greff":3052,"solicit":3053,"tradiational":3054,"software":3055,"PICa":3056,"Microsystems":3057,"Jaguar":3058,"cartoonishly":3059,"tandem":3060,"LinkedIn":3061,"Tayal":3062,"prompts":3063,"delivery":3064,"Hot":3065,"©":3066,"discrete":3067,"Annex":3068,"Registrar":3069,"Reliance":3070,"834":3071,"analyticsindiamag":3072,"Saving":3073,"satisfaction":3074,"Spotify":3075,"𝒞":3076,"Acquisitions":3077,"furthermore":3078,"manage":3079,"模块":3080,"worthiness":3081,"potentially":3082,"grayscale":3083,"eventually":3084,"8675309":3085,"\u0015":3086,"086":3087,"phases":3088,"card":3089,"distorting":3090,"211":3091,"1702844732454753":3092,"asyn":3093,"tory":3094,"Any":3095,"crowdsourcing":3096,"Kluwer":3097,"feeds":3098,"European":3099,"𝐸":3100,"751":3101,"prototype":3102,"heiligerl":3103,"Diagnostics":3104,"section":3105,"Multi":3106,"mobility":3107,"Management":3108,"CUDA":3109,"Categorical":3110,"mate":3111,"pasricha":3112,"sponsors":3113,"cy":3114,"Conversion":3115,"unfolded":3116,"GTC":3117,"Kaan":3118,"ToolCoder":3119,"manipulating":3120,"unifies":3121,"316":3122,"batchify":3123,"Question":3124,"branch":3125,"Solid":3126,"APPLICATIONS":3127,"xvi":3128,"stalls":3129,"propelling":3130,"py":3131,"5000":3132,"Fang":3133,"perspective":3134,"challenges":3135,"improved":3136,"Contributions":3137,"7096":3138,"suring":3139,"Percent":3140,"copilots":3141,"beam":3142,"Downloading":3143,"Tomasino":3144,"discovers":3145,"⌋":3146,"6.6":3147,"Life":3148,"dic":3149,"idle":3150,"Discussions128":3151,"straight":3152,"Bge":3153,"下方":3154,"Q2K2":3155,"Crawled":3156,"dotted":3157,"calme":3158,"branching316":3159,"qualifying":3160,"ellipses":3161,"OEMs":3162,"skip":3163,"harvesting":3164,"2074":3165,"With":3166,"autograd":3167,"4899e":3168,"multi":3169,"bigram":3170,"difference":3171,"10222":3172,"374":3173,"844":3174,"year":3175,"six":3176,"combatting":3177,"educational":3178,"STEVENS":3179,"ferring":3180,"weigh":3181,"431":3182,"Harvey":3183,"inv":3184,"PID":3185,"balances":3186,"clhm":3187,"MasterCard":3188,"sending":3189,"Jensen":3190,"Emphasis":3191,"adapting":3192,"reproduction":3193,"Taken":3194,"ATM":3195,"plug":3196,"turnover":3197,"07747":3198,"interval":3199,"Subramanya":3200,"docx":3201,"discourse":3202,"templated":3203,"pile":3204,"moment":3205,"institution":3206,"387814":3207,"committee":3208,"native":3209,"Kaftan":3210,"384":3211,"Leyton":3212,"Discussions92":3213,"sharpened":3214,"EAE":3215,"Variances":3216,"plotted":3217,"Reinforcement":3218,"onal":3219,"856":3220,"nected":3221,"Arbuthnot":3222,"Faloutsos":3223,"016":3224,"confidently":3225,"Shukla":3226,"tuned":3227,"Of":3228,"0.2890":3229,"8%":3230,"Read":3231,"00010":3232,"FFW":3233,"since":3234,"best":3235,"excise":3236,"marry":3237,"September":3238,"rowwise":3239,"ignores":3240,"350":3241,"5.4":3242,"97":3243,"impacted":3244,"alarm":3245,"Achievement":3246,"CHROMESH":3247,"platter":3248,"bleu":3249,"undergone":3250,"0.005":3251,"modularity":3252,"increas":3253,"bitrary":3254,"N0":3255,"possess":3256,"wider":3257,"950":3258,"quantifies":3259,"descriptions":3260,"invented":3261,"DATA":3262,"images":3263,"overloading":3264,"subsampled":3265,"corrections":3266,"treating":3267,"machin":3268,"bright":3269,"icon":3270,"archival":3271,"Companion":3272,"Signature":3273,"Discussions55":3274,"Grab":3275,"121":3276,"Dividing":3277,"off":3278,"NVLink":3279,"conduct":3280,"Exploiting":3281,"Ditlevsen":3282,"decomposition":3283,"2913":3284,"perparameters":3285,"standardized":3286,"Right":3287,"Latent":3288,"plement":3289,"formed":3290,"Useful":3291,"ine":3292,"CoBaFi":3293,"设计":3294,"2205":3295,"Maintain":3296,"quoted":3297,"mon":3298,"gracefully":3299,"10%":3300,"elems":3301,"python3":3302,"geometrically":3303,"closed":3304,"Qadir":3305,"Musicians":3306,"weave":3307,"IP":3308,"resemble":3309,"waving":3310,"Whenever":3311,"communities":3312,"leasehold":3313,"Bremen":3314,"consist":3315,"compression":3316,"Mitigate":3317,"made":3318,"UniMS":3319,"Kardas":3320,"monkey":3321,"training":3322,"Giannis":3323,"counterfactual":3324,"bans":3325,"Mack":3326,"monomials":3327,"whatsoever":3328,"Carlo":3329,"conversely":3330,"eldarkurtic":3331,"functionality":3332,"REACH":3333,"2023a":3334,"signatures":3335,"integrates":3336,"06450":3337,"09018":3338,"1734":3339,"Korea":3340,"45000":3341,"Impairments":3342,"prehending":3343,"green":3344,"fi":3345,"deviates":3346,"submitted":3347,"underpinnings":3348,"gressBoard":3349,"01431":3350,"command":3351,"subscription":3352,"upside":3353,"invite":3354,"Cloud":3355,"nansum":3356,"Dinh":3357,"certify":3358,"Algorithm":3359,"block":3360,"Intelligent":3361,"chicken":3362,"outnumber":3363,"zilliztech":3364,"fares":3365,"1000010":3366,"Quadro":3367,"Fuma":3368,"polygon":3369,"cached":3370,"etc":3371,"ancient":3372,"Gross":3373,"tricks":3374,"Systems":3375,"Masking":3376,"11206":3377,"Unterthiner":3378,"nation":3379,"b1":3380,"licensing":3381,"derivatives":3382,"practicality":3383,"entries":3384,"currentframe":3385,"clunky":3386,"Feichtenhofer":3387,"Moon":3388,"ner":3389,"amortize":3390,"loyalty":3391,"eval":3392,"换行":3393,"mansion":3394,"‘":3395,"Target":3396,"datasets":3397,"exported":3398,"Task":3399,"drive":3400,"Distributed":3401,"moid":3402,"Biometrika":3403,"DAWN":3404,"pairwise":3405,"Linear":3406,"niques":3407,"Account":3408,"NVIDIA":3409,"Aligning":3410,"A77":3411,"p2":3412,"Sarbanes":3413,"STATES":3414,"70s":3415,"1018":3416,"blks":3417,"approaches":3418,"Jiehang":3419,"constituting":3420,"gamma":3421,"countries":3422,"ColorJitter":3423,"SANTA":3424,"achieved":3425,"Amended":3426,"basic":3427,"tend":3428,"EVP":3429,"looks":3430,"ignored":3431,"downweighting":3432,"604":3433,"Bulatov":3434,"plateaued":3435,"222":3436,"Lecture":3437,"amongst":3438,"Bilinear":3439,"taller":3440,"ior":3441,"694":3442,"reasonable":3443,"similar":3444,"deferrals":3445,"diag":3446,"grid":3447,"analyze":3448,"Y":3449,"faced":3450,"ISVs":3451,"Mathematically":3452,"internationally":3453,"ICML":3454,"hamper":3455,"triv":3456,"subsume":3457,"spoken":3458,"USENIX":3459,"amortizable":3460,"superficial":3461,"using":3462,"icl":3463,"destroying":3464,"minimax":3465,"13.3":3466,"1041":3467,"0.119":3468,"reversed":3469,"next2":3470,"6840":3471,"700":3472,"From":3473,"Ac":3474,"optimizing":3475,"woman":3476,"game":3477,"Securities":3478,"Inline":3479,"adequately":3480,"comb":3481,"Buses":3482,"shipped":3483,"exit":3484,"Martins":3485,"afterthought":3486,"1000000":3487,"execution":3488,"03167":3489,"Alexa":3490,"distortion":3491,"ability":3492,"local":3493,"deductible":3494,"ﬂ":3495,"arose":3496,"quadratically":3497,"302":3498,"granularity":3499,"happening":3500,"advisors":3501,"Sanh":3502,"due":3503,"Germans":3504,"Attendance":3505,"AdditiveAttention":3506,"similarities":3507,"49%":3508,"AVX2195":3509,"Consent":3510,"learns":3511,"advocacy":3512,"Corrective":3513,"space":3514,"diffi":3515,"Continually":3516,"Kundu":3517,"MultiStepLR":3518,"KAPING":3519,"AlexSauer":3520,"174":3521,"Detect":3522,"Secretary":3523,"reimbursement":3524,"Hadjis":3525,"deprecated":3526,"ratification":3527,"Kinds":3528,"alternation":3529,"correlate":3530,"aug":3531,"cus":3532,"107405":3533,"Committee":3534,"satellite":3535,"interconnected":3536,"sexual":3537,"636":3538,"require":3539,"doubles":3540,"demographic":3541,"Overhead":3542,"LawLLM":3543,"decompositions":3544,"contained":3545,"613":3546,"12th":3547,"Glorot":3548,"Matias":3549,"classifiers":3550,"authorities":3551,"aware":3552,"costs":3553,"C4":3554,"escalate":3555,"966186":3556,"tionary":3557,"Symphony":3558,"digits":3559,"Malik":3560,"TFLOPs":3561,"exceeds":3562,"redeemed":3563,"145":3564,"flip":3565,"enjoyed":3566,"specialized":3567,"cot":3568,"AddNorm":3569,"character":3570,"against":3571,"cross":3572,"843":3573,"hue":3574,"automation":3575,"reviewing":3576,"poor":3577,"fourth":3578,"ubiquitous":3579,"EXCHANGE":3580,"shirt":3581,"SIGIR":3582,"sum":3583,"determined":3584,"single":3585,"programmatically":3586,"bridging":3587,"hedge":3588,"run":3589,"AdaptiveRAG":3590,"Selipsky":3591,"Whxx":3592,"network":3593,"constitutes":3594,"533":3595,"logically":3596,"Occupation":3597,"LEFT":3598,"tagged":3599,"Appl":3600,"ordering":3601,"Shares":3602,"encountering":3603,"360":3604,"Discussions165":3605,"Tutorial":3606,"897":3607,"Cooley":3608,"Vin":3609,"an":3610,"Geometric":3611,"rank":3612,"quent":3613,"treaties":3614,"parallelize":3615,"reduced":3616,"13a":3617,"covers":3618,"tosses":3619,"connection":3620,"holders":3621,"interrupts":3622,"Land":3623,"𝜶":3624,"bud":3625,"eager":3626,"Tbit":3627,"Unvested":3628,"amends":3629,"curacy":3630,"IST":3631,"Years":3632,"Revolution":3633,"Cock":3634,"learned":3635,"deeplearningbook":3636,"Wagenmakers":3637,"president":3638,"scientific":3639,"approximates":3640,"God":3641,"05777":3642,"sided":3643,"Mu":3644,"nizing":3645,"modifications":3646,"1.74":3647,"Baevski":3648,"hw1":3649,"instance":3650,"C++":3651,"1.4883":3652,"LeNet":3653,"neighbours":3654,"hypothetical":3655,"kernels":3656,"9824":3657,"rainier":3658,"748":3659,"desires":3660,"90th":3661,"Nikhil95":3662,"livelihood":3663,"themself":3664,"hparams":3665,"090b5e7e70c295757f55df93cb0a180b9691891a":3666,"PCIe":3667,"organizing":3668,"9023":3669,"303":3670,"eigenvalues":3671,"P2":3672,"Abadie":3673,"dation":3674,"her":3675,"underway":3676,"patch":3677,"648":3678,"Since":3679,"X800":3680,"Dell":3681,"bundled":3682,"Jiyang":3683,"statute":3684,"Semantic":3685,"calculated":3686,"mismatching":3687,"key":3688,"visualization":3689,"supports":3690,"Hoffmann":3691,"Durable":3692,"warehouse":3693,"DiskANN":3694,"revolution":3695,"A.49":3696,"noun":3697,"variate":3698,"something":3699,"circa":3700,"goals":3701,"1420":3702,"2404":3703,"59":3704,"Review":3705,"CSV":3706,"KnowledGPT":3707,"h3":3708,"heads":3709,"691":3710,"554":3711,"Discussions12":3712,"Ground":3713,"Reinforcing":3714,"exercised":3715,"Colab":3716,"blackbox":3717,"Novel":3718,"Added":3719,"indemnitee":3720,"indices":3721,"20th":3722,"01000":3723,"评估":3724,"extract":3725,"300":3726,"intent":3727,"Princeton":3728,"loader":3729,"638":3730,"Chapter":3731,"make":3732,"WeChat":3733,"collaborative":3734,"Goetz":3735,"943467":3736,"aggregating":3737,"symmetry":3738,"issuable":3739,"A.45":3740,"EDGE":3741,"pokemon":3742,"Common":3743,"THESE":3744,"applications":3745,"peer":3746,"𝐵":3747,"stacked":3748,"thoughts":3749,"rating":3750,"downsampling":3751,"Frisoni":3752,"069":3753,"grounding":3754,"3002":3755,"diluted":3756,"plant":3757,"perform":3758,"16347":3759,"egocentric":3760,"injunction":3761,"respon":3762,"7038":3763,"therewith":3764,"CODEAGENT":3765,"Santa":3766,"8697":3767,"1980s":3768,"costly":3769,"Microservices":3770,"ICCBR":3771,"hierarchically":3772,"13707981127012328":3773,"06732":3774,"bucket":3775,"constructor":3776,"professional":3777,"Ramesh":3778,"functional":3779,"Length":3780,"Tweak":3781,"Vial":3782,"Is":3783,"waste":3784,"forecasts":3785,"Fundamental":3786,"innermost":3787,"pattern":3788,"quotas":3789,"stylization":3790,"which":3791,"RelaxedOneHotCategorical":3792,"delimiter":3793,"around":3794,"plays":3795,"Vougiouklis":3796,"Differentiation":3797,"4334":3798,"repatriate":3799,"05799":3800,"DISCUSSION":3801,"Reproduction":3802,"Balances":3803,"prohibited":3804,"IndependentTransform":3805,"Discussions114":3806,"Carl":3807,"1107":3808,"Align":3809,"pain":3810,"5177":3811,"selecting":3812,"Kirkpatrick":3813,"trust":3814,"Entering":3815,"2030":3816,"overload":3817,"Kiureghian":3818,"⋯":3819,"unneeded":3820,"ditioned":3821,"263":3822,"hints":3823,"351":3824,"monsense":3825,"Helmbold":3826,"unlock":3827,"VOTE":3828,"communicates":3829,"India":3830,"4.2":3831,"skeleton":3832,"2112":3833,"Chang":3834,"Deferred":3835,"Square":3836,"headquarter":3837,"1993":3838,"normalization":3839,"lengthy":3840,"currently":3841,"sl7423":3842,"628":3843,"AIB":3844,"created":3845,"determinants":3846,"receipt":3847,"1X":3848,"discards":3849,"wallclock":3850,"Surpassed":3851,"farmers":3852,"transferring":3853,"USA":3854,"Xv":3855,"Theano":3856,"TOP500":3857,"1525.4":3858,"1655":3859,"vectorized":3860,"log":3861,"particularly":3862,"frequency":3863,"Perrone":3864,"timesteps":3865,"documentations":3866,"attr":3867,"Periodic":3868,"spe":3869,"ings":3870,"sistent":3871,"WordNet":3872,"persistently":3873,"any":3874,"wants":3875,"Aronszajn":3876,"span":3877,"DGL199":3878,"uncertainty":3879,"sleight":3880,"pub":3881,"collecting":3882,"9%":3883,"400MB":3884,"Lookup":3885,"behalf":3886,"modifi":3887,"Functions":3888,"1984":3889,"Wqhh":3890,"Attending":3891,"anonymous":3892,"Redondo":3893,"lexical":3894,"Corthorn":3895,"volutional":3896,"2237":3897,"SNLIBERTDataset":3898,"nlabel":3899,"indus":3900,"Mechan":3901,"1083":3902,"frivolously":3903,"Autoregressive":3904,"tropy":3905,"0704":3906,"aeronautics":3907,"Goldilocks":3908,"Interpreters":3909,"Provide":3910,"conda":3911,"visual":3912,"convey":3913,"ResNet18":3914,"asserts":3915,"relu":3916,"repeat":3917,"F3":3918,"biographies":3919,"saw":3920,"51":3921,"sounds":3922,"Harvard":3923,"18170":3924,"elementwise":3925,"1033":3926,"037703":3927,"When":3928,"consolidation":3929,"03172":3930,"Alongside":3931,"If":3932,"RAID":3933,"road":3934,"Sets":3935,"Nichols":3936,"ª":3937,"beverage":3938,"Strong":3939,"1922":3940,"ecution":3941,"Who":3942,"hyperplanes":3943,"1710":3944,"Licensing":3945,"objectively":3946,"Nested":3947,"ubiquity":3948,"Custom":3949,"LLaMA":3950,"leverages":3951,"Tailors":3952,"necessarily":3953,"Wow":3954,"nipulating":3955,"Gasthaus":3956,"Eigenvalues":3957,"ó":3958,"contrib":3959,"architectural":3960,"2.8231":3961,"SURGE":3962,"reveals":3963,"struggle":3964,"Norvig":3965,"Enhancing":3966,"4000":3967,"Karayev":3968,"1705":3969,"box":3970,"leakage":3971,"setup":3972,"adjusted":3973,"elicit":3974,"1015":3975,"arise":3976,"contradicted":3977,"Connected":3978,"coined":3979,"To":3980,"overridden":3981,"initiated":3982,"License":3983,"213":3984,"oscillations":3985,"Generator":3986,"Grace":3987,"847":3988,"NYSE":3989,"image":3990,"hyperplane":3991,"format311":3992,"Chainer":3993,"debias":3994,"Security":3995,"pq2":3996,"W1":3997,"overfitting":3998,"qa":3999,"665":4000,"indulge":4001,"4127":4002,"Validating":4003,"Dropout":4004,"spite":4005,"Package":4006,"tokenize":4007,"approve":4008,"Less":4009,"crafted":4010,"3.3":4011,"interruption":4012,"PopVsSoda":4013,"Michalewski":4014,"Ancient":4015,"touched":4016,"ance":4017,"noncancelable":4018,"concerned":4019,"peak":4020,"simply":4021,"tainly":4022,"combined":4023,"reaching":4024,"0.0":4025,"suggestion":4026,"4X":4027,"Restricted":4028,"blow":4029,"problematic":4030,"0759":4031,"↑":4032,"Ahmed":4033,"pertain":4034,"http":4035,"reinvent":4036,"negatives":4037,"RMSProp":4038,"mize":4039,"anisms":4040,"Katsouros":4041,"commitments":4042,"BiRNNScratch":4043,"xiv":4044,"analogue":4045,"CodeS":4046,"afterwards":4047,"think":4048,"contacted":4049,"SE":4050,"":4051,"phoneme":4052,"88%":4053,"grateful":4054,"heart":4055,"pretrains":4056,"2818":4057,"plethora":4058,"facecolor":4059,"Chae":4060,"predominant":4061,"bugs":4062,"TPAMI":4063,"split":4064,"bn3":4065,"0278":4066,"replicates":4067,"fascinating":4068,"xxvii":4069,"Wxc":4070,"mechanical":4071,"Hessians":4072,"ethnicity":4073,"Exhaustive":4074,"endless":4075,"Discussions170":4076,"Rewards":4077,"386":4078,"Choice":4079,"ROBERT":4080,"appears":4081,"optimizer":4082,"agreements":4083,"localize":4084,"encompass":4085,"sketch":4086,"library":4087,"permit":4088,"marvelously":4089,"everyday":4090,"Song":4091,"cels":4092,"xticks":4093,"Conv2d":4094,"683":4095,"getattr":4096,"ypandya":4097,"multipliers":4098,"progres":4099,"substitutes":4100,"Enterprises":4101,"traction":4102,"backgammon":4103,"method":4104,"363":4105,"spatial":4106,"Zoph":4107,"disposition":4108,"rstride":4109,"HPOSearcher":4110,"12890":4111,"Public":4112,"Ultimately":4113,"KL":4114,"invariances":4115,"Defines":4116,"12246":4117,"bedrooms":4118,"Headings":4119,"pirical":4120,"nonconvex":4121,"500px":4122,"Fe":4123,"reality":4124,"510":4125,"relkt":4126,"wired":4127,"Blume":4128,"0.0674":4129,"boasting":4130,"inaccurate":4131,"6719":4132,"w1":4133,"mail":4134,"VOC2012":4135,"INCORPORATED":4136,"549367":4137,"1410":4138,"Compute":4139,"strategic":4140,"RegNetX32":4141,"use":4142,"241193":4143,"137":4144,"fields":4145,"3.5":4146,"Zhengren":4147,"02178":4148,"Udomcharoenchaikit":4149,"uniquely":4150,"Monterey":4151,"$":4152,"Aerospace":4153,"":4154,"cosmetic":4155,"spiel":4156,"rect":4157,"Gulcehre":4158,"user":4159,"attrition":4160,"Steinhardt":4161,"consideration":4162,"Kavosh":4163,"2007":4164,"theft":4165,"pushes":4166,"16.3":4167,"algo":4168,"ReAct":4169,"Yards":4170,"Discussions76":4171,"dismissal":4172,"retailer":4173,"Gui":4174,"clude":4175,"SMALLCAP":4176,"estimators":4177,"3072e":4178,"prefixes":4179,"spans":4180,"SuccessiveHalvingScheduler":4181,"14130.125":4182,"Access":4183,"speaker":4184,"Wissenschaften":4185,"warrants":4186,"Dachshunds":4187,"future":4188,"Healthcare":4189,"ller":4190,"mlxd":4191,"recoverable":4192,"upstream":4193,"484":4194,"Kaixin":4195,"SDKs":4196,"minibatches":4197,"traveller":4198,"stu":4199,"Scaling":4200,"Fabrinet":4201,"compares":4202,"mysterious":4203,"Weights":4204,"Lectures":4205,"quality":4206,"Relevant":4207,"第一节":4208,"dose":4209,"conveyed":4210,"paved":4211,"few":4212,"Definition":4213,"decomposable":4214,"diagonals":4215,"prides":4216,"R100":4217,"2031":4218,"Discussions212":4219,"surprised":4220,"instructional":4221,"respectable":4222,"Sankhy":4223,"charac":4224,"insert":4225,"issues":4226,"PoET":4227,"025582":4228,"preference":4229,"Dickstein":4230,"amplitude":4231,"deduces":4232,"2301":4233,"encrypted":4234,"predefined":4235,"infrastructure":4236,"Traditionally":4237,"RoI":4238,"razor":4239,"emails":4240,"chopping":4241,"099":4242,"teristic":4243,"Abbeel":4244,"regres":4245,"champion":4246,"CL":4247,"190":4248,"ini":4249,"applies":4250,"fallout":4251,"176":4252,"ter":4253,"base":4254,"1047":4255,"Waldo":4256,"coordinate":4257,"manifestation":4258,"Lisp":4259,"gorithms":4260,"Drives":4261,"See":4262,"publishers":4263,"MacOSX":4264,"FLARE":4265,"imitation":4266,"trajectories":4267,"approximately":4268,"Discussions180":4269,"resented":4270,"Tomer":4271,"repeal":4272,"truncated":4273,"debt":4274,"expense":4275,"PACs":4276,"Codeagent":4277,"deviations":4278,"LDMs":4279,"flash":4280,"programmer":4281,"771":4282,"mined":4283,"diagnoses":4284,"Fashion":4285,"whiteboard":4286,"net1":4287,"delayed":4288,"reflects":4289,"Ltd":4290,"convs":4291,"fried":4292,"whereas":4293,"textbooks":4294,"Imple":4295,"Agreements":4296,"objec":4297,"的":4298,"Clipping":4299,"tokeniza":4300,"Modification":4301,"subsystems":4302,"families":4303,"puting":4304,"Current":4305,"gent":4306,"healthcare":4307,"damaged":4308,"intro":4309,"388":4310,"perplexity":4311,"03299":4312,"positional":4313,"1102":4314,"jects":4315,"svg":4316,"0010":4317,"Thomas":4318,"𝑎":4319,"startups":4320,"2107":4321,"relative":4322,"hotline":4323,"marks":4324,"DomKM":4325,"ATI":4326,"Blitzstein":4327,"Accounting":4328,"braries":4329,"Discussions100":4330,"Binary":4331,"Findings":4332,"extra":4333,"1.8":4334,"Miller":4335,"IPython":4336,"RRR":4337,"Luan":4338,"ALSO":4339,"taste":4340,"RAMP":4341,"agents":4342,"601":4343,"transformer":4344,"codified":4345,"00610":4346,"despite":4347,"131":4348,"Yutaro":4349,"NativeBatchNormBackward0":4350,"998":4351,"𝜷":4352,"Jaggi":4353,"suited":4354,"keepdims":4355,"constrain":4356,"radically":4357,"cleverness":4358,"Law":4359,"99995":4360,"coat":4361,"opinions":4362,"previously":4363,"hypotenuse":4364,"DDR4":4365,"gathering":4366,"decade":4367,"projected":4368,"设":4369,"Baraldi":4370,"NextSentencePred":4371,"2206":4372,"11325":4373,"over":4374,"Exact":4375,"impen":4376,"boost":4377,"desiderata":4378,"ES":4379,"sessions":4380,"dims":4381,"382":4382,"Investments":4383,"workloads":4384,"recommendations":4385,"socially":4386,"Fidelity":4387,"817":4388,"sensible":4389,"0624":4390,"𝑒":4391,"oh":4392,"photo":4393,"deposits":4394,"Khvedchenya":4395,"Oracle":4396,"transfor":4397,"disastrous":4398,"Closely":4399,"intractable":4400,"disregard":4401,"Graviton":4402,"node":4403,"shifts":4404,"discover":4405,"★":4406,"Corporate":4407,"likeli":4408,"infinitesimally":4409,"return":4410,"exclusively":4411,"Locality":4412,"Sunday":4413,"734384":4414,"hopefully":4415,"modeler":4416,"GELUs":4417,"unweighted":4418,"15370":4419,"unexercised":4420,"95%":4421,"000073":4422,"booming":4423,"120th":4424,"mapping":4425,"extrapolation":4426,"tv":4427,"nats":4428,"requiring":4429,"DDR":4430,"Bethge":4431,"Alignment":4432,"fragments":4433,"Ge":4434,"shards":4435,"carries":4436,"Implement":4437,"crisper":4438,"interpretable":4439,"stress":4440,"Henighan":4441,"Discussions154":4442,"acceptability":4443,"TABLE":4444,"sought":4445,"Kaluarachchi":4446,"seeds":4447,"266%":4448,"107":4449,"promote":4450,"defend":4451,"Processing":4452,"904":4453,"paying":4454,"Ammar":4455,"i":4456,"listings":4457,"Authority":4458,"Effectively":4459,"Ring":4460,"Warm":4461,"Flex":4462,"Platforms":4463,"outbreak":4464,"Steve":4465,"keen":4466,"hap":4467,"hired":4468,"Locate":4469,"branches":4470,"1406":4471,"prop":4472,"2210":4473,"tech":4474,"us":4475,"cauchy":4476,"Wednesday":4477,"Change":4478,"corrupting":4479,"put":4480,"surro":4481,"incorporate":4482,"Lucid":4483,"rehearing":4484,"lenet":4485,"analog":4486,"squares":4487,"June":4488,"Levin":4489,"Dive":4490,"增强":4491,"Luckily":4492,"PKU":4493,"maintained":4494,"pays":4495,"Conditional":4496,"nities":4497,"shjustinbaek":4498,"Introduced":4499,"matically":4500,"大型":4501,"Leonard":4502,"prevalence":4503,"polarities":4504,"inferencing":4505,"initialized":4506,"0604":4507,"individually":4508,"disentangling":4509,"nondifferentiable":4510,"snap":4511,"0007":4512,"streamlined":4513,"tedious":4514,"668":4515,"repository":4516,"equivalently":4517,"halt":4518,"laptop":4519,"plotting":4520,"1533":4521,"111":4522,"3072":4523,"German":4524,"02558173674804846":4525,"1910":4526,"increasingly":4527,"inte":4528,"1905":4529,"7500":4530,"personnel":4531,"support":4532,"bothered":4533,"scheme":4534,"12024":4535,"Asimov":4536,"action":4537,"interacted":4538,"899840":4539,"hides":4540,"Zachary":4541,"Mattersight":4542,"InputBlaster":4543,"sport":4544,"larger":4545,"setups":4546,"saying":4547,"Idle":4548,"News":4549,"Apple":4550,"PLX":4551,"avoid":4552,"au":4553,"My":4554,"PC":4555,"Integration":4556,"Rajchandra":4557,"coincided":4558,"cardinality":4559,"called":4560,"Calculus":4561,"meet":4562,"031":4563,"standalone":4564,"subcontractors":4565,"94646ad1522d915e7b0f9296181140edcf86a4f5":4566,"supplying":4567,"357":4568,"391":4569,"Transformation":4570,"ℎ":4571,"5035":4572,"222814":4573,"chronously":4574,"totaling":4575,"8370":4576,"impeded":4577,"SHARES":4578,"ethnically":4579,"agreed":4580,"catalyzed":4581,"redefine":4582,"si":4583,"30000":4584,"02940":4585,"Discovery":4586,"rw":4587,"sionality":4588,"396":4589,"represented":4590,"orous":4591,"cuting":4592,"fear":4593,"texture":4594,"Freitas":4595,"Algebra":4596,"expiration":4597,"providing":4598,"largest":4599,"capitalizations":4600,"9052":4601,"exists":4602,"cognitive":4603,"Naturally":4604,"Sohl":4605,"375":4606,"__.":4607,"COVID":4608,"Del":4609,"shown":4610,"reigned":4611,"administration":4612,"77":4613,"Multinomial":4614,"a":4615,"Azizpour":4616,"2439":4617,"trap":4618,"chapter":4619,"cooled":4620,"Vladimir":4621,"manuel":4622,"multistep":4623,"led":4624,"comprehensive":4625,"prose":4626,"mou":4627,"Positionwise":4628,"Julia":4629,"parity":4630,"Hasan":4631,"uninhibited":4632,"elaborating":4633,"3274":4634,"Occam":4635,"Java":4636,"855":4637,"asymp":4638,"46.18621024399691":4639,"第二季":4640,"abstractive":4641,"intelligent":4642,"repeated":4643,"concatenate":4644,"ingenuity":4645,"perceived":4646,"lkopf":4647,"usu":4648,"Significantly":4649,"30":4650,"Whr":4651,"seek":4652,"Recomputing":4653,"caching":4654,"squaring":4655,"attribution":4656,"ReSKGC":4657,"Berg":4658,"arrows":4659,"gca":4660,"demands":4661,"Assurance":4662,"Shlens":4663,"widths":4664,"pip":4665,"Vol":4666,"infinitely":4667,"A.7":4668,"equality":4669,"Bommasani":4670,"eminently":4671,"retail":4672,"unstable":4673,"4354":4674,"underdetermined":4675,"Statisti":4676,"surprisingly":4677,"1.76":4678,"<":4679,"ParNet":4680,"rewrites":4681,"RAM":4682,"completeness":4683,"shutter":4684,"2379":4685,"African":4686,"stochastic":4687,"7542":4688,"0089":4689,"management":4690,"Texas":4691,"1208":4692,"unfitness":4693,"273898":4694,"ned":4695,"6741":4696,"™":4697,"219":4698,"dedicate":4699,"approvals":4700,"Human":4701,"Finite":4702,"occasional":4703,"blk":4704,"1600W":4705,"Stable":4706,"状态":4707,"RNNLM":4708,"639":4709,"matmul":4710,"s":4711,"Computershare":4712,"contour":4713,"DONALD":4714,"436":4715,"Worked":4716,"ticks":4717,"SAP":4718,"Fubini":4719,"backend":4720,"stimulate":4721,"caption":4722,"appearing":4723,"realm":4724,"Chung":4725,"3B":4726,"precomputed":4727,"Tipping":4728,"succession":4729,"conclusion":4730,"rb":4731,"joined":4732,"comprise":4733,"examine":4734,"A.9":4735,"edits":4736,"1.0974":4737,"strongest":4738,"183187":4739,"Gordon":4740,"damage":4741,"conceptual":4742,"reparametrization":4743,"Debt":4744,"Essence":4745,"careful":4746,"ARCHITECTURE":4747,"fire":4748,"parallel":4749,"Khoshgoftaar":4750,"StepLR":4751,"Bridging":4752,"complication":4753,"neuroscience":4754,"Duy":4755,"361":4756,"played":4757,"budgets":4758,"insights":4759,"fortune":4760,"P6":4761,"experimentation":4762,"171":4763,"citations":4764,"Match":4765,"pr":4766,"Ozair":4767,"buying":4768,"Kubicek":4769,"prototypical":4770,"thereby":4771,"pertinent":4772,"hundreds":4773,"aside":4774,"Dynamics":4775,"bases":4776,"boycotts":4777,"prohibitively":4778,"Establishes":4779,"permissible":4780,"863":4781,"Convergence":4782,"undiagnosed":4783,"asserted":4784,"bachelor":4785,"Concatenating":4786,"sheep":4787,"refresher":4788,"Approves":4789,"protective":4790,"emulate":4791,"alternatively":4792,"tagger":4793,"householding":4794,"regressors":4795,"removes":4796,"siderations":4797,"bringing":4798,"iters":4799,"nik":4800,"15.5":4801,"Fumero":4802,"continuity":4803,"pertains":4804,"Lift":4805,"7587":4806,"justifiably":4807,"pixels":4808,"Discussions162":4809,"prevents":4810,"GFLOPs":4811,"lowerrights":4812,"Simulateur":4813,"Transform":4814,"Yes":4815,"Reconstruction":4816,"belief":4817,"REQUEST":4818,"1672":4819,"Igor":4820,"Lomeli":4821,"5de26c8fce5ccdea9f91267273464dc968d20d72":4822,"feel":4823,"CRF":4824,"Liked":4825,"represents":4826,"Aim":4827,"debiases":4828,"18000":4829,"built":4830,"vivid":4831,"968":4832,"1351":4833,"AIGC":4834,"chip":4835,"1e":4836,"A.27":4837,"General":4838,"Offset":4839,"dictable":4840,"surrounds":4841,"injecting":4842,"32%":4843,"sported":4844,"99%":4845,"Updates":4846,"Probing":4847,"23%":4848,"lag":4849,"triever":4850,"Computation":4851,"IPC":4852,"Veit":4853,"pledge":4854,"Designated":4855,"1493":4856,"uncorrelated":4857,"774":4858,"SoftBank":4859,"tools":4860,"QK":4861,"advent":4862,"persists":4863,"intensity":4864,"photography":4865,"Wiley":4866,"pairs":4867,"Emirates":4868,"400001":4869,"histories":4870,"Gen":4871,"frameworks":4872,"temperatures":4873,"people":4874,"memorization":4875,"Singh":4876,"AudioLDM":4877,"CSP":4878,"him":4879,"reinforced":4880,"polysemy":4881,"196101":4882,"cians":4883,"rapid":4884,"336183":4885,"sockets":4886,"closures":4887,"nonequilibrium":4888,"lambdas":4889,"preferable":4890,"pleasant":4891,"onboarding":4892,"年龄":4893,"chemical":4894,"deriva":4895,"whole":4896,"Akad":4897,"141":4898,"SynthesizedImage":4899,"225d66f04cae318b841a13d32af3acc165f253ac":4900,"swering":4901,"literally":4902,"significance":4903,"vlines":4904,"hind":4905,"morphological":4906,"Inherent":4907,"Increased":4908,"Mishra":4909,"intend":4910,"cues":4911,"generates":4912,"loc":4913,"penalize":4914,"pulse":4915,"avenues":4916,"sinh":4917,"Correction":4918,"GRetriever":4919,"06318":4920,"Gimpel":4921,"∼":4922,"immense":4923,"resolved":4924,"gained":4925,"Golub":4926,"SGDR":4927,"decimal":4928,"particular":4929,"Sparse":4930,"2960420911378594":4931,"satisfies":4932,"miss":4933,"zone":4934,"classical":4935,"2g":4936,"fresh":4937,"emits":4938,"speeding":4939,"thorough":4940,"624":4941,"0%":4942,"erative":4943,"bilingual":4944,"1700s":4945,"header":4946,"1807":4947,"Qu":4948,"Riemann":4949,"burden":4950,"factoid":4951,"setattr":4952,"sheet":4953,"Field":4954,"SGD":4955,"0822":4956,"tensorflow":4957,"League":4958,"Fosler":4959,"1212":4960,"BERTClassifier":4961,"mutually":4962,"Maxwell":4963,"prominent":4964,"1052":4965,"Var":4966,"机制":4967,"elers":4968,"truncate":4969,"Quantization":4970,"proof":4971,"Realized":4972,"function91":4973,"785":4974,"transcend":4975,"433":4976,"alternates":4977,"manufactured":4978,"augments":4979,"annual":4980,"二季度":4981,"peaks":4982,"827":4983,"notes169":4984,"positive":4985,"serviceability":4986,"Keyword":4987,"grapple":4988,"relations":4989,"Formalize":4990,"pieces":4991,"terminals":4992,"energy":4993,"departments":4994,"系统":4995,"tags":4996,"Zen":4997,"GMT":4998,"underutilization":4999,"ization":5000,"societal":5001,"dominant":5002,"backpropgation":5003,"partnering":5004,"hosts":5005,"aggressive":5006,"lookup":5007,"ilar":5008,"aftermarket":5009,"memorizers":5010,"device":5011,"evi":5012,"highlights":5013,"Fellowship":5014,"165":5015,"grander":5016,"04085":5017,"Rather":5018,"monomial":5019,"evenly":5020,"037":5021,"tweaking":5022,"gym":5023,"3am":5024,"virtue":5025,"japan":5026,"NeuroNimes":5027,"Statistical":5028,"freedoms":5029,"cancellation":5030,"Kuksa":5031,"milder":5032,"fabrication":5033,"firmware":5034,"477":5035,"hack":5036,"goodwill":5037,"750":5038,"liabilities":5039,"installation":5040,"Economy":5041,"supplier":5042,"KD":5043,"Purpose":5044,"Aarti":5045,"B.5":5046,"odds":5047,"contrary":5048,"tokenized":5049,"1.7":5050,"Discussions281":5051,"decodings":5052,"bigger":5053,"impressive":5054,"BERTLARGE":5055,"1061":5056,"derivations":5057,"1002":5058,"undefined":5059,"root":5060,"explanations":5061,"Sherrington":5062,"church":5063,"_.":5064,"Incorporation":5065,"044":5066,"𝑖":5067,"typical":5068,"motorbike":5069,"instances202":5070,"11.93":5071,"937":5072,"尤其":5073,"cov":5074,"concurrent":5075,"205":5076,"Transla":5077,"happily":5078,"looking":5079,"intervals":5080,"administers":5081,"919":5082,"Notation":5083,"cations":5084,"AdaptiveMaxPool2d":5085,"interactive":5086,"ordinal":5087,"conditional":5088,"Questions":5089,"hear":5090,"mll":5091,"Ability":5092,"enable":5093,"366":5094,"Observational":5095,"997":5096,"trigonometric":5097,"Opportunities":5098,"windows":5099,"备注":5100,"counterparties":5101,"picturing":5102,"flags":5103,"Cancer":5104,"tern":5105,"you":5106,"unstructured":5107,"subsidiary":5108,"cheating":5109,"011548":5110,"083":5111,"Effective":5112,"15131":5113,"arranging":5114,"RUN":5115,"Assuming":5116,"Qinhan":5117,"PTBDataset":5118,"event":5119,"Denil":5120,"151":5121,"partial":5122,"evaluated":5123,"ComposeTransform":5124,"representing":5125,"supercharged":5126,"sponding":5127,"076646":5128,"seeks":5129,"RSU":5130,"stemming":5131,"ignoring":5132,"guaran":5133,"ones":5134,"achievements":5135,"strictions":5136,"ilkermetinkursova":5137,"limit":5138,"analogously":5139,"Yunteng":5140,"Recommendation":5141,"parametrized":5142,"pokemondb276":5143,"outperformed":5144,"optima":5145,"2567":5146,"ImageNet":5147,"stores":5148,"047":5149,"retrospect":5150,"90":5151,"threshold":5152,"electricity":5153,"serious":5154,"782":5155,"correspondence":5156,"Exposed":5157,"TextDataset":5158,"Pratik":5159,"respective":5160,"talks":5161,"216":5162,"neighborhood":5163,"370":5164,"exposes":5165,"𝑇":5166,"chi":5167,"protypical":5168,"multiplying":5169,"orthog":5170,"adursun":5171,"Hey":5172,"Barnett":5173,"homebuilding":5174,"guarantees":5175,"arsenals":5176,"928":5177,"Macherey":5178,"reverse":5179,"Problem":5180,"448":5181,"14323":5182,"Ott":5183,"2000s":5184,"sophisti":5185,"Help":5186,"discount":5187,"burdens":5188,"volume":5189,"int":5190,"0.8477":5191,"Supply":5192,"norms":5193,"recovering":5194,"diving":5195,"cycles":5196,"handling":5197,"symbols":5198,"Peilin":5199,"814":5200,"subtract":5201,"Saravia":5202,"01795":5203,"Karnin":5204,"probabilis":5205,"Ellie":5206,"Clark":5207,"antitrust":5208,"consummate":5209,"274":5210,"polynomial":5211,"periodicity":5212,"asserting":5213,"252":5214,"Singapore":5215,"register":5216,"ring":5217,"Synchronization":5218,"yesterday":5219,"totaled":5220,"Hong":5221,"zhao":5222,"793":5223,"RandomSearch":5224,"cifar":5225,"x3":5226,"508":5227,"Motivating":5228,"extracts":5229,"Warstadt":5230,"Dr":5231,"shopping":5232,"Nodar":5233,"Types":5234,"invalidation":5235,"0.048":5236,"453":5237,"defaults":5238,"trumps":5239,"conceptualized":5240,"fastText":5241,"Fifth":5242,"𝑅":5243,"redundancy":5244,"Contrast":5245,"45th":5246,"mse":5247,"lets":5248,"tershed":5249,"boyfriend":5250,"overseen":5251,"interfere":5252,"pos":5253,"immediate":5254,"elab":5255,"Neal":5256,"Nobody":5257,"Summary":5258,"assesses":5259,"focus":5260,"922":5261,"relationships":5262,"Musthafa":5263,"Hubel":5264,"returning":5265,"HW":5266,"1023":5267,"Pipelines":5268,"volumes":5269,"dictive":5270,"critique":5271,"3643":5272,"unfold":5273,"Worldwide":5274,"fallacy":5275,"Times":5276,"ory":5277,"18e":5278,"Stojnic":5279,"𝑌":5280,"exotic":5281,"misstatements":5282,"0001":5283,"tal":5284,"175":5285,"transporting":5286,"8226":5287,"⊈":5288,"separated":5289,"Id":5290,"Repayment":5291,"Luby":5292,"bn1":5293,"uninstall":5294,"offset":5295,"Attention":5296,"Raina":5297,"Lukasiewicz":5298,"normalizes":5299,"Alibaba":5300,"658":5301,"NNP":5302,"VGG":5303,"binocular":5304,"synchronous":5305,"ellipsoid":5306,"746":5307,"inferences":5308,"Explor":5309,"sharper":5310,"pipelines":5311,"calculation":5312,"independence":5313,"probabil":5314,"vague":5315,"rectangle":5316,"Generation":5317,"semiconductor":5318,"hats":5319,"refractions":5320,"lingual":5321,"interspersing":5322,"267":5323,"ZEEKR":5324,"556":5325,"richer":5326,"spectrum":5327,"44.7":5328,"sentinel":5329,"FixedHiddenMLP":5330,"JEN":5331,"Spaces":5332,"action2dxdy":5333,"marrying":5334,"Note":5335,"Well":5336,"Renesas":5337,"exporting":5338,"270":5339,"qualify":5340,"Katarzyna":5341,"nally":5342,"Variance":5343,"acquainted":5344,"closing":5345,"invents":5346,"shortest":5347,"IJCAI":5348,"Fangcheng":5349,"Kahane":5350,"KnowledgeNavigator":5351,"clinical":5352,"incorporating":5353,"ammunition":5354,"rithms":5355,"Avatar":5356,"greedily":5357,"colloquially":5358,"commit":5359,"Cappelli":5360,"64":5361,"laude":5362,"insufficient":5363,"jit":5364,"conf":5365,"NL":5366,"steps":5367,"SKR":5368,"seven":5369,"bootcamp":5370,"merits":5371,"pable":5372,"premium":5373,"1404":5374,"respectively":5375,"280":5376,"2150":5377,"475":5378,"transfers":5379,"amended":5380,"clothing":5381,"verges":5382,"Medina":5383,"Henderson":5384,"demonstrate":5385,"0.0967":5386,"9A":5387,"synergy":5388,"Submit":5389,"1067":5390,"Notably":5391,"regular":5392,"arrives":5393,"timators":5394,"Calculate":5395,"Ye":5396,"Origin":5397,"imread":5398,"commands":5399,"Alberti":5400,"12869":5401,"Meduri":5402,"impairing":5403,"Format":5404,"stant":5405,"analogy":5406,"resilient":5407,"CAD":5408,"MaxPool2d":5409,"ordinary":5410,"Piperag":5411,"Rogers":5412,"Qx":5413,"02811":5414,"Signing":5415,"T":5416,"mathematically":5417,"widened":5418,"progresses":5419,"numerous":5420,"Ap":5421,"Fact":5422,"4169e":5423,"08415":5424,"pioneered":5425,"Water":5426,"cheated":5427,"Health":5428,"denois":5429,"biguously":5430,"b3":5431,"9649":5432,"Keane":5433,"legend":5434,"chassis":5435,"superresolution":5436,"Skills":5437,"singular":5438,"Colette":5439,"Information":5440,"restructures":5441,"downsides":5442,"cube":5443,"rat":5444,"cleverly":5445,"K1":5446,"succeed":5447,"manufacturing":5448,"presence":5449,"daisy":5450,"Norelli":5451,"Prakhar":5452,"crucial":5453,"perusing":5454,"thanks":5455,"6b50d":5456,"Before":5457,"env":5458,"Pretraining":5459,"finetune":5460,"1492":5461,"655":5462,"duration":5463,"gating":5464,"headquartered":5465,"Covariance":5466,"modest":5467,"its":5468,"Address":5469,"Patil":5470,"ERM":5471,"breeze":5472,"cuda":5473,"Hoeffding":5474,"semidefinite":5475,"FiD":5476,"Unfortunately":5477,"EACL":5478,"rotation":5479,"Possible":5480,"Numerator":5481,"xo":5482,"transform":5483,"322":5484,"trip":5485,"concepts":5486,"surrogates":5487,"Ioffe":5488,"Source":5489,"smooth":5490,"irrespective":5491,"freq":5492,"functions":5493,"Parisotto":5494,"cx":5495,"democratized":5496,"Swami":5497,"intricate":5498,"underscored":5499,"Board":5500,"1005":5501,"nbatch":5502,"170":5503,"write":5504,"spatialized":5505,"Sim":5506,"computational":5507,"satisfactory":5508,"withdrawal":5509,"pars":5510,"Boltzmann":5511,"Physical":5512,"00270":5513,"CLARA":5514,"referenced":5515,"Waibel":5516,"stretch":5517,"Den":5518,"271":5519,"135":5520,"snippet":5521,"codify":5522,"toddler":5523,"footprint":5524,"Style":5525,"educate":5526,"Twelve":5527,"wellness":5528,"jaccard":5529,"disaster":5530,"BasicScheduler":5531,"dilution":5532,"hc":5533,"convenient":5534,"dvincent1337":5535,"generation":5536,"它会":5537,"Newton":5538,"spotting":5539,"diseased":5540,"B.6":5541,"straightforwardly":5542,"Maron":5543,"ImageFolder":5544,"estimating":5545,"109":5546,"flips":5547,"integrations":5548,"rpm":5549,"Convolu":5550,"representa":5551,"saves":5552,"Sales":5553,"BookCorpus":5554,"Immorlica":5555,"ODIS":5556,"vertices":5557,"850":5558,"ethical":5559,"eralization":5560,"Seq2SeqAttentionDecoder":5561,"4785":5562,"1b1":5563,"191":5564,"包含":5565,"Sons":5566,"fly":5567,"reimbursed":5568,"registrations":5569,"2500":5570,"888":5571,"debug":5572,"DRIVE":5573,"DOCUMENTS":5574,"5378":5575,"polation":5576,"tenured":5577,"hyper":5578,"NIO":5579,"mnemonic":5580,"venience":5581,"产品":5582,"descriptive":5583,"18.2":5584,"confirms":5585,"MaxPooling":5586,"Strip":5587,"allocation":5588,"Lavin":5589,"Sutskever":5590,"passenger":5591,"Combining":5592,"instances":5593,"considered":5594,"backups":5595,"Advances":5596,"excels":5597,"0.5993":5598,"spired":5599,"participate":5600,"434274":5601,"encapsulated":5602,"reinforcement":5603,"involve":5604,"1943":5605,"02816":5606,"xf":5607,"uations":5608,"GBE":5609,"speci":5610,"246":5611,"CAC":5612,"informally":5613,"dataset108":5614,"Utility":5615,"gether":5616,"Challenges":5617,"culminated":5618,"F":5619,"29442952580755816":5620,"rongruosong":5621,"substantial":5622,"catenating":5623,"requires":5624,"became":5625,"Associates":5626,"autonomy":5627,"ReMoDiffuse":5628,"Discussions265":5629,"principle":5630,"11278":5631,"eclipse":5632,"offer":5633,"Instances":5634,"764":5635,"deductions":5636,"Bougares":5637,"power":5638,"ery":5639,"RandomHorizontalFlip":5640,"wheels":5641,"practi":5642,"developer":5643,"editors":5644,"denoted":5645,"Planck":5646,"spots":5647,"optionally":5648,"filer":5649,"6105":5650,"Underfitting":5651,"midrange":5652,"WEATHER":5653,"automated":5654,"Employee":5655,"004":5656,"animals":5657,"reinstated":5658,"recruit":5659,"fed":5660,"shallow":5661,"incurring":5662,"Remodiffuse":5663,"1022":5664,"regu":5665,"Still":5666,"Discussions245":5667,"Underlying":5668,"Readings":5669,"advising":5670,"notional":5671,"Nerveux":5672,"transmitter":5673,"understands":5674,"Extreme":5675,"flag":5676,"hopes":5677,"approximation":5678,"331":5679,"inch":5680,"1460":5681,"Persons":5682,"Khattab":5683,"warehousing":5684,"014076038679980779":5685,"trucks":5686,"cats":5687,"devoted":5688,"Transposed":5689,"searching":5690,"Vishwesh":5691,"eigenspaces":5692,"Szegedy":5693,"Mucs":5694,"811":5695,"economic":5696,"Linnaeus":5697,"Rezende":5698,"imizer":5699,"1109":5700,"tonzhang":5701,"observations":5702,"precon":5703,"rel":5704,"SECTION":5705,"Cancellation":5706,"Graves":5707,"OpenVino":5708,"1056":5709,"OU":5710,"Outstanding":5711,"p3.2":5712,"834111":5713,"drastic":5714,"pseudorandom":5715,"back":5716,"Bollob":5717,"03963":5718,"hotfix":5719,"1912":5720,"rush":5721,"uncer":5722,"prohibit":5723,"993":5724,"dark":5725,"Mead":5726,"VII":5727,"thriving":5728,"times":5729,"messages":5730,"model":5731,"2f":5732,"longstanding":5733,"c3":5734,"operated":5735,"GPG":5736,"empirical":5737,"domestically":5738,"0.02":5739,"occupies":5740,"truera":5741,"ONE":5742,"Massachusetts":5743,"4097":5744,"mispredict":5745,"Convince":5746,"是":5747,"ternative":5748,"183":5749,"Schaar":5750,"ylabel":5751,"proba":5752,"Singer":5753,"numerator":5754,"Industrial":5755,"combine":5756,"criminal":5757,"effort":5758,"00426":5759,"indemnitees":5760,"ddof":5761,"suffi":5762,"1.1":5763,"thresholds":5764,"PARC":5765,"Hill":5766,"659":5767,"loop":5768,"Rolnick":5769,"somewhat":5770,"regulators":5771,"appendix":5772,"Discussions219":5773,"notably":5774,"Azoulay":5775,"0.153":5776,"Tan":5777,"checkout":5778,"Billion":5779,"TRANX":5780,"715":5781,"bandwidth":5782,"parallelograms":5783,"coordinates":5784,"technical":5785,"pooling":5786,"088":5787,"948":5788,"Itoh":5789,"0.85":5790,"what":5791,"Pull":5792,"sewage":5793,"Minibatches":5794,"neurones":5795,"consequential":5796,"CODEGEN":5797,"soning":5798,"rich":5799,"nd":5800,"reconstructed":5801,"sh":5802,"Corston":5803,"succinctness":5804,"p":5805,"falter":5806,"dv":5807,"Almeida":5808,"Cloudera":5809,"mentwise":5810,"characteristic":5811,"decouple":5812,"household":5813,"¶":5814,"Removing":5815,"11271":5816,"controlled":5817,"elections":5818,"Peripherals":5819,"Tao":5820,"867":5821,"0.00176955":5822,"Convolution":5823,"BlackRock":5824,"Caffe":5825,"professionals":5826,"943":5827,"Hybrid":5828,"roll":5829,"Xw":5830,"tweaks":5831,"Jie":5832,"Terms":5833,"normaliza":5834,"helper":5835,"Ordered":5836,"Mikhail":5837,"IMAGE":5838,"lim":5839,"Jampani":5840,"noted":5841,"convergence":5842,"ASAP":5843,"Digital":5844,"1098":5845,"P8":5846,"introductory":5847,"Donald":5848,"JDS":5849,"tilde":5850,"Lugosi":5851,"careless":5852,"remedies":5853,"examined":5854,"816":5855,"Saddle":5856,"influential":5857,"217289":5858,"plex":5859,"156":5860,"Total":5861,"页眉":5862,"innocent":5863,"Wu":5864,"Horne":5865,"remembers":5866,"rule":5867,"opposite":5868,"1.6809":5869,"mechanism":5870,"monochro":5871,"legally":5872,"LinearRegression":5873,"exposed":5874,"Discussions17":5875,"19th":5876,"Dropping":5877,"100%":5878,"instantiate":5879,"Rare":5880,"Popper":5881,"reconciliation":5882,"predates":5883,"standardization":5884,"ChatGPT164":5885,"VioNet":5886,"abroad":5887,"beneficial":5888,"Structured":5889,"Calculation":5890,"noncompliance":5891,"partition":5892,"word2vec":5893,"harm":5894,"972":5895,"exponentiating":5896,"connections":5897,"privately":5898,"shocked":5899,"cmf":5900,"20e":5901,"served":5902,"↦":5903,"Revealing":5904,"Nearby":5905,"summable":5906,"little":5907,"Dimensional":5908,"LazyLinear":5909,"763":5910,"certified":5911,"Donahue":5912,"Vanishing":5913,"von":5914,"Incorporate":5915,"advice":5916,"REALM":5917,"7262":5918,"characterize":5919,"Trees":5920,"after":5921,"brokerage":5922,"1077":5923,"tualized":5924,"everyone":5925,"bars":5926,"triangles":5927,"boosts":5928,"unauthorized":5929,"xxxiv":5930,"China":5931,"concisely":5932,"logues":5933,"Points":5934,"The":5935,"gready":5936,"Informa":5937,"NVL72":5938,"Obtaining":5939,"2th":5940,"Yue":5941,"pronouns":5942,"OK":5943,"formulate":5944,"NP":5945,"infused":5946,"day":5947,"cos2":5948,"mentor":5949,"immanent":5950,"startswith":5951,"intentionally":5952,"perfectly":5953,"528166":5954,"cording":5955,"capitalization":5956,"predefine":5957,"106":5958,"sprites":5959,"differ":5960,"1076":5961,"Blues":5962,"984":5963,"Statis":5964,"cartoonish":5965,"fronts":5966,"waiver":5967,"w":5968,"furthered":5969,"Activity":5970,"ndarrays":5971,"steam":5972,"8889":5973,"03374":5974,"retrieval":5975,"pharmaceutical":5976,"Think":5977,"Hallacy":5978,"stead":5979,"Document":5980,"associ":5981,"(":5982,"10446":5983,"ulously":5984,"Initialization":5985,"Leibler":5986,"bottlenecks":5987,"Megatron":5988,"sanctity":5989,"912":5990,"AVGO":5991,"Staten":5992,"Progress":5993,"Jerzy":5994,"0.229":5995,"explanation":5996,"optical":5997,"programs":5998,"mammalian":5999,"imgs":6000,"Segments":6001,"2215":6002,"token":6003,"Startups":6004,"clearly":6005,"˜":6006,"08056711961080017":6007,"Hudson":6008,"Decomposition":6009,"01211":6010,"154":6011,"kwargs":6012,"terminated":6013,"TensorFlow":6014,"decoupling":6015,"giom":6016,"la":6017,"Fidler":6018,"Gems":6019,"maze":6020,"Skipping":6021,"FactorScheduler":6022,"admits":6023,"bad":6024,"summariza":6025,"elif":6026,"ify":6027,"WD":6028,"28":6029,"interleave":6030,"Tijsseling":6031,"CRM":6032,"K2":6033,"Afterall":6034,"Euro":6035,"overlooks":6036,"ratios":6037,"organic":6038,"SelfMemory":6039,"adagrad":6040,"HDDs":6041,"2696":6042,"binary":6043,"nltk":6044,"profile":6045,"Highway":6046,"Roossin":6047,"jointly":6048,"1483":6049,"area":6050,"Dahl":6051,"shedding":6052,"develop":6053,"Bain":6054,"DAIR":6055,"引言":6056,"misleading":6057,"supply":6058,"Report":6059,"Discussions179":6060,"pour":6061,"Shrimali":6062,"Weighted":6063,"fines":6064,"firms":6065,"900009":6066,"Skcoder":6067,"TD":6068,"without":6069,"一些":6070,"tiveness":6071,"polytechnic":6072,"10428":6073,"Insider":6074,"transcript":6075,"showcased":6076,"highest":6077,"EfficientNets":6078,"RKHS":6079,"MAY":6080,"0.0030":6081,"Reputation":6082,"skies":6083,"584":6084,"abbreviate":6085,"centralized":6086,"snack":6087,"0.0992":6088,"Its":6089,"异步":6090,"combinations":6091,"robotics":6092,"inquired":6093,"hotel":6094,"ipynb":6095,"rendering":6096,"Music":6097,"Excessive":6098,"Units":6099,"2788":6100,"Petersen":6101,"Discussions222":6102,"q2":6103,"0003":6104,"Wei":6105,"stretched":6106,"Whi":6107,"direct":6108,"enterprises":6109,"stumble":6110,"propagate":6111,"GRG":6112,"Goal":6113,"Sandler":6114,"imate":6115,"Researchers":6116,"Applied":6117,"flattens":6118,"ratifying":6119,"Growth":6120,"Word":6121,"881":6122,"Expert":6123,"1404876708984375":6124,"pondering":6125,"promptly":6126,"ViTMLP":6127,"57":6128,"Optical":6129,"718":6130,"3000":6131,"replacement":6132,"1989":6133,"extensively":6134,"Bank":6135,"Representing":6136,"normalizing":6137,"number":6138,"nondisclosure":6139,"Customization":6140,"617":6141,"interesting":6142,"NLP":6143,"org":6144,"MaoMao":6145,"ubuntu2204":6146,"Ommer":6147,"Blockers":6148,"converted":6149,"Cubed":6150,"predictions":6151,"Res":6152,"Perform":6153,"1701":6154,"Faithfulness":6155,"determinazione":6156,"VMware":6157,"40e":6158,"Ben":6159,"Virtual":6160,"0.054":6161,"Graphics":6162,"Ornstein":6163,"Jannach":6164,"金额":6165,"类别":6166,"expands":6167,"live":6168,"comprehend":6169,"students":6170,"Required":6171,"NEC":6172,"audits":6173,"426":6174,"online3":6175,"lowercased":6176,"Notices":6177,"display":6178,"technology":6179,"verification":6180,"sliver":6181,"bigrams":6182,"Bookeeping":6183,"Attributes":6184,"front":6185,"personally":6186,"3119":6187,"Dialogue":6188,"Kale":6189,"indepen":6190,"vulnerabilities":6191,"procedures":6192,"adjective":6193,"systolic":6194,"039036":6195,"ccchengff":6196,"06117":6197,"Not":6198,"Simard":6199,"Exculpation":6200,"provisions":6201,"amazon":6202,"customer":6203,"dev":6204,"teen":6205,"exposures":6206,"uninformative":6207,"neighbor":6208,"squared":6209,"dom":6210,"bet":6211,"ch11":6212,"intertwined":6213,"0.927":6214,"Yashunin":6215,"Dirichlet":6216,"365109":6217,"549":6218,"bag":6219,"Suite":6220,"comedies":6221,"705":6222,"741":6223,"Helper":6224,"Computational":6225,"Corporation":6226,"cance":6227,"collapse":6228,"tested":6229,"tree":6230,"compu":6231,"arccos":6232,"Channels":6233,"tips":6234,"Teoriya":6235,"tendency":6236,"serendipitously":6237,"02311":6238,"sufficient":6239,"Query":6240,"118":6241,"excited":6242,"geogunow":6243,"treatments":6244,"434195":6245,"unclear":6246,"50d":6247,"Jouppi":6248,"Invariance":6249,"vanilla":6250,"875":6251,"talking":6252,"expensive":6253,"MVAPICH2":6254,"introducing":6255,"occurred":6256,"xxii":6257,"birdsong":6258,"seasonality":6259,"suite":6260,"signifying":6261,"09476":6262,"simplifies":6263,"shed":6264,"223485":6265,"successes":6266,"Reuse":6267,"rets":6268,"Passages":6269,"effectiveness":6270,"computing":6271,"Date":6272,"then":6273,"hit":6274,"relational":6275,"Reinwald":6276,"impair":6277,"adolescent":6278,"methodological":6279,"unsatisfactory":6280,"Ada":6281,"Decade":6282,"deliveries":6283,"Mercer":6284,"AV":6285,"Bang":6286,"detaching":6287,"considers":6288,"1.14":6289,"sold":6290,"Predictions":6291,"Proposals":6292,"curious":6293,"professionalism":6294,"sampler":6295,"suspended":6296,"1948":6297,"310455":6298,"1.3746":6299,"6375":6300,"sate":6301,"cmp":6302,"6th":6303,"Closing":6304,"Observed":6305,"908":6306,"Responsible":6307,"FisherSnedecor":6308,"history":6309,"adage":6310,"645":6311,"Sheynin":6312,"6875":6313,"Supermicro":6314,"skewed":6315,"xxix":6316,"rtel":6317,"unaligned":6318,"surgery":6319,"unambiguous":6320,"5805":6321,"Lane":6322,"degradation":6323,"grown":6324,"submitting":6325,"1434":6326,"Transaction":6327,"Mutual":6328,"Convexity":6329,"1035":6330,"Lukovenko":6331,"Poesia":6332,"tomorrow":6333,"014628":6334,"school":6335,"strive":6336,"Warmup":6337,"8.5":6338,"examination":6339,"crop":6340,"3526":6341,"propaga":6342,"368":6343,"successively":6344,"typos":6345,"opportunities":6346,"mension":6347,"ferentiate":6348,"A.30":6349,"logarithmic":6350,"gets":6351,"iloc":6352,"invoice":6353,"N":6354,"1b":6355,"lengthened":6356,"hardware":6357,"assembled":6358,"rearranging":6359,"HUDSON":6360,"acting":6361,"navigating":6362,"decided":6363,"revolve":6364,"tor":6365,"notation":6366,"entails":6367,"ancy":6368,"transparency":6369,"50000":6370,"00083":6371,"Za":6372,"boards":6373,"Regarding":6374,"↩":6375,"Propagation":6376,"tripod":6377,"conv3":6378,"etrable":6379,"3788":6380,"mount":6381,"Freeze":6382,"film":6383,"responses":6384,"198453":6385,"posted":6386,"alongside":6387,"Feedback":6388,"print":6389,"ć":6390,"Optimization":6391,"match":6392,"Market":6393,"WRITING":6394,"879":6395,"quake2005":6396,"troduces":6397,"possessing":6398,"leather":6399,"Gunrock":6400,"cs229":6401,"regob":6402,"compile":6403,"Improve":6404,"899920":6405,"outfitted":6406,"expected":6407,"referrals":6408,"ables":6409,"distinguished":6410,"提取":6411,"tenure":6412,"archi":6413,"cautionary":6414,"accumulate":6415,"019":6416,"vulnerable":6417,"distorts":6418,"began":6419,"Processors":6420,"tau":6421,"Whhh":6422,"fuss":6423,"generalizes":6424,"empirica":6425,"located":6426,"celebrity":6427,"Games":6428,"represen":6429,"Qiao":6430,"Gotmare":6431,"extraordinarily":6432,"fier":6433,"extravagant":6434,"ℱ":6435,"selects":6436,"agent":6437,"dormant":6438,"System":6439,"14.1":6440,"pathways":6441,"1043":6442,"elect":6443,"wastage":6444,"dimension":6445,"Formally":6446,"590":6447,"05108":6448,"ml":6449,"labor":6450,"convNet":6451,"479":6452,"ANN":6453,"Sigmoids":6454,"Prompt":6455,"Netflix":6456,"1550":6457,"grounded":6458,"logical":6459,"SEAWELL":6460,"Nguyen":6461,"Ab":6462,"Bojanowski":6463,"operation":6464,"mountain":6465,"441":6466,"Subject":6467,"troduced":6468,"Sourcing":6469,"peers":6470,"divide":6471,"linewidth":6472,"John":6473,"08845692598296777":6474,"Dou":6475,"equilibrium":6476,"criteria":6477,"trials":6478,"931":6479,"NLTK":6480,"Denominator":6481,"03":6482,"Measuring":6483,"paraphrase":6484,"vonenkis":6485,"ymax":6486,"Timothy":6487,"IDF":6488,"Efficiency":6489,"procure":6490,"Designing":6491,"74%":6492,"colormap2label":6493,"speculative":6494,"die":6495,"Iter":6496,"Knowledgenavigator":6497,"0.243":6498,"width":6499,"":6500,"092":6501,"negligible":6502,"Ð":6503,"inadequate":6504,"directing":6505,"feedbacks":6506,"Every":6507,"Der":6508,"Wierstra":6509,"0.83":6510,"sample":6511,"triques":6512,"interruptions":6513,"culminating":6514,"Maira":6515,"matrices":6516,"transcription":6517,"cool":6518,"McCandlish":6519,"Discussions67":6520,"cortex":6521,"3598":6522,"0591":6523,"mine":6524,"biological":6525,"LM":6526,"adheres":6527,"Each":6528,"VAE":6529,"resumes":6530,"defini":6531,"Production":6532,"°":6533,"Macroeconomic":6534,"L40":6535,"contest":6536,"0.126340":6537,"tection":6538,"效果":6539,"not":6540,"Scale":6541,"pages":6542,"resembles":6543,"configurations":6544,"Almaden":6545,"blurry":6546,"improvement":6547,"inconclusive":6548,"Expenses":6549,"elsewhere":6550,"1f":6551,"Barr":6552,"matic":6553,"decent":6554,"clearing":6555,"Wrong":6556,"Chevedden":6557,"Focus":6558,"negated":6559,"lating":6560,"downloads":6561,"854":6562,"Retriever":6563,"2347":6564,"Adam":6565,"craftsmanship":6566,"Discussions58":6567,"invoke":6568,"scipy":6569,"withheld":6570,"baseline":6571,"Detection":6572,"DataModule":6573,"Motion":6574,"hsneto":6575,"merged":6576,"resounding":6577,"Deepak":6578,"doc2":6579,"4782":6580,"Surprisal":6581,"Vollgraf":6582,"incorporat":6583,"multivariable":6584,"fulfill":6585,"overestimate":6586,"recip":6587,"Drive":6588,"Go250":6589,"McGraw":6590,"585":6591,"mance":6592,"86":6593,"raised":6594,"Memorizing":6595,"leadership":6596,"SQL":6597,"meteorology":6598,"gradually":6599,"cloud":6600,"distributors":6601,"Tufano":6602,"Primarily":6603,"esti":6604,"Generative":6605,"atten":6606,"mech":6607,"listdir":6608,"central":6609,"14942487313193167":6610,"rose":6611,"GANs":6612,"multilateral":6613,"AttentionDecoder":6614,"19473v6":6615,"lumped":6616,"Judg":6617,"Matthias":6618,"truly":6619,"176B":6620,"839":6621,"invariably":6622,"strengthen":6623,"peri":6624,"eigendecom":6625,"Shahriar":6626,"910":6627,"processor":6628,"Uppercase":6629,"Labeling":6630,"Contributing":6631,"P7":6632,"Discussions163":6633,"inject":6634,"compete":6635,"Fused":6636,"prompted":6637,"stunningly":6638,"yet":6639,"analysts":6640,"354":6641,"FSE":6642,"522":6643,"lunch":6644,"test":6645,"Recaptioning":6646,"-":6647,"619":6648,"provided":6649,"Constraining":6650,"Jia":6651,"Discussions240":6652,"painfully":6653,"492":6654,"underlie":6655,"characterized":6656,"stocks":6657,"Approximation":6658,"Because":6659,"Database":6660,"905":6661,"rela":6662,"it":6663,"Muller":6664,"9127":6665,"REDCODER":6666,"Layer":6667,"compensation":6668,"icantly":6669,"puter":6670,"2117":6671,"Discussions142":6672,"amortized":6673,"generators":6674,"attains":6675,"avg":6676,"A.23":6677,"Listing":6678,"gamer":6679,"Concretely":6680,"Inductive":6681,"Steering":6682,"ily":6683,"RINK":6684,"purportedly":6685,"rx":6686,"toolkits":6687,"文本":6688,"CoWoS":6689,"PERFORMANCE":6690,"Stockholder":6691,"hierarchies":6692,"neighboring":6693,"749":6694,"agnostic":6695,"Vi":6696,"membership":6697,"entities":6698,"Relating":6699,"Amortized":6700,"start":6701,"Reconciling":6702,"Nucleus":6703,"adopts":6704,"Howard":6705,"Discussions99":6706,"shaping":6707,"Accrued":6708,"regardent":6709,"IJCNLP":6710,"Debora":6711,"pretending":6712,"23445":6713,"455":6714,"projections":6715,"Represents":6716,"Decay":6717,"ramp":6718,"ABCs":6719,"protocols":6720,"VOCdevkit":6721,"6547":6722,"Supporting":6723,"Foundations":6724,"reimplement":6725,"employ":6726,"analo":6727,"indefinite":6728,"warrant":6729,"serialized":6730,"Dohan":6731,"1040":6732,"backbone":6733,"Kansas":6734,"instantiating":6735,"2405":6736,"Cucerzan":6737,"kNN":6738,"advanced":6739,"previous":6740,"Rubinfeld":6741,"attending":6742,"ured":6743,"xxvi":6744,"pace":6745,"73":6746,"Yet":6747,"incumbent":6748,"monoton":6749,"merging":6750,"puted":6751,"Double":6752,"Inves":6753,"cp":6754,"ber":6755,"tenant":6756,"Predicting":6757,"1.0957":6758,"Pennock":6759,"entirely":6760,"heel":6761,"sheds":6762,"unroll":6763,"Discussions74":6764,"directions":6765,"weak":6766,"Cojocaru":6767,"CSUR":6768,"subwindows":6769,"comparable":6770,"10012":6771,"MobileNetV3":6772,"VC":6773,"MS":6774,"9539":6775,"act":6776,"NeMo":6777,"plan":6778,"invari":6779,"15884":6780,"HHHTHTTHHHHHT":6781,"wife":6782,"witnessing":6783,"Copies":6784,"destroy":6785,"grating":6786,"promotions":6787,"offered":6788,"might":6789,"Augmenting":6790,"RL":6791,"relatedness":6792,"beginner":6793,"Stemming":6794,"geNet":6795,"demystified":6796,"utterance":6797,"Yamaguchi":6798,"gamma1":6799,"Saha":6800,"Absent":6801,"communicating":6802,"filter":6803,"215":6804,"path":6805,"Zhang":6806,"fontsize":6807,"multitask":6808,"moderately":6809,"document":6810,"posterior":6811,"aggregate":6812,"Whitehead":6813,"Co":6814,"427400":6815,"dominate":6816,"forgotten":6817,"93%":6818,"Reporting":6819,"acknowledge":6820,"aligns":6821,"Although":6822,"song":6823,"suggested":6824,"self":6825,"identically":6826,"sensing":6827,"varadgunjal":6828,"5313":6829,"104":6830,"sort":6831,"2.2461":6832,"monolingual":6833,"prefact":6834,"glossing":6835,"indemnification":6836,"rization":6837,"breaks":6838,"3228":6839,"reloaded":6840,"84%":6841,"1879":6842,"Karypis":6843,"2204":6844,"1006":6845,"1108":6846,"2557":6847,"popularity":6848,"Pitts":6849,"deterministic":6850,"减少":6851,"305":6852,"TechRadar":6853,"integrity":6854,"Convenience":6855,"Rate":6856,"Math":6857,"Online":6858,"patients":6859,"7739":6860,"13243":6861,"SProp":6862,"Emeritus":6863,"Rosemary":6864,"accept":6865,"indeed":6866,"Kiros":6867,"3GPP":6868,"redundant":6869,"embeddings":6870,"3555":6871,"5908":6872,"differing":6873,"assumptions":6874,"summarize":6875,"absurdity":6876,"reranking":6877,"HTML":6878,"codebert":6879,"concerted":6880,"934":6881,"shareholdermeeting":6882,"collects":6883,"1001":6884,"latory":6885,"conditionals":6886,"misaligned":6887,"Discussions141":6888,"Krueger":6889,"pathway":6890,"Rahul":6891,"COXE":6892,"1903":6893,"405":6894,"512MB":6895,"biologically":6896,"Maximum":6897,"243":6898,"balanced":6899,"novels":6900,"marketable":6901,"neighbors":6902,"damages":6903,"836":6904,"Steiner":6905,"lambda":6906,"Hoyer":6907,"capped":6908,"Loshchilov":6909,"diagnosing":6910,"842":6911,"trim":6912,"lowercase":6913,"manufacturer":6914,"Max":6915,"FLOPs":6916,"0800":6917,"retirement":6918,"participants":6919,"un":6920,"Amendment":6921,"VisualGPT":6922,"titles":6923,"Rostamizadeh":6924,"grammatically":6925,"Creating":6926,"Brian":6927,"Exclude":6928,"employer":6929,"Discussions135":6930,"separately":6931,"advancing":6932,"platform":6933,"742":6934,"definition":6935,"Duvenaud":6936,"meshgrid":6937,"Beginning":6938,"1040.8":6939,"DataParallel":6940,"538":6941,"XML":6942,"MediaTek":6943,"862":6944,"6071":6945,"domestication":6946,"anchez":6947,"1800":6948,"factories":6949,"affiliates":6950,"Interpretation":6951,"strategies":6952,"archiving":6953,"697":6954,"proteins":6955,"TCP":6956,"enc":6957,"Juntian":6958,"880":6959,"XRICL":6960,"Until":6961,"OUR":6962,"convexity":6963,"Overall":6964,"Thinking":6965,"successful":6966,"entropy":6967,"2Var":6968,"Undoubtedly":6969,"ICASSP":6970,"____________________________________________________________________________________________":6971,"dummy":6972,"wearing":6973,"il":6974,"Classical":6975,"NotedownContentsManager":6976,"OpenCV":6977,"longtime":6978,"xv":6979,"Generally":6980,"independently":6981,"2020s":6982,"074":6983,"05407":6984,"Expectations":6985,"Lefan":6986,"3118":6987,"Homme":6988,"Poor":6989,"encouraging":6990,"\n":6991,"969":6992,"om":6993,"appended":6994,"Returning":6995,"Commonsense":6996,"sorts":6997,"Presentation":6998,"reimplemented":6999,"them":7000,"categories":7001,"ix":7002,"ranked":7003,"647":7004,"investigates":7005,"Decoding":7006,"356":7007,"tenth":7008,"freedom":7009,"223500":7010,"licenses":7011,"voted":7012,"Gate":7013,"Ç":7014,"edges":7015,"1511":7016,"justified":7017,"0.459":7018,"009999999":7019,"exploited":7020,"2.6":7021,"Volatility":7022,"cumulative":7023,"902":7024,"Owens":7025,"insidious":7026,"synapses":7027,"installers":7028,"1.3537":7029,"logi":7030,"scholarship":7031,"Bosma":7032,"Tencent":7033,"266":7034,"Record":7035,"290000":7036,"Catanzaro":7037,"fairly":7038,"Discussions217":7039,"9fcde07509c7e87ec61c640c1b2753d9041758e4":7040,"Size":7041,"increments":7042,"041688":7043,"synthetic":7044,"naturalness":7045,"career":7046,"901":7047,"characterizations":7048,"nondecreasing":7049,"7558":7050,"blurred":7051,"4036":7052,"Kocetkov":7053,"abbreviations":7054,"5904067586747807":7055,"computa":7056,"vgg19":7057,"1936":7058,"fancier":7059,"mulates":7060,"01110":7061,"Diffused":7062,"facets":7063,"395153":7064,"conv2":7065,"19%":7066,"ADADELTA":7067,"Verlag":7068,"modified":7069,"journey":7070,"soliciting":7071,"225":7072,"statistics":7073,"281":7074,"Zemlyanskiy":7075,"Facebook":7076,"starve":7077,"13th":7078,"\"":7079,"Millennium":7080,"Flexible":7081,"Dartmouth":7082,"retrieves":7083,"incorporated":7084,"标准文件":7085,"agendas":7086,"Elastic":7087,"lapse":7088,"reintegrate":7089,"Specimen":7090,"526":7091,"formalism":7092,"Tax":7093,"1810":7094,"Forbes":7095,"nisms":7096,"CCA":7097,"situations":7098,"FALCON":7099,"temp":7100,"Gosset":7101,"Price":7102,"Causal":7103,"Verify":7104,"4697":7105,"12.9":7106,"buses":7107,"900263":7108,"equivariance":7109,"infin":7110,"Ram":7111,"changes":7112,"Hoekstra":7113,"Simulators":7114,"horizontally":7115,"Nominee":7116,"conversion":7117,"equipped":7118,"008":7119,"500K":7120,"108":7121,"06800":7122,"Victor":7123,"ARM":7124,"Gmail":7125,"story":7126,"underestimate":7127,"Namely":7128,"Iowa":7129,"fulfilled":7130,"4.7":7131,"Rescale":7132,"Shareholder":7133,"nvda":7134,"542":7135,"Guidelines":7136,"Intelli":7137,"1568":7138,"Signals":7139,"PDF":7140,"Comma":7141,"2050":7142,"Jun":7143,"countable":7144,"tier":7145,"0956":7146,"Originally":7147,"GitHub":7148,"calculate":7149,"ingesting":7150,"started":7151,"decom":7152,"backpropagating":7153,"PCI":7154,"Thankfully":7155,"constituencies":7156,"5289":7157,"quotients":7158,"750M":7159,"Tagging":7160,"remeasurement":7161,"amenable":7162,"→":7163,"help":7164,"parallelized":7165,"Inputs":7166,"fname":7167,"Iterators":7168,"durable":7169,"qh":7170,"Jeong":7171,"Guti":7172,"visit":7173,"4.3":7174,"Varatharajan":7175,"介绍":7176,"argminx":7177,"Including":7178,"suppressed":7179,"plt":7180,"4105":7181,"detach":7182,"comput":7183,"utilization":7184,"limits":7185,"adverse":7186,"negative":7187,"Diab":7188,"vecs":7189,"Nishiyama":7190,"slide":7191,"networks":7192,"Lester":7193,"limited":7194,"poison":7195,"SARGAM":7196,"wiped":7197,"inventing":7198,"1.7359":7199,"Cybenko":7200,"compositional":7201,"suspicious":7202,"view":7203,"realizing":7204,"least":7205,"g4":7206,"Running":7207,"inspired":7208,"Spanish":7209,"407":7210,"importantly":7211,"hr":7212,"popularly":7213,"Based":7214,"Wigner":7215,"Detail":7216,"nominations":7217,"05578":7218,"cluding":7219,"634":7220,"flying":7221,"big":7222,"gist205":7223,"Tsai":7224,"BSE":7225,"precedence":7226,"Lei":7227,"06983":7228,"Function":7229,"founded":7230,"liked":7231,"Celsius":7232,"Seoul":7233,"finishing":7234,"377":7235,"absolute":7236,"2795":7237,"Workers":7238,"quential":7239,"Driving":7240,"AceCoder":7241,"Case":7242,"Stadium":7243,"specifically":7244,"76%":7245,"suburbs":7246,"unemployment":7247,"framework":7248,"Realistic":7249,"exchange":7250,"tricky":7251,"mere":7252,"underestimates":7253,"iciency":7254,"filing":7255,"019823":7256,"exercisable":7257,"resiliency":7258,"794":7259,"worried":7260,"seem":7261,"imagined":7262,"simpler":7263,"supervised":7264,"maker":7265,"Dalmedigos":7266,"Discussions101":7267,"leads":7268,"plementing":7269,"Hadamard":7270,"Passage":7271,"modulates":7272,"Allowance":7273,"embedded":7274,"EDITAS":7275,"speech":7276,"Berkowitz":7277,"344":7278,"horizontal":7279,"Elliott":7280,"cls":7281,"precise":7282,"horribly":7283,"Regardless":7284,"shorten":7285,"925":7286,"proportional":7287,"Resurrecting":7288,"splitting":7289,"webcast":7290,"fewer":7291,"exceeded":7292,"behind":7293,"reliability":7294,"record":7295,"anniversary":7296,"twitter":7297,"Wong":7298,"casting":7299,"607":7300,"Extractive":7301,"pp":7302,"URL":7303,"achievable":7304,"1x":7305,"semantics":7306,"bd":7307,"account":7308,"sub":7309,"repaid":7310,"assists":7311,"Statements":7312,"spanned":7313,"unmistakably":7314,"A.40":7315,"Four":7316,"confidentially":7317,"Jurafsky":7318,"Assigning":7319,"lane":7320,"confusing":7321,"Syntax":7322,"throttling":7323,"1267":7324,"ruling":7325,"TokenEmbedding":7326,"handwriting":7327,"Ishan":7328,"0s":7329,"xi":7330,"Dassault":7331,"sep":7332,"genetic":7333,"edition":7334,"followed":7335,"Thor":7336,"exports":7337,"181500":7338,"Copilots":7339,"Flygare":7340,"keyring":7341,"Polysemy":7342,"/":7343,"0580":7344,"lows":7345,"xxiii":7346,"Electronics":7347,"−":7348,"emerged":7349,"CHARGE":7350,"ent":7351,"ensures":7352,"skin":7353,"manipulat":7354,"1155":7355,"Throughout":7356,"Volatile":7357,"interacting":7358,"exocentric":7359,"advantages":7360,"discarding":7361,"Mahdi":7362,"Deploy":7363,"David":7364,"gou":7365,"0.000022":7366,"Copying":7367,"expedient":7368,"Grape":7369,"height":7370,"864":7371,"ssh":7372,"fmap":7373,"14.4":7374,"concludes":7375,"thus":7376,"purchase":7377,"annotate":7378,"thought":7379,"python":7380,"Lipchitz":7381,"conformity":7382,"does":7383,"hash":7384,"oscillates":7385,"LKJCholesky":7386,"Fellow":7387,"supermajority":7388,"French":7389,"hidden":7390,"earned":7391,"zeroing":7392,"ExecuteTime":7393,"Connecting":7394,"empiricism":7395,"sfermigier":7396,"Russakovsky":7397,"Parallelism":7398,"recommend":7399,"maximized":7400,"Lipton":7401,"prepare":7402,"LN":7403,"":7404,"maintains":7405,"𝒔":7406,"Lin":7407,"100s":7408,"finality":7409,"528":7410,"dioxide":7411,"representative":7412,"royalty":7413,"differentiated":7414,"repayment":7415,"Optimized":7416,"explained":7417,"intersection":7418,"palette":7419,"至关重要":7420,"straightfor":7421,"ny":7422,"旨在":7423,"Having":7424,"implementation":7425,"tively":7426,"rerank":7427,"725":7428,"def":7429,"Coxe":7430,"synthesize":7431,"planet":7432,"suggests":7433,"adopt":7434,"Editsum":7435,"date":7436,"substances":7437,"intercept":7438,"fabric":7439,"r2":7440,"slows":7441,"misrepresentative":7442,"liens":7443,"numel":7444,"propagated":7445,"induces":7446,"Combined":7447,"decide":7448,"simultaneous":7449,"Anchor":7450,"Gershgorin":7451,"ave":7452,"enabling":7453,"Functional":7454,"Hartshorn":7455,"07":7456,"Detected":7457,"Ohio":7458,"Venture":7459,"Lewis":7460,"planning":7461,"repurchases":7462,"girlfriend":7463,"Register":7464,"accrue":7465,"naming":7466,"administrative":7467,"Cui":7468,"242025":7469,"trouble":7470,"Run":7471,"men":7472,"Specifically":7473,"meeting":7474,"screen":7475,"erates":7476,"backwards":7477,"superscripts":7478,"Suddenly":7479,"sell":7480,"fairness":7481,"Thomee":7482,"strengths":7483,"TPUs":7484,"Product":7485,"bylaw":7486,"templates":7487,"InstructGPT":7488,"novel":7489,"termed":7490,"During":7491,"ranking":7492,"horsepower":7493,"surpasses":7494,"𝑃":7495,"Shavit":7496,"Traffic":7497,"Light":7498,"Jaedong":7499,"supplemental":7500,"GD":7501,"seaborn47":7502,"30%":7503,"associa":7504,"scholar":7505,"solvers":7506,"sudden":7507,"Micron":7508,"Director":7509,"introductions":7510,"Sermanet":7511,"ZipFile":7512,"Madry":7513,"761":7514,"distractions":7515,"ambitious":7516,"emb":7517,"2.8991":7518,"magnitude":7519,"Kim":7520,"dates":7521,"measuring":7522,"435":7523,"4608":7524,"noon":7525,"tional":7526,"location":7527,"TensorFlow34":7528,"And":7529,"alternative":7530,"main":7531,"Girshick":7532,"blank":7533,"give":7534,"das":7535,"4003":7536,"tors":7537,"effectively":7538,"Nijkamp":7539,"8203370335228594":7540,"Essentially":7541,"MCCAFFERY":7542,"HIV":7543,"pesky":7544,"0.6":7545,"Paragraphs":7546,"viewable":7547,"TST":7548,"larized":7549,"025":7550,"MSSubClass":7551,"Experiments":7552,"ylist":7553,"Wx":7554,"补充":7555,"676":7556,"indiscriminately":7557,"surfing":7558,"Ethernet":7559,"responding":7560,"Make":7561,"255":7562,"debated":7563,"Technologies":7564,"3GB":7565,"schemas":7566,"rois":7567,"detectable":7568,"List":7569,"subword":7570,"5366":7571,"subdivision":7572,"schedul":7573,"5097":7574,"TSMC":7575,"desire":7576,"ByteTrack":7577,"Bousquet":7578,"≠":7579,"utf":7580,"quel":7581,"accounted":7582,"indexed":7583,"keypoints":7584,"composite":7585,"Alemi":7586,"evant":7587,"singletons":7588,"Omni":7589,"weeds":7590,"establish":7591,"enhanced":7592,"arrive":7593,"BERTEn":7594,"stretching":7595,"2673":7596,"RNNLMScratch":7597,"plane":7598,"high":7599,"10828":7600,"775":7601,"193":7602,"proving":7603,"MeSH":7604,"failures":7605,"Refinement":7606,"Graphical":7607,"right":7608,"Gu":7609,"award":7610,"JONES":7611,"Dealing":7612,"noelo":7613,"classifications":7614,"7.5":7615,"Auli":7616,"SSD":7617,"commercial":7618,"computer":7619,"syn":7620,"ExactMarginalLogLikelihood":7621,"hoped":7622,"cumsum":7623,"2048":7624,"Shreshtha13":7625,"SegmentationClass":7626,"Lan":7627,"covariates":7628,"TinyMemBench":7629,"19.1":7630,"tractable":7631,"401":7632,"preserves":7633,"BUSINESS":7634,"1877":7635,"CuDNN":7636,"Poland":7637,"anticipated":7638,"Matthews":7639,"6190":7640,"20139":7641,"delays":7642,"fig":7643,"perimeter":7644,"LayerNorm":7645,"born":7646,"week":7647,"960":7648,"consumers":7649,"16":7650,"sumed":7651,"probabilities":7652,"122":7653,"Little":7654,"closes":7655,"Backend":7656,"kicked":7657,"tant":7658,"0.225":7659,"invoked":7660,"Stone":7661,"779":7662,"Karras":7663,"temporary":7664,"Addressing":7665,"crude":7666,"1097":7667,"Sphinx":7668,"Rights":7669,"interspersed":7670,"poorly":7671,"ques":7672,"whereby":7673,"towards":7674,"vehicle":7675,"unto":7676,"830":7677,"survived":7678,"detailed":7679,"logistical":7680,"ExactGP":7681,"待办":7682,"dependencies":7683,"done":7684,"Weinberger":7685,"AudioMAE":7686,"Previously":7687,"Tableau":7688,"calling":7689,"Ulm":7690,"simi":7691,"Acceleration":7692,"le":7693,"Denoting":7694,"1440":7695,"thermal":7696,"paramteres":7697,"Chi":7698,"05934":7699,"Kuratov":7700,"insertion":7701,"barometer":7702,"axon":7703,"A.39":7704,"coherence":7705,"1998":7706,"leaving":7707,"563":7708,"useless":7709,"shows":7710,"uniques":7711,"PhD":7712,"FCN":7713,"analytics":7714,"synetune":7715,"discussion":7716,"inverting":7717,"wards":7718,"16063":7719,"thrower":7720,"Governments":7721,"Gonz":7722,"Besta":7723,"Buildings":7724,"secant":7725,"sitional":7726,"Zipfian":7727,"Acoustics":7728,"label2image":7729,"layerwise":7730,"points":7731,"functioning":7732,"2672e":7733,"07697":7734,"hyay":7735,"Comment":7736,"subsampling":7737,"2959":7738,"在":7739,"123":7740,"840":7741,"2":7742,"Bendersky":7743,"expressed":7744,"Bonn":7745,"kens":7746,"shipments":7747,"dispensing":7748,"intensive":7749,"schon":7750,"become":7751,"978":7752,"018466":7753,"xlist":7754,"4073":7755,"snakes":7756,"NotImplemented":7757,"Seasonality":7758,"detaches":7759,"masks":7760,"Capacity":7761,"McCulloch":7762,"cognition":7763,"Github":7764,"外传":7765,"initiatives":7766,"federal":7767,"apples":7768,"Faced":7769,"Discussions178":7770,"faithfulness":7771,"Call":7772,"advertisers":7773,"Oakley":7774,"RAG":7775,"plausibly":7776,"ACL":7777,"Wi":7778,"Telco":7779,"NOTICE":7780,"11B":7781,"gregate":7782,"swer":7783,"展示":7784,"remeasured":7785,"⊕":7786,"motion":7787,"finetunes":7788,"06455":7789,"Pouget":7790,"ish":7791,"decays":7792,"kept":7793,"disadvantaged":7794,"Shuffle":7795,"Young":7796,"details":7797,"nvidia":7798,"stable":7799,"2s":7800,"impactful":7801,"poured":7802,"JOSA":7803,"complicated":7804,"Dzreyev":7805,"surfboard":7806,"cables":7807,"Parameter":7808,"arrowprops":7809,"intuition":7810,"generator":7811,"wire":7812,"Seq2SeqDecoder":7813,"Q1K1":7814,"adjusts":7815,"Discussions280":7816,"179":7817,"delegates":7818,"outcome":7819,"Summing":7820,"1933":7821,"This":7822,"1990":7823,"po":7824,"hotels":7825,"strange":7826,"Discussions145":7827,"957":7828,"pressing":7829,"fleets":7830,"Pipeline":7831,"530B":7832,"1901":7833,"hasoadd":7834,"流程":7835,"deployed":7836,"Vaswani":7837,"Storyboard":7838,"gov":7839,"Kaplun":7840,"1x1conv":7841,"oneself":7842,"Dumoulin":7843,"Sally":7844,"misnomer":7845,"alistic":7846,"fault":7847,"bytes":7848,"End":7849,"aka":7850,"373":7851,"IRS":7852,"Kotthoff":7853,"none":7854,"latents":7855,"depends":7856,"Yida":7857,"04136":7858,"Highly":7859,"KaVD":7860,"Jaeger":7861,"59874":7862,"exhibited":7863,"advance":7864,"32nd":7865,"CFO":7866,"EncoderDecoder":7867,"dig":7868,"Gains":7869,"decides":7870,"1952":7871,"Miniconda":7872,"vzlamal":7873,"inconvenient":7874,"adds":7875,"designated":7876,"899995":7877,"SKURG":7878,"March":7879,"Downsampling":7880,"Jung":7881,"bidirec":7882,"0.8307":7883,"0840":7884,"master":7885,"accuracies":7886,"282":7887,"gymlibrary":7888,"Losses":7889,"engine":7890,"recast":7891,"PLEASE":7892,"complete":7893,"Visit":7894,"AutoML":7895,"Elizabeth":7896,"uses":7897,"2203":7898,"1060":7899,"xxxviii":7900,"369":7901,"REPOFUSE":7902,"Exploration":7903,"cancellable":7904,"estimate":7905,"Teter":7906,"Merri":7907,"Jing":7908,"deposit":7909,"infusing":7910,"546":7911,"logit":7912,"registrant":7913,"trouser":7914,"nature":7915,"Elizalde":7916,"505":7917,"Jones":7918,"Le":7919,"changed":7920,"mechanically":7921,"transmitted":7922,"EPYC":7923,"claim":7924,"eigenvalue":7925,"0.0137":7926,"pareto":7927,"Section":7928,"858":7929,"dec":7930,"liner":7931,"collections":7932,"内存":7933,"Nexus":7934,"antique":7935,"seamless":7936,"guidance":7937,"policing":7938,"Environment":7939,"complicates":7940,"本节":7941,"encapsulates":7942,"textrm":7943,"progressed":7944,"retrospective":7945,"Incorporated":7946,"YaYaB":7947,"extremely":7948,"sary":7949,"DRAMs":7950,"≥":7951,"relieving":7952,"287":7953,"12.11":7954,"Discussions158":7955,"righly":7956,"Success":7957,"Items":7958,"theorists":7959,"nonlinearities":7960,"quorum":7961,"Cambria":7962,"MacKenzie":7963,"Beginner":7964,"vanish":7965,"positively":7966,"Rescuing":7967,"offs":7968,"h2":7969,"Safety":7970,"vari":7971,"aggregates":7972,"Fei":7973,"exact":7974,"predictor":7975,"Shan":7976,"includ":7977,"parent":7978,"nating":7979,"declines":7980,"estimation":7981,"PATH":7982,"WITHOUT":7983,"semi":7984,"expedience":7985,"developement":7986,"bin":7987,"CosineScheduler":7988,"censoring":7989,"surviving":7990,"taxable":7991,"allowance":7992,"true":7993,"entered":7994,"uncontrolled":7995,"12925":7996,"10998":7997,"fits":7998,"⊆":7999,"retentive":8000,"11.7":8001,"auditors":8002,"authorizations":8003,"519127":8004,"10.6":8005,"Command":8006,"Caseres":8007,"exploration":8008,"·":8009,"a0":8010,"11990":8011,"erations":8012,"Gptcache":8013,"gear":8014,"voc2012":8015,"industries":8016,"𝐹":8017,"directory":8018,"skis":8019,"dimensonality":8020,"alchemy":8021,"multimedia":8022,"shareholder":8023,"Hilbert":8024,"469":8025,"Lapse":8026,"roughly":8027,"Shao":8028,"predecessors":8029,"03188":8030,"c065c0e2593b8b161a2d7873e42418bf6a21106c":8031,"Bidirectional":8032,"可行":8033,"contractor":8034,"Kernel":8035,"lin3":8036,"69e":8037,"recon":8038,"identified":8039,"hazard":8040,"Vocab":8041,"memoizer":8042,"linguistic":8043,"spot":8044,"further":8045,"Heavy":8046,"microphone":8047,"Portions":8048,"256":8049,"exhibit":8050,"assess":8051,"𝑂":8052,"liability":8053,"1019":8054,"1233786579597858":8055,"ognize":8056,"Desjardins":8057,"continues":8058,"grows":8059,"MB":8060,"Ginibre":8061,"Members":8062,"consent":8063,"general":8064,"GaussianLikelihood":8065,"d2lbook":8066,"DQN":8067,"2x":8068,"强烈":8069,"sustainability":8070,"resembling":8071,"experimenter":8072,"Exponential":8073,"0398":8074,"waldoness":8075,"5226":8076,"921":8077,"variety":8078,"Martens":8079,"。":8080,"astonishing":8081,"Discussions133":8082,"attained":8083,"perceive":8084,"course":8085,"encoding":8086,"795":8087,"rl":8088,"Arabia":8089,"Afterwards":8090,"7132":8091,"Algorithms":8092,"Farm":8093,"Lo":8094,"quences":8095,"alarms":8096,"900002":8097,"Y1":8098,"Northern":8099,"responsibility":8100,"816103":8101,"3915e":8102,"haviour":8103,"阅读":8104,"3d":8105,"Netherlands":8106,"Discussions246":8107,"rarely":8108,"read":8109,"0.884":8110,"tropical":8111,"permits":8112,"intersections":8113,"asymptotic":8114,"subtrees":8115,"stitching":8116,"899801":8117,"unseen":8118,"workstations":8119,"Akademie":8120,"FitzGerald":8121,"Codes":8122,"696":8123,"viii":8124,"Score":8125,"home":8126,"stride":8127,"524":8128,"Voting":8129,"LogSumExp":8130,"turns":8131,"clinically":8132,"thermodynamics":8133,"kcj":8134,"soul":8135,"Observation":8136,"TokenEm":8137,"Chen":8138,"tent":8139,"Against":8140,"Supplementary":8141,"hammer":8142,"purposes":8143,"presses":8144,"Dual":8145,"fishersnedecor":8146,"Adverse":8147,"candor":8148,"flywheel":8149,"competitions21":8150,"cleanly":8151,"2211":8152,"liusy182":8153,"Weyerhaeuser":8154,"hedging":8155,"utilize":8156,"Greater":8157,"assump":8158,"1016":8159,"Faculty":8160,"unreasonably":8161,"1048576":8162,"personalization":8163,"Alsallakh":8164,"Lachaux":8165,"Opti":8166,"pithy":8167,"fuses":8168,"solver":8169,"1719":8170,"Polestar":8171,"Achieving":8172,"manager":8173,"B.1":8174,"actors":8175,"Postprocessing":8176,"Individuals":8177,"781":8178,"diagnosis":8179,"Leake":8180,"thin":8181,"invokes":8182,"infotainment":8183,"unrecognized":8184,"Burges":8185,"mally":8186,"421":8187,"832":8188,"logs":8189,"Aleatory":8190,"o1":8191,"0.0974":8192,"specify":8193,"Treatment":8194,"8.3":8195,"shapes":8196,"scent":8197,"Drell":8198,"founding":8199,"pe":8200,"p3":8201,"appointments":8202,"Unlike":8203,"imports":8204,"947":8205,"PDT":8206,"928907":8207,"Discussions234":8208,"multilingual":8209,"scores":8210,"tably":8211,"095":8212,"ends":8213,"Okroshiashvili":8214,"0.693":8215,"Bylaw":8216,"899988":8217,"dissipate":8218,"pay":8219,"previ":8220,"create":8221,"People":8222,"settlement":8223,"love":8224,"Caution":8225,"Principle":8226,"f37072fd":8227,"finally":8228,"Lost":8229,"Fortunately":8230,"thereto":8231,"578":8232,"BIOREADER":8233,"10196":8234,"Lease":8235,"pled":8236,"caps":8237,"ASTs":8238,"275":8239,"Desay":8240,"awarded":8241,"derive":8242,"Prakash":8243,"cepts":8244,"ature":8245,"Studio":8246,"0000":8247,"pertaining":8248,"queried":8249,"I":8250,"series":8251,"Via":8252,"北京":8253,"recognizable":8254,"equiva":8255,"Do":8256,"bicycle":8257,"inde":8258,"principal":8259,"KG":8260,"merge":8261,"Press":8262,"Comparing":8263,"timestep":8264,"motives":8265,"modalities":8266,"yuntai":8267,"Kosaraju":8268,"elucidate":8269,"Engineers":8270,"eration":8271,"YOLO":8272,"Action":8273,"alert":8274,"directly":8275,"2013":8276,"50":8277,"doorstep":8278,"Blocks":8279,"grouped":8280,"stackspot":8281,"Preface":8282,"skills":8283,"fan":8284,"implicitly":8285,"tack":8286,"choices":8287,"mess":8288,"sic":8289,"Whc":8290,"Izacard":8291,"886":8292,"walked":8293,"Saudi":8294,"677":8295,"99th":8296,"BART":8297,"Scao":8298,"TalNeoran":8299,"FASB":8300,"Gormley":8301,"fewest":8302,"signs":8303,"Momentum":8304,"ā":8305,"impression":8306,"formal":8307,"ask":8308,"friend":8309,"ference":8310,"DotProductAttention":8311,"Tim":8312,"Project":8313,"客户端":8314,"sarial":8315,"obtain":8316,"shines":8317,"coordination":8318,"fulfilling":8319,"excit":8320,"exceed":8321,"Attorney":8322,"ought":8323,"formerly":8324,"identity":8325,"module":8326,"rules":8327,"Recruitment":8328,"premature":8329,"schedules":8330,"Compensation":8331,"illegal":8332,"ator":8333,"bolstered":8334,"autoencoders":8335,"列表":8336,"Vector":8337,"utils":8338,"819":8339,"Array":8340,"convinced":8341,"A.44":8342,"Engineering":8343,"affording":8344,"98":8345,"⇐":8346,"effect":8347,"constant":8348,"登录":8349,"Lead":8350,"3516":8351,"reclaim":8352,"f":8353,"delightful":8354,"recreated":8355,"Bernoulli":8356,"bilinear":8357,"earnings":8358,"affine":8359,"Solutions":8360,"possibility":8361,"1086":8362,"Consumer":8363,"brianhendee":8364,"pedestrians":8365,"470":8366,"3440":8367,"gopher":8368,"142":8369,"AnyNetA":8370,"equaled":8371,"genie":8372,"some":8373,"Within":8374,"METRICS":8375,"nonlinearity":8376,"Rrgcode":8377,"Interpolation":8378,"score":8379,"A.11":8380,"regard":8381,"authority":8382,"Murphy":8383,"theorems":8384,"40GB":8385,"nin":8386,"Covs":8387,"duplicate":8388,"djliden":8389,"BSharmi":8390,"Augmentation":8391,"star":8392,"adopting":8393,"nearby":8394,"1784":8395,"sigmd":8396,"repeating":8397,"seemed":8398,"Na":8399,"identi":8400,"55%":8401,"112":8402,"1Whh":8403,"noir":8404,"shortly":8405,"interconnects":8406,"months":8407,"5891":8408,"fashionable":8409,"whet":8410,"fetching":8411,"0899":8412,"with":8413,"Softmax":8414,"Shin":8415,"sparse":8416,"VGGish":8417,"第":8418,"concluded":8419,"mas":8420,"10m":8421,"blood":8422,"0.0987":8423,"distinct":8424,"repetitive":8425,"Beat":8426,"Diao":8427,"blog":8428,"MLM":8429,"Include":8430,"CoLA":8431,"178100":8432,"572":8433,"303261":8434,"Addison":8435,"dislodge":8436,"379":8437,"clarifying":8438,"typesetter":8439,"Latinx":8440,"leave":8441,"Divide":8442,"visited":8443,"iar":8444,"answers":8445,"lection":8446,"𝑋":8447,"easier":8448,"book":8449,"multiplied":8450,"Germany":8451,"Adjust":8452,"shuffled":8453,"电子产品":8454,"rainfall":8455,"cur":8456,"observant":8457,"Maintenance":8458,"Chaitanya":8459,"xxx":8460,"NativeLayerNormBackward0":8461,"346":8462,"Hongler":8463,"rebates":8464,"ining":8465,"remarkably":8466,"escape":8467,"Ke":8468,"RATT":8469,"\u000b":8470,"weird":8471,"twin":8472,"sooner":8473,"switching":8474,"Lora":8475,"periment":8476,"prerecorded":8477,"clicking":8478,"pinning":8479,"Proceed":8480,"8500":8481,"Flickr":8482,"Machines":8483,"entitled":8484,"”":8485,"17532":8486,"lh":8487,"provoke":8488,"full":8489,"charges":8490,"2.3":8491,"Last":8492,"environment":8493,"regardless":8494,"41%":8495,"Should":8496,"explore":8497,"4448":8498,"argmin":8499,"Arp":8500,"indexer":8501,"marketed":8502,"backends":8503,"dispersed":8504,"gure":8505,"books":8506,"sentiments":8507,"Textual":8508,"assessment":8509,"spec":8510,"courtesy":8511,"Dependence":8512,"Definitions":8513,"Salary":8514,"connected":8515,"uation":8516,"Along":8517,"KaggleHouse":8518,"sciences":8519,"rented":8520,"periodically":8521,"outfit":8522,"stabilizing":8523,"Noise":8524,"manipu":8525,"innocuous":8526,"2608.4":8527,"entailment":8528,"desideratum":8529,"2201":8530,"Litigation":8531,"behave":8532,"ℓ":8533,"Nat":8534,"solved":8535,"relying":8536,"06434":8537,"20256":8538,"scrutiny":8539,"57th":8540,"offerings":8541,"Ambarella":8542,"columns":8543,"sgd":8544,"ghejc":8545,"posable":8546,"A.28":8547,"eligibility":8548,"tokenizer":8549,"58":8550,"ceived":8551,"优化":8552,"viewing":8553,"dispositions":8554,"Metric":8555,"Symmetry":8556,"nine":8557,"64%":8558,"furnish":8559,"counterpart":8560,"scheduling":8561,"stationarity":8562,"unrealistically":8563,"punctuation":8564,"1422":8565,"Invoking":8566,"block1":8567,"api":8568,"indicates":8569,"transport":8570,"Courez":8571,"Delving":8572,"9C":8573,"domly":8574,"00846":8575,"astonzhang":8576,"masking":8577,"finance":8578,"convention":8579,"overhead":8580,"giant":8581,"Regan":8582,"Issued":8583,"dont":8584,"budgeted":8585,"Individual":8586,"optimize":8587,"6.4":8588,"Schoenholz":8589,"txt":8590,"SciPy":8591,"diagnos":8592,"categorize":8593,"Reports":8594,"Oversight":8595,"trained":8596,"legge":8597,"eliminating":8598,"already":8599,"台":8600,"drew":8601,"truth":8602,"leased":8603,"substrates":8604,"Matter":8605,"2006":8606,"qui":8607,"Optimize":8608,"Activation":8609,"Lopyrev":8610,"Nichol":8611,"𝝁":8612,"Clauses":8613,"hl":8614,".+":8615,"337":8616,"Vijayvargeeya":8617,"DigitalVision":8618,"2329":8619,"blogs":8620,"synthesises":8621,"hallucinator":8622,"438":8623,"controversy":8624,"sched":8625,"prompting":8626,"zhang":8627,"charters":8628,"4d7d5b85e4537ad0c5d0a202623dcec5":8629,"frustrating":8630,"0.0094":8631,"appear":8632,"9.4":8633,"Veroyatnostei":8634,"GR00T":8635,"reasons":8636,"ERP":8637,"filings":8638,"Segmentation":8639,"irreducible":8640,"也":8641,"Distill":8642,"Hazan":8643,"414":8644,"7":8645,"Discussions226":8646,"precursors":8647,"cast":8648,"stanford":8649,"bidirectional":8650,"ontology":8651,"blessing":8652,"Codification":8653,"Inspections":8654,"navigable":8655,"None":8656,"gate":8657,"Kernion":8658,"Nashid":8659,"1Whf":8660,"bilin":8661,"responsibly":8662,"algorithm":8663,"784":8664,"Corpus":8665,"config":8666,"转发":8667,"15000":8668,"Ninth":8669,"Components":8670,"couldn":8671,"equitable":8672,"seeming":8673,"bare":8674,"choose":8675,"rising":8676,"provide":8677,"Seven":8678,"expert":8679,"astronomy":8680,"Testing":8681,"Nearly":8682,"235":8683,"shortages":8684,"ubitiquous":8685,"Ili":8686,"orderings":8687,"drink":8688,"unavoidably":8689,"instagram":8690,"490":8691,"Michael":8692,"Demographics":8693,"absent":8694,"demonstration":8695,"tation":8696,"fn":8697,"4.6":8698,"Average":8699,"tinuously":8700,"stopped":8701,"motivations":8702,"chinery":8703,"fluctuate":8704,"Barvaz":8705,"Multiply":8706,"Cord":8707,"07s":8708,"177":8709,"Repair":8710,"anticlimactic":8711,"periodic":8712,"Independent":8713,"engs":8714,"anticipation":8715,"pig":8716,"intense":8717,"impose":8718,"Kumar":8719,"PepsiCo":8720,"retain":8721,"covari":8722,"nicest":8723,"specifics":8724,"1045":8725,"infer":8726,"2.01":8727,"modular":8728,"144":8729,"电子":8730,"inverses":8731,"\u0003":8732,"6855":8733,"pyplot":8734,"A.36":8735,"ships":8736,"Mangal":8737,"Psychophysik":8738,"Malartic":8739,"RandomResizedCrop":8740,"stars":8741,"positions":8742,"temporal":8743,"tention":8744,"wish":8745,"discoveries":8746,"Worker":8747,"Touvron":8748,"automate":8749,"repurpose":8750,"xii":8751,"AnyNetD":8752,"cat":8753,"shepherd":8754,"captioned":8755,"underrep":8756,"Russell":8757,"Mirza":8758,"VI":8759,"receives":8760,"update":8761,"Results":8762,"reform":8763,"rephrasing":8764,"Norms":8765,"proposes":8766,"left":8767,"b5116e234e9eb9076672cfeabf5469f3eec904fa":8768,"Headquartered":8769,"They":8770,"long":8771,"person":8772,"说明":8773,"timely":8774,"900579":8775,"50%":8776,"954":8777,"Grefenstette":8778,"resulting":8779,"x1":8780,"Yoshua":8781,"exaggeration":8782,"2088":8783,"671":8784,"BLEU":8785,"contours":8786,"1110":8787,"expresses":8788,"Indemnity":8789,"appling":8790,"mismatch":8791,"OF":8792,"imdb":8793,"9142e":8794,"complexities":8795,"An":8796,"scrape":8797,"202352":8798,"Bao":8799,"inspirations":8800,"Guide":8801,"conspiring":8802,"pen":8803,"Brown":8804,"111982":8805,"concentrate":8806,"Taiwan":8807,"possession":8808,"102":8809,"assemble":8810,"Unrealized":8811,"wasting":8812,"demystify":8813,"alluded":8814,"meters":8815,"machines":8816,"MGX":8817,"wherever":8818,"A.31":8819,"592":8820,"Large":8821,"seeing":8822,"4914":8823,"chronous":8824,"exploitable":8825,"186485":8826,"1MB":8827,"Prowess":8828,"talk":8829,"preconditioning":8830,"ENDED":8831,"cold":8832,"heading":8833,"neutral":8834,"funds":8835,"SHAREHOLDERMEETING":8836,"Recall":8837,"Assessment":8838,"Bases":8839,"maliciously":8840,"experimen":8841,"084":8842,"Investor":8843,"optimiza":8844,"Quanta":8845,"skincare":8846,"Casanova":8847,"Up":8848,"exponentiate":8849,"Now":8850,"Gato":8851,"𝑘":8852,"Chair":8853,"roadmap":8854,"c4":8855,"will":8856,"jpg":8857,"fering":8858,"eps":8859,"530.30":8860,"Events":8861,"easiest":8862,"Micchelli":8863,"great":8864,"declared":8865,"Bertolami":8866,"abbreviation":8867,"Accelerated":8868,"trimmed":8869,"1732":8870,"Careful":8871,"Wilson":8872,"reinvest":8873,"buggy":8874,"party":8875,"153":8876,"𝑝":8877,"resume":8878,"viously":8879,"underflow":8880,"military":8881,"langchain":8882,"Gong":8883,"Bellemare":8884,"corporates":8885,"appealing":8886,"arable":8887,"signals":8888,"RHO":8889,"instantiation":8890,"Koren":8891,"467":8892,"Bradbury":8893,"forecasted":8894,"Sheng":8895,"proceedings":8896,"success":8897,"discharged":8898,"jobs":8899,"regularizing":8900,"postprocess":8901,"prac":8902,"ROBOTICS":8903,"hierarchy":8904,"detecting":8905,"azimjonn":8906,"Roles":8907,"unknown":8908,"09055":8909,"pricing":8910,"terrifying":8911,"088457":8912,"contractors":8913,"posi":8914,"conventions":8915,"Japanese":8916,"1532":8917,"5167":8918,"Scalability":8919,"Presetting":8920,"Triggs":8921,"Integrating":8922,"RandomGenerator":8923,"elicits":8924,"Discussions183":8925,"sparsity":8926,"instantiates":8927,"integration":8928,"mated":8929,"cor":8930,"gd":8931,"Unilog":8932,"topecongiro":8933,"even":8934,"nboer":8935,"EKF":8936,"Shi":8937,"ultimate":8938,"geom":8939,"02":8940,"911":8941,"opposed":8942,"Rutherford":8943,"vendor":8944,"possibilities":8945,"upgrades":8946,"2.4754":8947,"ters":8948,"871":8949,"383":8950,"confusingly":8951,"much":8952,"Web":8953,"Pang":8954,"Cucurull":8955,"hackers":8956,"Bello":8957,"8238":8958,"whistles":8959,"lawyer":8960,"Reverse":8961,"2.1":8962,"558":8963,"munity":8964,"familiar":8965,"content":8966,"SDA":8967,"mediate":8968,"url":8969,"Residual":8970,"Hsun":8971,"summarizes":8972,"exploiting":8973,"tunes":8974,"Galac":8975,"Convolutions":8976,"RNG":8977,"ready":8978,"What":8979,"shortcuts":8980,"quantifying":8981,"":8982,"checkpointing":8983,"Education":8984,"saddle":8985,"implementations":8986,"975":8987,"Truth":8988,"0.850":8989,"Row":8990,"vulnerability":8991,"enthusiast":8992,"meaningful":8993,"standardizes":8994,"0.861":8995,"6000":8996,"ingredient":8997,"commonsense":8998,"related":8999,"15":9000,"1907":9001,"integrals":9002,"creativity":9003,"CNTK":9004,"aids":9005,"pecking":9006,"counters":9007,"matrix":9008,"Basis":9009,"2672":9010,"convolution":9011,"9185e":9012,"Gurgul":9013,"reference":9014,"writes":9015,"pushing":9016,"impatient":9017,"revolutions":9018,"6.7":9019,"SportsTHU":9020,"array":9021,"subtlety":9022,"abs":9023,"90%":9024,"driver":9025,"PTB":9026,"affecting":9027,"communica":9028,"terawatt":9029,"Lovelace":9030,"PAM":9031,"restric":9032,"blazingly":9033,"still":9034,"chiplets":9035,"clas":9036,"1713":9037,"financing":9038,"23000":9039,"frequently":9040,"-----":9041,"honesty":9042,"410":9043,"divided":9044,"smoothing":9045,"995":9046,"descriptor":9047,"rotated":9048,"justifying":9049,"specified":9050,"yticks":9051,"Fixed":9052,"Exhibit":9053,"closest":9054,"resolution":9055,"232":9056,"house":9057,"downtown":9058,"4659":9059,"Multilingual":9060,"personalized":9061,"revolutionize":9062,"Treating":9063,"cn":9064,"946":9065,"UDAPDR":9066,"inductive":9067,"COLORMAP":9068,"precious":9069,"acteristics":9070,"Gaussians":9071,"circuit":9072,"ensured":9073,"wages":9074,"theme":9075,"thorny":9076,"tiating":9077,"string":9078,"center":9079,"incentives":9080,"accumulating":9081,"2403":9082,"Intuitively":9083,"tempted":9084,"05326":9085,"conservation":9086,"insolvency":9087,"indicated":9088,"doubtful":9089,"Yoder":9090,"impute":9091,"Sivic":9092,"Berkov":9093,"LazyConv2d":9094,"Machine137":9095,"putationally":9096,"Ch":9097,"Trial":9098,"ProgressBoard":9099,"inclined":9100,"robustness":9101,"7.1":9102,"backyard":9103,"there":9104,"hypergradi":9105,"avoiding":9106,"dialog":9107,"Concise":9108,"transformative":9109,"Agirre":9110,"1408":9111,"remedy":9112,"virtually":9113,"至关":9114,"placing":9115,"humans":9116,"pros":9117,"dim":9118,"throughs":9119,"chairman":9120,"booster":9121,"searcher":9122,"subscript":9123,"Rencos":9124,"pointer":9125,"2121":9126,"967":9127,"arnav":9128,"onestep":9129,"R3":9130,"Flight":9131,"fluid":9132,"Story":9133,"classified":9134,"prevailed":9135,"wavelengths":9136,"instrument":9137,"operations":9138,"proofs":9139,"encouragement":9140,"treme":9141,"Souza":9142,"premises":9143,"Muhyun":9144,"Franceschi":9145,"Undiscovered":9146,"attorneys":9147,"interacts":9148,"partially":9149,"Zolna":9150,"trick":9151,"NVIDIANs":9152,"Drug":9153,"protection":9154,"1855":9155,"effecting":9156,"4612":9157,"47th":9158,"completes":9159,"rightward":9160,"01307":9161,"influ":9162,"\u0002":9163,"accelerator":9164,"Nonetheless":9165,"keeping":9166,"Proceedings":9167,"practicable":9168,"egy":9169,"13.7":9170,"Bebchuk":9171,"1.4914":9172,"Mobile":9173,"too":9174,"menting":9175,"specifies":9176,"Marvell":9177,"Simon":9178,"00030":9179,"favorite":9180,"dard":9181,"patrol":9182,"whitened":9183,"alleviate":9184,"pause":9185,"Discussions94":9186,"pratikhack":9187,"simultaneously":9188,"lenient":9189,"Evans":9190,"264475":9191,"lot":9192,"]":9193,"vastly":9194,"Meng":9195,"search":9196,"Bin":9197,"792":9198,"take":9199,"StructGPT":9200,"Pokemon":9201,"Side":9202,"agencies":9203,"cesses":9204,"Government":9205,"lowering":9206,"Naively":9207,"SoCs":9208,"PaddlePaddle":9209,"filtration":9210,"CONCURRENTLY":9211,"permitted":9212,"Goodfellow":9213,"vermicelli":9214,"virtuous":9215,"falls":9216,"aver":9217,"considering":9218,"Fahrenheit":9219,"cult":9220,"parking":9221,"电脑":9222,"Salinas":9223,"0284":9224,"Important":9225,"Wolpert":9226,"compiler":9227,"SCG":9228,"literal":9229,"∞":9230,"coupon":9231,"subsequences":9232,"SHARP":9233,"indicator":9234,"5148":9235,"Orr":9236,"Adoption":9237,"murky":9238,"223":9239,"interfaces":9240,"sliding":9241,"HPOTrainer":9242,"76":9243,"computers":9244,"0.0904":9245,"Markets":9246,"Compliance":9247,"𝑡":9248,"Duties":9249,"测试":9250,"12652":9251,"er":9252,"Compact":9253,"recharge":9254,"numerics":9255,"Altman":9256,"networking":9257,"Considered":9258,"dataset241":9259,"ViTBlock":9260,"enhances":9261,"Jin":9262,"tral":9263,"strengthens":9264,"2D":9265,"412":9266,"Griewank":9267,"cautioned":9268,"slower":9269,"Permit":9270,"sword":9271,"Lived":9272,"proportion":9273,"motus":9274,"具体":9275,"accrued":9276,"ve":9277,"1036":9278,"distin":9279,"corresonding":9280,"SigmoidTransform":9281,"Earned":9282,"magnetic":9283,"Discussions303":9284,"strengthening":9285,"regulation":9286,"Forums":9287,"Grounded":9288,"OREOLM":9289,"languished":9290,"s2":9291,"Constraints":9292,"ProjX":9293,"female":9294,"Founder":9295,"Tatoeba":9296,"comply":9297,"tokyo":9298,"pathic":9299,"Discussions64":9300,"4800":9301,"0.4":9302,"active":9303,"Tolstikhin":9304,"transposes":9305,"1312":9306,"metadata":9307,"audience":9308,"categorized":9309,"cessation":9310,"ysis":9311,"collapses":9312,"rows":9313,"brilliant":9314,"keyphrase":9315,"excessive":9316,"implementa":9317,"commonality":9318,"malware":9319,"acids":9320,"throughput":9321,"Divvala":9322,"dimensionalities":9323,"xxxiii":9324,"066":9325,"usage":9326,"close":9327,"list":9328,"Earlier":9329,"10007":9330,"Norm":9331,"1951":9332,"Graph":9333,"Q":9334,"meets":9335,"Predict":9336,"framing":9337,"Video":9338,"file":9339,"Wallis":9340,"unreasonable":9341,"PUs":9342,"superior":9343,"810":9344,"notations":9345,"De":9346,"flop":9347,"probabilty":9348,"08209":9349,"Shaw":9350,"E1":9351,"ACM":9352,"ad":9353,"messy":9354,"gradients":9355,"Georg":9356,"copyfile":9357,"160MB":9358,"measures":9359,"na":9360,"Hajishirzi":9361,"preparing":9362,"SELF":9363,"ob":9364,"artifacts":9365,"apps":9366,"06476":9367,"Genentech":9368,"death":9369,"reset":9370,"experiments":9371,"detail":9372,"RE":9373,"Age":9374,"ReF":9375,"guistic":9376,"6305":9377,"governance":9378,"ously":9379,"scolio":9380,"236":9381,"guages":9382,"非":9383,"2GHz":9384,"measurement":9385,"random":9386,"USB":9387,"14A":9388,"Chebyshev":9389,"reject":9390,"𝜇":9391,"imately":9392,"582":9393,"1137":9394,"bespoke":9395,"filename":9396,"uppercase":9397,"modders":9398,"You":9399,"Codex":9400,"AlphaGo":9401,"Backward":9402,"Island":9403,"ceded":9404,"Mordatch":9405,"NCGC":9406,"curves":9407,"MySequential":9408,"9486":9409,"547":9410,"Collaborative":9411,"801":9412,"sampleSubmission":9413,"outages":9414,"assisting":9415,"Wahba":9416,"Joulin":9417,"discriminative":9418,"workload":9419,"Chaumond":9420,"Shoe":9421,"930":9422,"push":9423,"suspiciously":9424,"1049":9425,"PERSIS":9426,"CE":9427,"guarantee":9428,"Abalone":9429,"pow":9430,"compliant":9431,"449":9432,"viewpoint":9433,"exe":9434,"Sanjar":9435,"Affine":9436,"Fibre":9437,"GAN":9438,"plicate":9439,"Simply":9440,"307":9441,"docs":9442,"adjust":9443,"abnormal":9444,"folders":9445,"Getting":9446,"robust":9447,"optimization":9448,"theoretically":9449,"253":9450,"profound":9451,"158591":9452,"continuations":9453,"Active":9454,"657":9455,"VGNMN":9456,"Artificial":9457,"Shot":9458,"linestyle":9459,"iteration":9460,"commute":9461,"chair":9462,"Rat":9463,"diligently":9464,"Say":9465,"Organization":9466,"reportable":9467,"presenting":9468,"sneak":9469,"ICLR":9470,"dictionary":9471,"26868380288030347":9472,"tialized":9473,"Continental":9474,"Pat":9475,"350M":9476,"Cognitive":9477,"oil":9478,"Paris":9479,"RDM":9480,"Wahrscheinlichkeitstheorie":9481,"Computations":9482,"cyclic":9483,"Canada":9484,"mortality":9485,"Teal":9486,"una":9487,"Approaching":9488,"prejudices":9489,"0.03":9490,"lay":9491,"revolutionized":9492,"Directions":9493,"feedback":9494,"repeatable":9495,"lowest":9496,"cyclical":9497,"209":9498,"gross":9499,"hotdogs":9500,"Installation":9501,"dispositive":9502,"Convinse":9503,"Annual":9504,"Discussions132":9505,"preset":9506,"student":9507,"verbatim":9508,"GAAP":9509,"infrequently":9510,"habits":9511,"rescaled":9512,"sporadically":9513,"quence":9514,"oriented":9515,"inclusion":9516,"opponent":9517,"owned":9518,"2526":9519,"simulated":9520,"3.85":9521,"RNNScratch":9522,"competition":9523,"从":9524,"Discussions56":9525,"suppresses":9526,"bit":9527,"Σ":9528,"pit":9529,"Ghahramani":9530,"bors":9531,"perturbs":9532,"other":9533,"got":9534,"hire":9535,"789":9536,"College":9537,"gain":9538,"756":9539,"18678":9540,"confirming":9541,"input":9542,"RandomCrop":9543,"Makes":9544,"cholesky":9545,"r1":9546,"666":9547,"pmf":9548,"37716809.52":9549,"downfall":9550,"Gender":9551,"LLAMA":9552,"à":9553,"Density":9554,"Petroni":9555,"greatest":9556,"p4":9557,"示例":9558,"Black":9559,"attributes":9560,"banc":9561,"Santiago":9562,"Fergus":9563,"BC":9564,"Mike":9565,"strangely":9566,"NEAL":9567,"arch":9568,"142847":9569,"LeGresley":9570,"Dynamo":9571,"Unsu":9572,"review":9573,"subqueries":9574,"certain":9575,"119":9576,"cours":9577,"office":9578,"sentences":9579,"marginalized":9580,"replaces":9581,"0.4448":9582,"Barham":9583,"rise":9584,"Tibshirani":9585,"83":9586,"VidIL":9587,"780":9588,"Share":9589,"Registers":9590,"terminology":9591,"payouts":9592,"Finance":9593,"10D":9594,"never":9595,"facing":9596,"delightfully":9597,"disclosing":9598,"softmax":9599,"troducing":9600,"Parinov":9601,"Shazeer":9602,"travelly":9603,"press":9604,"salient":9605,"reports":9606,"bridge":9607,"8GB":9608,"Shareholders":9609,"examples":9610,"itory":9611,"groundwork":9612,"1GHz":9613,"jstor":9614,"15657":9615,"misclassifying":9616,"IN":9617,"dimensionality":9618,"0.869":9619,"SECURITIES":9620,"Mohamed":9621,"Goodwill":9622,"serman":9623,"Shape":9624,"Sarthi":9625,"Google":9626,"Elemente":9627,"exper":9628,"embedding":9629,"isolated":9630,"markets":9631,"algorithmic":9632,"eagle":9633,"want":9634,"rectified":9635,"kind":9636,"sequentially":9637,"kriz":9638,"Adadelta":9639,"yd":9640,"11%":9641,"motivate":9642,"dump":9643,"Boulevard":9644,"approachable":9645,"mergers":9646,"breathing":9647,"flows":9648,"Bodla":9649,"Frazier":9650,"generat":9651,"cussed":9652,"HSUN":9653,"carry":9654,"Discussions69":9655,"Zeitschrift":9656,"cheats":9657,"Tworek":9658,"Implicit":9659,"interest":9660,"modifies":9661,"328":9662,"679":9663,"chain":9664,"Vandenberghe":9665,"pem":9666,"majorizes":9667,"Covx":9668,"527":9669,"correctable":9670,"loan":9671,"False":9672,"Executing":9673,"rescue":9674,"segment":9675,"Squeeze":9676,"Replug":9677,"dashed":9678,"SQuAD":9679,"available":9680,"Assessments":9681,"eugenics":9682,"instability":9683,"basically":9684,"Broadcasting":9685,"conventionally":9686,"1476":9687,"1031":9688,"structural":9689,"4021":9690,"029140":9691,"Metrics":9692,"audit":9693,"guessed":9694,"employing":9695,"Millions":9696,"462":9697,"LowRankMultivariateNormal":9698,"forums":9699,"meaning":9700,"Greys":9701,"ReACC":9702,"subtracted":9703,"Enriching":9704,"engages":9705,"IF":9706,"invert":9707,"minimiz":9708,"barriers":9709,"Without":9710,"symbol":9711,"13178":9712,"retailers":9713,"digest":9714,"1046":9715,"remember":9716,"favourably":9717,"passages":9718,"Restated":9719,"shortcomings":9720,"interpolating":9721,"Kurniawan":9722,"plague":9723,"hibit":9724,"GHz":9725,"making":9726,"10403":9727,"mechanics":9728,"dot":9729,"thick":9730,"occasionally":9731,"Werbos":9732,"Spline":9733,"8828.3095703125":9734,"Don":9735,"CLAP":9736,"district":9737,"gravitational":9738,"Southern":9739,"971":9740,"AGAINST":9741,"已":9742,"yangling0818":9743,"evaluating":9744,"receiving":9745,"Fiocco":9746,"SIMULATION":9747,"deterioration":9748,"assist":9749,"Photorealistic":9750,"eating":9751,"authentication":9752,"487":9753,"rameter":9754,"ditions":9755,"Classifiers":9756,"biology":9757,"newspapers":9758,"dealing":9759,"implements":9760,"validation":9761,"methodologies":9762,"testing":9763,"Compose":9764,"ker":9765,"1.0308":9766,"942":9767,"guess":9768,"aggregation":9769,"exponentially":9770,"Gunn":9771,"Blue":9772,"frame":9773,"packet":9774,"YFC100M":9775,"598":9776,"Peer":9777,"headquarters":9778,"marked":9779,"ok":9780,"animation":9781,"Bioreader":9782,"126%":9783,"ReLUs":9784,"prohibitive":9785,"Gar":9786,"signing":9787,"downloading":9788,"976":9789,"weighted":9790,"Schwartz":9791,"cess":9792,"1.1456":9793,"3367":9794,"Nets":9795,"broadly":9796,"Discussions285":9797,"primarily":9798,"incur":9799,"Iglovikov":9800,"Foundation":9801,"tallest":9802,"SageMakerBackend":9803,"extends":9804,"17":9805,"Omnicom":9806,"unlikely":9807,"consumption":9808,"lecturer":9809,"translations":9810,"Hipporag":9811,"Falcon":9812,"Ima":9813,"2159":9814,"Somekh":9815,"finished":9816,"limiting":9817,"CenteredLayer":9818,"602":9819,"conveys":9820,"tasked":9821,"folded":9822,"chunk":9823,"Finnish":9824,"lies":9825,"case":9826,"addnorm3":9827,"Scope":9828,"industrial":9829,"worryingly":9830,"O3":9831,"recently":9832,"preapproval":9833,"Qdiag":9834,"environmental":9835,"Capitalization":9836,"Discrete":9837,"Bottle":9838,"contradiction":9839,"张三":9840,"Select":9841,"Mk":9842,"Boxes":9843,"semiconductors":9844,"Union":9845,"controllers":9846,"autocomplete":9847,"720":9848,"PayPal":9849,"REQUESTED":9850,"2002":9851,"Bottom":9852,"undermine":9853,"generality":9854,"e":9855,"bboxes":9856,"845":9857,"Gates":9858,"Hs":9859,"licensors":9860,"hyperscale":9861,"3354":9862,"1104":9863,"smi":9864,"Breuleux":9865,"pension":9866,"fixes":9867,"Aji":9868,"stories":9869,"FILCO":9870,"part":9871,"576":9872,"remediated":9873,"more":9874,"stricter":9875,"Das":9876,"385970":9877,"storing":9878,"Discussions83":9879,"798":9880,"outcomes":9881,"omit":9882,"traced":9883,"2737092907":9884,"352":9885,"Computer":9886,"sectional":9887,"safety":9888,"Central":9889,"8377":9890,"06":9891,"amateur":9892,"reused":9893,"Anything":9894,"gener":9895,"Larroy":9896,"709":9897,"ically":9898,"enabled":9899,"Expected":9900,"xviii":9901,"P3608":9902,"callback":9903,"10357":9904,"spaCy":9905,"1999":9906,"copies":9907,"median":9908,"appropri":9909,"controversial":9910,"unfounded":9911,"managing":9912,"BlendedRAG":9913,"2Cov":9914,"wholly":9915,"034437":9916,"Moment":9917,"COMPSTAT":9918,"11.4":9919,"pan":9920,"refined":9921,"rectness":9922,"SoC":9923,"surrounding":9924,"library72":9925,"furniture":9926,"government":9927,"foreseeable":9928,"neg":9929,"Hershey":9930,"namedtuple":9931,"Tsoumakas":9932,"Ax":9933,"Costs":9934,"lently":9935,"Derivative":9936,"Johns":9937,"fake":9938,"t10k":9939,"129569":9940,"could":9941,"philosopher":9942,"disc":9943,"Jr":9944,"Storage":9945,"qingfengtommy":9946,"Reserve":9947,"becomes":9948,"lenges":9949,"dendrites":9950,"petition":9951,"dennismalmgren":9952,"dramatically":9953,"subsequence":9954,"CRUD":9955,"Have":9956,"forcement":9957,"bash":9958,"ially":9959,"Kalinin":9960,"Zhu":9961,"snow":9962,"Patwary":9963,"Shannon":9964,"AACL":9965,"Foreign":9966,"bers":9967,"Nadaraya":9968,"placeholder":9969,"核心":9970,"Library":9971,"Wasserman":9972,"Exercise":9973,"ficiently":9974,"100m2":9975,"sampling":9976,"RAC":9977,"44":9978,"Naive":9979,"ranging":9980,"Principles":9981,"qualified":9982,"EMEA":9983,"producing":9984,"exclude":9985,"revises":9986,"1.2266":9987,"corr1d":9988,"季度":9989,"neigh":9990,"Ansys":9991,"abound":9992,"warps":9993,"VLDB":9994,"Sakamoto":9995,"varieties":9996,"margins":9997,"mechanization":9998,"Reporter":9999,"sprung":10000,"B.9":10001,"subwords":10002,"Histograms":10003,"medicine":10004,"Prediction":10005,"KF":10006,"District":10007,"sultats":10008,"max":10009,"guishing":10010,"always":10011,"decouples":10012,"Breed":10013,"idea":10014,"scripts":10015,"fidelity":10016,"pounds":10017,"900026":10018,"transactions":10019,"whe":10020,"Stu":10021,"ig":10022,"reviews":10023,"1078":10024,"chosen":10025,"calculates":10026,"Development":10027,"Hypothesis":10028,"reads":10029,"tanh":10030,"Citation":10031,"Kilt":10032,"singularity":10033,"422906":10034,"Services":10035,"169738":10036,"designs":10037,"aerospace":10038,"Framework":10039,"riplus1":10040,"：":10041,"trucking":10042,"subramanian":10043,"errez":10044,"tutorials":10045,"736":10046,"1388":10047,"Indicate":10048,"antees":10049,"augs":10050,"authorizes":10051,"asked":10052,"raising":10053,"website":10054,"Pasupat":10055,"6551":10056,"813":10057,"makers":10058,"diminished":10059,"Mooij":10060,"182500":10061,"compromise":10062,"rein":10063,"535":10064,"pdf":10065,"redefined":10066,"disclose":10067,"decomposi":10068,"162":10069,"rescal":10070,"Bellman":10071,"subsidize":10072,"participation":10073,"0.000017":10074,"Biden":10075,"Integrated":10076,"Adding":10077,"contributor":10078,"CONCLUSION":10079,"polygons":10080,"seeking":10081,"Tseng":10082,"2519":10083,"CIKM":10084,"While":10085,"Tchebycheffian":10086,"ration":10087,"spring":10088,"Stop":10089,"Article":10090,"CumulativeDistributionTransform":10091,"maxima":10092,"71":10093,"08252":10094,"rigid":10095,"stockholder":10096,"城市":10097,"Combine":10098,"escalation":10099,"reproduced":10100,"harnessing":10101,"586%":10102,"1987":10103,"ten":10104,"video":10105,"effected":10106,"extents":10107,"leaps":10108,"eases":10109,"vision":10110,"9912":10111,"outpace":10112,"serves":10113,"micrometers":10114,"operating":10115,"Nouvelles":10116,"724":10117,"Wikipedia":10118,"landscape":10119,"scalable":10120,"imposition":10121,"many":10122,"Herbrich":10123,"Reviewing":10124,"654":10125,"UCSD":10126,"analytically":10127,"Syst":10128,"sweep":10129,"scalability":10130,"please":10131,"probable":10132,"switched201":10133,"fails":10134,"3872":10135,"ous":10136,"Oki":10137,"cTBLS":10138,"Jean":10139,"anchors":10140,"980305":10141,"057646":10142,"Levine":10143,"synaptic":10144,"Chief":10145,"lake":10146,"wonderful":10147,"8427":10148,"7540":10149,"ZF":10150,"CDF":10151,"zeus":10152,"Cocke":10153,"interventions":10154,"1556":10155,"认证":10156,"Roadmap":10157,"Watson":10158,"enforceable":10159,"program":10160,"Mietchen":10161,"1.5680":10162,"exhaustive":10163,"variant":10164,"resnet18":10165,"empirically":10166,"unbiased":10167,"scratches":10168,"calibrate":10169,"miles":10170,"Allahyar":10171,"Isaac":10172,"EXHIBIT":10173,"ANNUAL":10174,"terrific":10175,"builtins":10176,"neatly":10177,"enriched":10178,"accrual":10179,"listing":10180,"Libratus":10181,"vocab":10182,"includes":10183,"silently":10184,"Ohta":10185,"Take":10186,"Sensitive":10187,"passes":10188,"𝝅":10189,"ReshapeTransform":10190,"Cavallo":10191,"auditor":10192,"Labor":10193,"ß":10194,"https":10195,"boilerplate":10196,"2493":10197,"underrepresented":10198,"recalled":10199,"benefitting":10200,"liweiwp":10201,"204":10202,"script":10203,"Fourier":10204,"contributions":10205,"0.003":10206,"literals":10207,"awareness":10208,"systematic":10209,"Uni":10210,"repay":10211,"statis":10212,"tionally":10213,"Moreover":10214,"flavors":10215,"k":10216,"squished":10217,"ongoing":10218,"759":10219,"dissertation":10220,"Encoding":10221,"Arcy":10222,"21":10223,"Adilov":10224,"psychology":10225,"Labels":10226,"fittingly":10227,"290":10228,"posit":10229,"Layers":10230,"0805e":10231,"IS":10232,"heralded":10233,"verb":10234,"02972":10235,"reschedule":10236,"Norouzi":10237,"BiRNN":10238,"absolutely":10239,"Yuhong":10240,"NAS":10241,"brains":10242,"scanning":10243,"expand":10244,"violating":10245,"reserves":10246,"sim":10247,"researches":10248,"instruc":10249,"ablation":10250,"cosh":10251,"DECAF":10252,"taught":10253,"behavioral":10254,"Tranah":10255,"Internal":10256,"ries":10257,"gion":10258,"inplace":10259,"modules":10260,"Imagenet":10261,"Tian":10262,"merges":10263,"2771":10264,"accompanying":10265,"ternational":10266,"ill":10267,"append":10268,"NFLX":10269,"215050":10270,"ln":10271,"disentangle":10272,"download":10273,"covered":10274,"ation":10275,"academia":10276,"ensemble":10277,"CAE":10278,"backed":10279,"promises":10280,"317":10281,"496":10282,"canvas":10283,"must":10284,"roost":10285,"absurdly":10286,"0605":10287,"documents":10288,"Allen":10289,"230":10290,"SANER":10291,"noticed":10292,"removal":10293,"Participation":10294,"234":10295,"accomplishes":10296,"lgov":10297,"highlight":10298,"radians":10299,"15.10":10300,"had":10301,"4965":10302,"priorities":10303,"hairier":10304,"ground":10305,"swift":10306,"Informally":10307,"copied":10308,"Instruments":10309,"unsqueeze":10310,"347":10311,"styles":10312,"interpre":10313,"6293":10314,"campus":10315,"alliances":10316,"Publications":10317,"overfits":10318,"effective":10319,"slice":10320,"purchased":10321,"commitment":10322,"Currency":10323,"719":10324,"fundamentals":10325,"HiFi":10326,"TR":10327,"tance":10328,"Opinions":10329,"550":10330,"remind":10331,"Registrant":10332,"explod":10333,"quantified":10334,"statistical":10335,"tanh2":10336,"do":10337,"⊙":10338,"improving":10339,"Expressing":10340,"methodology":10341,"lanes":10342,"Consultant":10343,"erage":10344,"Describe":10345,"10.8":10346,"399":10347,"averaging":10348,"scaled":10349,"Matena":10350,"2961":10351,"Liberty":10352,"2.4":10353,"consumed":10354,"fullest":10355,"epsilion":10356,"fetches":10357,"amount":10358,"precursor":10359,"blockchain":10360,"615":10361,"MultiHop":10362,"imposes":10363,"draws":10364,"è":10365,"regulatory":10366,"focusing":10367,"Von":10368,"Unik":10369,"端":10370,"hyperparams":10371,"oddities":10372,"pred":10373,"geometry":10374,"wildfires":10375,"movement":10376,"hibits":10377,"PricewaterhouseCoopers":10378,"triple":10379,"3190":10380,"val":10381,"1545":10382,"expectations":10383,"Cho":10384,"comfortably":10385,"headline":10386,"removed":10387,"prowess":10388,"invest":10389,"Timeframe":10390,"SUPER":10391,"subclass":10392,"sparsification":10393,"Modules":10394,"17.2":10395,"Fid":10396,"lending":10397,"hwM":10398,"Also":10399,"undiscounted":10400,"developments":10401,"CS":10402,"4354e":10403,"foremost":10404,"1756":10405,"TIP":10406,"describe":10407,"tr":10408,"06302":10409,"Devlin":10410,"chebyshev":10411,"featurizing":10412,"readily":10413,"5%":10414,"buttons":10415,"son":10416,"macOS":10417,"20.1":10418,"TRANSITION":10419,"constraints":10420,"uploading":10421,"client314":10422,"pinecone":10423,"Cai":10424,"ematical":10425,"dchoi77":10426,"glance":10427,"Winston":10428,"demo":10429,"depicted":10430,"stances":10431,"thou":10432,"compromising":10433,"coats":10434,"mxnet":10435,"07022":10436,"differentiation":10437,"balancing":10438,"pathbreaking":10439,"56%":10440,"worse":10441,"loping":10442,"McCann":10443,"immersive":10444,"SCCLLM":10445,"Middle":10446,"reported":10447,"lightweight":10448,"𝛽":10449,"0.7359":10450,"wh":10451,"themes":10452,"19355":10453,"eyed":10454,"DALI":10455,"Inside":10456,"Intersection":10457,"2292.7":10458,"fully":10459,"616":10460,"Mohammad":10461,"Between":10462,"2U":10463,"lever":10464,"subsidiaries":10465,"constants":10466,"MedTech":10467,"ingly":10468,"Love":10469,"frisbees":10470,"5163":10471,"provenance":10472,"464":10473,"Allergan":10474,"Discussions166":10475,"wide":10476,"tackled":10477,"Boyd":10478,"MLPScratch":10479,"aims":10480,"Properties":10481,"Distinctive":10482,"ViewBackward0":10483,"explodes":10484,"0.9940":10485,"transmission":10486,"Stevens":10487,"MDFs":10488,"2690v4":10489,"dense":10490,"cortical":10491,"suddenly":10492,"en":10493,"enhancements":10494,"365":10495,"Translation":10496,"xxiv":10497,"Yiming":10498,"reasoning":10499,"bouncing":10500,"termediate":10501,"Team":10502,"ratio":10503,"2cm":10504,"CrowdStrike":10505,"large":10506,"bution":10507,"browser":10508,"reach":10509,"sto":10510,"availability":10511,"Swish":10512,"941":10513,"reparametrizes":10514,"Animator":10515,"4570":10516,"warranty":10517,"Identi":10518,"9197404791177789":10519,"Expense":10520,"Alex":10521,"M":10522,"termination":10523,"drinks":10524,"Recent":10525,"listwise":10526,"Ajay":10527,"586":10528,"disjoint":10529,"1409":10530,"1828":10531,"bus":10532,"references":10533,"guide":10534,"troubles":10535,"Thesis":10536,"lessly":10537,"Nomination":10538,"2130":10539,"Darrell":10540,"LazyBatchNorm2d":10541,"Pu":10542,"1447":10543,"9th":10544,"recognition":10545,"compensatory":10546,"cmap":10547,"FP16":10548,"Aggregate":10549,"Retain":10550,"Intuit":10551,"pick":10552,"LIBRARY":10553,"153846":10554,"pin":10555,"channels":10556,"Kress":10557,"Kouzelis":10558,"一张":10559,"magnify":10560,"BatchNorm":10561,"consequence":10562,"ri":10563,"reusing":10564,"R1024":10565,"promising":10566,"microinstructions":10567,"intuitions":10568,"frontends":10569,"最小":10570,"divestitures":10571,"LocalSearcher":10572,"Overview":10573,"预期":10574,"882":10575,"A4":10576,"noticeable":10577,"centered":10578,"predated":10579,"issuers":10580,"543":10581,"15097":10582,"Ungar":10583,"atop":10584,"forwarding":10585,"subjected":10586,"mult":10587,"Rasul":10588,"2616":10589,"winners":10590,"cryptocurrencies":10591,"microseconds":10592,"deployment":10593,"remediate":10594,"12.8":10595,"transmit":10596,"请勿":10597,"exposure":10598,"Advisory":10599,"invention":10600,"Covariate":10601,"cadence":10602,"foodservice":10603,"overall":10604,"DeepBlue":10605,"Print":10606,"ulation":10607,"495":10608,"ASE":10609,"tick":10610,"helped":10611,"Serialization":10612,"prominently":10613,"competencies":10614,"Hyeong":10615,"digitization":10616,"detects":10617,"0.090":10618,"teams":10619,"2990":10620,"automobiles":10621,"circuits":10622,"6257":10623,"Supplemental":10624,"recruiting":10625,"hub":10626,"larities":10627,"Exploring":10628,"direction":10629,"6342":10630,"Emphasize":10631,"algebra":10632,"corruption":10633,"PromptDiff":10634,"!":10635,"Equations":10636,"tweak":10637,"A.12":10638,"Post":10639,"错误":10640,"Unamortized":10641,"tight":10642,"tical":10643,"0.186632":10644,"novella":10645,"Male":10646,"screenful":10647,"gal":10648,"Maps":10649,"sion":10650,"prime":10651,"Graber":10652,"Baratov":10653,"places":10654,"leap":10655,"Shoeybi":10656,"conceiving":10657,"Inc":10658,"Discussions124":10659,"doodlers":10660,"eigendecompositions":10661,"gpy":10662,"Website":10663,"matches":10664,"compared":10665,"534":10666,"Whq":10667,"\u001a":10668,"Remarkably":10669,"bags":10670,"skew":10671,"1.1950":10672,"∗":10673,"sections":10674,"notion":10675,"CORE":10676,"tolist":10677,"wreck":10678,"42b":10679,"689":10680,"INSTALLED":10681,"0519":10682,"familiarity":10683,"fol":10684,"autumn":10685,"Decomposed":10686,"DeCandia":10687,"goal":10688,"components":10689,"286225":10690,"Cumulative":10691,"resold":10692,"Loading":10693,"analytic":10694,"affected":10695,"handled":10696,"encourages":10697,"herewith":10698,"Achievements":10699,"family":10700,"Sustainability":10701,"Period":10702,"converges":10703,"EU":10704,"1092":10705,"Refine":10706,"Reference":10707,"traversing":10708,"figures":10709,"decode":10710,"affection":10711,"segments":10712,"707":10713,"adhering":10714,"doodle":10715,"1773":10716,"erased":10717,"collaborations":10718,"illustrates":10719,"experts":10720,"以":10721,"meaningless":10722,"Download":10723,"experi":10724,"Outputs":10725,"pean":10726,"Reingold":10727,"Kakulapati":10728,"latest":10729,"column":10730,"thousand":10731,"import":10732,"ecosystem":10733,"block2":10734,"0.1022":10735,"USG":10736,"issuances":10737,"wisdom":10738,"4":10739,"backing":10740,"Yum":10741,"210":10742,"minich":10743,"ubyte":10744,"Returns":10745,"TM":10746,"Levskaya":10747,"READ":10748,"presentation":10749,"fades":10750,"timation":10751,"anchor":10752,"Amsterdam":10753,"Contingent":10754,"Lakshman":10755,"327":10756,"Concat":10757,"714":10758,"mentioned":10759,"Theoria":10760,"lkj":10761,"Transformations":10762,"9.7":10763,"deer":10764,"xxviii":10765,"Blenderbot":10766,"Vectorizing":10767,"liqingnz":10768,"ResNeXt":10769,"nal":10770,"Gray":10771,"Bepler":10772,"immediately":10773,"Ayed":10774,"Aug":10775,"label":10776,"Feel":10777,"china":10778,"1Whr":10779,"ORCL":10780,"0.3":10781,"films":10782,"recognizability":10783,"fashion":10784,"Wishart":10785,"Whh":10786,"55th":10787,"queue":10788,"开发进展":10789,"gift":10790,"cosines":10791,"package":10792,"imshow":10793,"20549":10794,"Indeed":10795,"terov":10796,"demonstrated":10797,"Cropping":10798,"technologies":10799,"probabilistically":10800,"proportionally":10801,"crimes":10802,"422":10803,"如下":10804,"smooths":10805,"imagination":10806,"713":10807,"08053":10808,"folding":10809,"akin":10810,"735":10811,"conditioned":10812,"senting":10813,"NiN":10814,"overwrite":10815,"nite":10816,"billed":10817,"093":10818,"initiative":10819,"∀":10820,"intentional":10821,"GAC":10822,"1W":10823,"Probably":10824,"agrees":10825,"Flipping":10826,"downward":10827,"while":10828,"ear":10829,"monotonic":10830,"Coming":10831,"complish":10832,"defects":10833,"pxrds":10834,"BFGS":10835,"domains":10836,"多":10837,"preserve":10838,"request":10839,"成果":10840,"mistaking":10841,"1990s":10842,"Incorrectly":10843,"modicum":10844,"—":10845,"corresponding":10846,"proficient":10847,"pointed":10848,"Libraries":10849,"Deviation":10850,"75th":10851,"century":10852,"convex":10853,"16714":10854,"Tessera":10855,"Sellers":10856,"sustainable":10857,"Revisions":10858,"Similarly":10859,"healthy":10860,"Agreement":10861,"Smith":10862,"s0":10863,"Bistro":10864,"lose":10865,"Keqing":10866,"schedulers":10867,"minimize":10868,"protect":10869,"excel":10870,"scientist":10871,"ple":10872,"bend":10873,"provisional":10874,"searched":10875,"as":10876,"tual":10877,"6G":10878,"Disclosure":10879,"inactions":10880,"indexes":10881,"learners":10882,"Trainer":10883,"'":10884,"discriminate":10885,"Microsoft":10886,"Discussions147":10887,"EmilyOng":10888,"reclassified":10889,"Abdullah":10890,"1D":10891,"putative":10892,"male":10893,"335989":10894,"assuming":10895,"telling":10896,"sublayer":10897,"Few":10898,"hardly":10899,"mendations":10900,"783":10901,"PetaFLOP":10902,"Standardizing":10903,"pursuant":10904,"leak":10905,"niently":10906,"request308":10907,"Marginal":10908,"delay":10909,"Sie":10910,"Confers":10911,"Same":10912,"tin":10913,"threaded":10914,"initiate":10915,"Membership":10916,"granting":10917,"intel":10918,"7818":10919,"Torralba":10920,"More":10921,"987":10922,"Schedules":10923,"Servers":10924,"Snowflake":10925,"Meta":10926,"thereunto":10927,"navigate":10928,"manually":10929,"sunset":10930,"substituted":10931,"notices":10932,"Approximate":10933,"Jenatton":10934,"Extraction":10935,"𝑏":10936,"c2":10937,"Quantized":10938,"Tuli":10939,"denies":10940,"dicting":10941,"duly":10942,"alone":10943,"Discussions110":10944,"Could":10945,"400000":10946,"stan":10947,"899987":10948,"shirts":10949,"Archimedes":10950,"autoregression":10951,"0298":10952,"dirty":10953,"receipts":10954,"Program":10955,"Bounding":10956,"altogether":10957,"availabil":10958,"unilateral":10959,"HGNN":10960,"flat":10961,"Quantitative":10962,"Eventually":10963,"patient":10964,"REFSQL":10965,"𝐼":10966,"Alaskan":10967,"24xlarge":10968,"serving":10969,"Contrary":10970,"Rawat":10971,"xiii":10972,"increases":10973,"Gehring":10974,"iterating":10975,"dependency":10976,"Cell":10977,"leader":10978,"03983":10979,"strokes":10980,"2011":10981,"924":10982,"assign":10983,"joke":10984,"imaginary":10985,"frugal":10986,"associate":10987,"Bowles":10988,"Companies":10989,"je":10990,"purple":10991,"restore":10992,"electric":10993,"updatable":10994,"questions":10995,"Han":10996,"cuBLAS":10997,"In":10998,"servation":10999,"Krizhevsky":11000,"NPM":11001,"average":11002,"BENCHMARK":11003,"distorted":11004,"certiorari":11005,"guar":11006,"refundable":11007,"guoweis":11008,"Sha":11009,"Around":11010,"surfaced":11011,"divisible":11012,"hood":11013,"姓名":11014,"transformed":11015,"survives":11016,"innovative":11017,"1703":11018,"Codet5mix":11019,"0.017":11020,"exclusive":11021,"interpreting":11022,"Cheng":11023,"lates":11024,"learn":11025,"reproducing":11026,"7606":11027,"Glass":11028,"占用":11029,"launch":11030,"California":11031,"1100":11032,"biolaysumm":11033,"Latency":11034,"masked":11035,"modernizing":11036,"1890":11037,"forget":11038,"kl":11039,"Again":11040,"developed":11041,"alto":11042,"MU":11043,"extraordinary":11044,"enrichment":11045,"SHAH":11046,"ingests":11047,"linearity":11048,"adequate":11049,"ylim":11050,"Computing":11051,"handles":11052,"views":11053,"dominates":11054,"factorizing":11055,"Wellesley":11056,"tationally":11057,"poten":11058,"239":11059,"Dehghani":11060,"partitions":11061,"necessitating":11062,"holidays":11063,"preferred":11064,"protease":11065,"merely":11066,"convolutional":11067,"Notified":11068,"2209":11069,"IC":11070,"Discussions153":11071,"unrealized":11072,"art":11073,"A.20":11074,"Ukraine":11075,"mainboards":11076,"rocal":11077,"mystery":11078,"industry":11079,"proposal":11080,"835":11081,"Community":11082,"username":11083,"Hamas":11084,"IT":11085,"Surveillance":11086,"temperature":11087,"ELECTRA":11088,"tomography":11089,"including":11090,"joining":11091,"258":11092,"convolutions":11093,"gaussian":11094,"deviate":11095,"xxi":11096,"torchvision":11097,"mappings":11098,")":11099,"Vested":11100,"swaths":11101,"indefinitely":11102,"sides":11103,"例如":11104,"autoregressive":11105,"Standards":11106,"ConvolutionBackward0":11107,"profitability":11108,"Decision":11109,"syllogism":11110,"581%":11111,"excitation":11112,"rather":11113,"overhang":11114,"tiple":11115,"dicted":11116,"3200":11117,"Constructing":11118,"alike":11119,"8341":11120,"summation":11121,"Lm":11122,"x2":11123,"actually":11124,"announced":11125,"balls":11126,"Ratification":11127,"439":11128,"Different":11129,"Devvrit":11130,"Kasparov":11131,"Software":11132,"problem":11133,"bypassing":11134,"shell":11135,"distribute":11136,"Kolmogorov":11137,"Resdsql":11138,"1026":11139,"GDDR6194":11140,"A.51":11141,"Beam":11142,"compensate":11143,"board":11144,"discriminant":11145,"pivotal":11146,"313873":11147,"advances":11148,"fit":11149,"minor":11150,"1.6486":11151,"burn":11152,"epochs":11153,"insist":11154,"wild":11155,"SYNCHROMESH":11156,"Factors":11157,"charged":11158,"tensorloader":11159,"lin1":11160,"nsp":11161,"poisson":11162,"Discussions168":11163,"2424":11164,"snip":11165,"alization":11166,"endeavor":11167,"custom":11168,"sequence":11169,"bias":11170,"KILT":11171,"extension":11172,"Plotting":11173,"ax":11174,"ALL":11175,"Volvo":11176,"gorithm":11177,"vanishing":11178,"adeptly":11179,"Composite":11180,"Benchmarking":11181,"demonstrates":11182,"recur":11183,"GF":11184,"minimalistic":11185,"Hoi":11186,"spikes":11187,"upwards":11188,"2302":11189,"Scene":11190,"938":11191,"shrink":11192,"Compiling":11193,"chunked":11194,"resolu":11195,"tagging":11196,"frequentist":11197,"Moving":11198,"Investigating":11199,"Yankees":11200,"Stepback":11201,"Conversely":11202,"resizing":11203,"monoT5":11204,"intensely":11205,"5955":11206,"0.0022":11207,"undoes":11208,"completion":11209,"Hynix":11210,"returned":11211,"Kan":11212,"tiny":11213,"Flat":11214,"325":11215,"vendors":11216,"dd":11217,"uwsd":11218,"bedding":11219,"17th":11220,"Building":11221,",":11222,"manageable":11223,"Practice":11224,"Breaking":11225,"TB":11226,"budget":11227,"ingenious":11228,"Learn":11229,"tures":11230,"BLLM":11231,"anachro":11232,"generative":11233,"Jaccard":11234,"neurophysiologists":11235,"McCul":11236,"gt":11237,"produce":11238,"curring":11239,"reviewed":11240,"12.3":11241,"Sora":11242,"quantized":11243,"Fix":11244,"532":11245,"Whereas":11246,"options":11247,"spreads":11248,"e03d187e043d2a17cae636d6af164015":11249,"recog":11250,"assembling":11251,"pending":11252,"boring":11253,"0th":11254,"unsur":11255,"Students":11256,"accelerates":11257,"expres":11258,"ids":11259,"Stoyanov":11260,"extending":11261,"imagen":11262,"Convolutional":11263,"cmd":11264,"Carrying":11265,"VGA":11266,"LeCun":11267,"implementing":11268,"subtracting":11269,"Extraordinary":11270,"ponder":11271,"atgctg":11272,"cone":11273,"limitation":11274,"数量":11275,"readiness":11276,"ther":11277,"Label":11278,"Fi":11279,"regarding":11280,"Ji":11281,"superintelligence":11282,"03098":11283,"reward":11284,"Research":11285,"45":11286,"early":11287,"NVDA":11288,"packing":11289,"Networks":11290,"sively":11291,"awards":11292,"Connection":11293,"spammers":11294,"dispose":11295,"INTRODUCTION":11296,"procedure":11297,"CleanTechnica":11298,"deeply":11299,"nominate":11300,"lastly":11301,"Consequently":11302,"altered":11303,"nnnnnInnnThe":11304,"Spoken":11305,"GP":11306,"misclassification":11307,"timizers":11308,"catenated":11309,"Goodman":11310,"Joe":11311,"restrictive":11312,"Karpukhin":11313,"Synthetic":11314,"benefiting":11315,"CACM":11316,"67%":11317,"capacities":11318,"pledging":11319,"google":11320,"B.4":11321,"Scaled":11322,"explainable":11323,"WikiText":11324,"Logit":11325,"cd43bfb07e44e6f27cbcc7bc9ae3d80284fdaf5a":11326,"1y":11327,"9.6":11328,"rested":11329,"occurs":11330,"Comments":11331,"chinese":11332,"simulta":11333,"AARTI":11334,"014076":11335,"hansent":11336,"ch13":11337,"AST":11338,"displaced":11339,"connectionist":11340,"Obligations":11341,"0276":11342,"Numbers":11343,"valuation":11344,"1645":11345,"marking":11346,"V100":11347,"02155":11348,"manifests":11349,"Determining":11350,"inherited":11351,"validly":11352,"lock":11353,"methods":11354,"accepts":11355,"COCO":11356,"04615":11357,"spond":11358,"Murray":11359,"Joseph":11360,"divides":11361,"attempts":11362,"continuation":11363,"1833":11364,"王五":11365,"dpkg":11366,"553":11367,"Bandits":11368,"Mathematical":11369,"confront":11370,"nisation":11371,"thereafter":11372,"Baek":11373,"16kHz":11374,"Strictly":11375,"2027":11376,"TOME":11377,"Symbolic":11378,"tons":11379,"shocking":11380,"engineers":11381,"molecular":11382,"Fargo":11383,"QLC":11384,"69%":11385,"Accountant":11386,"多栏":11387,"wow":11388,"mdp":11389,"precisely":11390,"flipping":11391,"iid":11392,"Lowes":11393,"Delete":11394,"0.1044":11395,"typewriter":11396,"pilot":11397,"Angles":11398,"12xlarge":11399,"stats":11400,"automakers":11401,"07220":11402,"quaternion":11403,"100k":11404,"2e":11405,"Defined":11406,"Rescal":11407,"Hardware":11408,"4881":11409,"Duan":11410,"evolutions":11411,"AC":11412,"issuer":11413,"Claims":11414,"etry":11415,"layout":11416,"nicely":11417,"bombs":11418,"580":11419,"bar":11420,"Sawhney":11421,"2060":11422,"corrector":11423,"LoRA":11424,"487762":11425,"radical":11426,"Setting":11427,"remainder":11428,"Unsettled":11429,"illustrate":11430,"balance":11431,"Macs":11432,"example263":11433,"9449":11434,"013779522851109505":11435,"CPRA":11436,"SWITCH":11437,"HPOTuner":11438,"Discussions152":11439,"Suppose":11440,"encodings":11441,"Seq2Seq":11442,"anywhere":11443,"Fortune":11444,"morning":11445,"satisfying":11446,"fact":11447,"ratings":11448,"Workshop":11449,"troduction":11450,"1606":11451,"ulary":11452,"Araki":11453,"governing":11454,"loves":11455,"Re":11456,"12363":11457,"Koltun":11458,"2337":11459,"ContinuousBernoulli":11460,"compo":11461,"level":11462,"wear":11463,"𝛾":11464,"1916":11465,"mentions":11466,"李四":11467,"Hybridizing":11468,"8165":11469,"Method":11470,"smorgasbord":11471,"distortions":11472,"mil":11473,"timer":11474,"DIVKNOWQA":11475,"1095":11476,"Beneficial":11477,"Rome":11478,"Lim":11479,"extend":11480,"schedule":11481,"suits":11482,"phase":11483,"prospectively":11484,"triangle":11485,"bility":11486,"trievers":11487,"rectional":11488,"scenarios":11489,"overweighted":11490,"105599":11491,"ESEC":11492,"given":11493,"Extra":11494,"sit":11495,"Logging":11496,"quantitatively":11497,"Cells":11498,"CORPORATION":11499,"Schuster":11500,"Organiza":11501,"Johnson":11502,"0264":11503,"frozen":11504,"610689":11505,"ACHIEVEMENT":11506,"Knowledge":11507,"stack":11508,"isnan":11509,"willingness":11510,"myriad":11511,"wget":11512,"likewise":11513,"Srivastav":11514,"featuring":11515,"BERTBASE":11516,"dropout":11517,"UPON":11518,"That":11519,"Emphasized":11520,"名称":11521,"subfolders":11522,"extrapolating":11523,"v3":11524,"Proposal":11525,"policymakers":11526,"adding":11527,"plished":11528,"Nesterov":11529,"subjective":11530,"beautiful":11531,"ternatively":11532,"curl":11533,"表格":11534,"moved":11535,"therein":11536,"Athletic":11537,"required":11538,"carrying":11539,"manifesting":11540,"eigs":11541,"249007":11542,"ReLU":11543,"collate":11544,"page":11545,"src":11546,"Dyer":11547,"Interestingly":11548,"miller":11549,"3112":11550,"educating":11551,"203":11552,"Cornelia":11553,"0522":11554,"contentious":11555,"pull":11556,"suitably":11557,"Perceptrons":11558,"rulings":11559,"Mdiag":11560,"applied":11561,"August":11562,"PCAST":11563,"engineered":11564,"SIFT":11565,"generaliza":11566,"INS":11567,"enthusiastically":11568,"unfortu":11569,"field":11570,"composed":11571,"so":11572,"fixed":11573,"this":11574,"py39":11575,"Samsung":11576,"𝛿":11577,"Schedulers":11578,"Bakshy":11579,"Fork":11580,"Variables":11581,"𝑦":11582,"Acecoder":11583,"unaffected":11584,"plateaus":11585,"ject":11586,"to":11587,"coarse":11588,"plots":11589,"permutations":11590,"gates":11591,"powers":11592,"215%":11593,"381":11594,"blind":11595,"posed":11596,"hw2":11597,"Wightman":11598,"SIGKDD":11599,"contested":11600,"TPU":11601,"mensions":11602,"counterintuitive":11603,"bel":11604,"forces":11605,"sons":11606,"mpl":11607,"challenging":11608,"Hayashi":11609,"1089":11610,"662":11611,"Eghbali":11612,"burning":11613,"blur":11614,"sharing":11615,"2639":11616,"Wind":11617,"01108":11618,"expenditure":11619,"claims":11620,"cores":11621,"Cooperation":11622,"Ashual":11623,"promotion":11624,"urel":11625,"disease":11626,"Tyagi":11627,"Benz":11628,"FrozenLake":11629,"grab":11630,"HDD":11631,"RACE":11632,"ozgur":11633,"imperative":11634,"regularly":11635,"trickier":11636,"Chakraborty":11637,"streamlines":11638,"cells":11639,"543102":11640,"caller":11641,"Anyone":11642,"Electro":11643,"advancement":11644,"stat":11645,"perfect":11646,"answer":11647,"configuration":11648,"Problems":11649,"mimic":11650,"Csisz":11651,"143":11652,"perfor":11653,"1.5723":11654,"Equivalently":11655,"Abid":11656,"Wesley":11657,"Venn":11658,"lar":11659,"assistants":11660,"Dollar":11661,"multinational":11662,"implicit":11663,"Saynova":11664,"needing":11665,"4743":11666,"opus":11667,"attention":11668,"0.01":11669,"stewardship":11670,"proceed":11671,"Unified":11672,"Programming":11673,"Nan":11674,"HSG":11675,"536":11676,"cyber":11677,"dz":11678,"nonzeros":11679,"vol":11680,"One":11681,"perception":11682,"5968":11683,"HPE":11684,"customization":11685,"deferral":11686,"A.22":11687,"fraction":11688,"modularize":11689,"2529":11690,"4990":11691,"shares":11692,"Retirement":11693,"intelli":11694,"3175":11695,"Probability":11696,"Zou":11697,"programmers":11698,"unigrams":11699,"∩":11700,"lamest":11701,"Tikhonov":11702,"Sym":11703,"rebroadcast":11704,"wrap":11705,"MFLOPS":11706,"addi":11707,"1000s":11708,"301029995.6":11709,"gravity":11710,"2385":11711,"pennystock":11712,"Reddi":11713,"interpretably":11714,"competitive":11715,"Green500":11716,"Yime":11717,"illustrative":11718,"efficiently":11719,"Taskar":11720,"SLAC":11721,"8748":11722,"func":11723,"bound":11724,"Bapat":11725,"explode":11726,"𝐶":11727,"smiley":11728,"Quorum":11729,"vanishes":11730,"see":11731,"A.16":11732,"162754":11733,"PipeRAG":11734,"synchronisation":11735,"787":11736,"women":11737,"26e":11738,"concreteness":11739,"Reflects":11740,"Nobel":11741,"Batching":11742,"1021":11743,"184":11744,"ligand":11745,"Potts":11746,"figuring":11747,"Specifications":11748,"Demonstration":11749,"Nowadays":11750,"×":11751,"Silver":11752,"grouping":11753,"restaurant":11754,"tence":11755,"2832":11756,"bounding":11757,"domestic":11758,"894":11759,"Proc":11760,"A.25":11761,"emphasize":11762,"modality":11763,"Shen":11764,"𝑣":11765,"xs":11766,"元":11767,"551":11768,"07258":11769,"quest":11770,"continually":11771,"tanks":11772,"supercomputers":11773,"Braud":11774,"Yi":11775,"timeliness":11776,"ticular":11777,"spitting":11778,"mask":11779,"Revoke":11780,"reinstate":11781,"marginalization":11782,"Virtually":11783,"Recognition":11784,"clock":11785,"L1Loss":11786,"2537":11787,"system":11788,"129":11789,"10483132064775551":11790,"Comparison":11791,"页":11792,"harness":11793,"9245":11794,"Clearly":11795,"LangChain":11796,"Probabilities":11797,"Judgement":11798,"继续":11799,"tives":11800,"Yanase":11801,"Penalty":11802,"irrelevant":11803,"tik":11804,"nanasDataset":11805,"NVP":11806,"Kryder":11807,"dictio":11808,"El":11809,"certificate":11810,"mantissa":11811,"Sachan":11812,"955":11813,"chop":11814,"White":11815,"serialize":11816,"Matters":11817,"DSL":11818,"Xiong":11819,"resource":11820,"side":11821,"Least":11822,"Adopts":11823,"gducharme":11824,"halving":11825,"hampers":11826,"SoftplusTransform":11827,"1050":11828,"Channel":11829,"TransformedDistribution":11830,"MTG":11831,"boxcar":11832,"interconnect":11833,"4693":11834,"retriever":11835,"promulgated":11836,"set":11837,"Excludes":11838,"FP32":11839,"Part":11840,"multiprocessor":11841,"Abhinav":11842,"Universal":11843,"clothes":11844,"2420":11845,"incrementally":11846,"outlet":11847,"note":11848,"Copy":11849,"Rfou":11850,"corporation":11851,"Customer":11852,"Nearest":11853,"Preconditioning":11854,"Asanovic190":11855,"Committees":11856,"control":11857,"853":11858,"Future":11859,"serialization":11860,"solicited":11861,"rmsprop":11862,"tuples":11863,"集成":11864,"⊂":11865,"2511":11866,"convince":11867,"Yu":11868,"flight":11869,"Vaessen":11870,"figsize":11871,"popped":11872,"attened":11873,"Techni":11874,"incorrectly":11875,"𝜖":11876,"Equity":11877,"0365":11878,"envisioned":11879,"EMNLP":11880,"530":11881,"Starting":11882,"MuJoCo":11883,"Retained":11884,"DistBelief":11885,"break":11886,"router":11887,"Chancery":11888,"modernize":11889,"Schedule":11890,"unlocking":11891,"Discussions130":11892,"LI":11893,"DPUs":11894,"Eargo":11895,"Massa":11896,"Working":11897,"abbreviated":11898,"0286":11899,"4090":11900,"caused":11901,"320":11902,"interpret":11903,"Estimated":11904,"campaign":11905,"reposi":11906,"892":11907,"completed":11908,"profoundly":11909,"frogs":11910,"需要":11911,"associating":11912,"trial":11913,"st":11914,"cart":11915,"0850":11916,"genuine":11917,"discard":11918,"Puri":11919,"summary":11920,"prisingly":11921,"lenging":11922,"haozhu233":11923,"Irrevocable":11924,"signal":11925,"harmlessness":11926,"sole":11927,"rely":11928,"85189199447632":11929,"STEPHEN":11930,"Ux":11931,"ties":11932,"1296":11933,"cancelled":11934,"Cuong":11935,"rections":11936,"dcbb9e9d":11937,"recycling":11938,"1048":11939,"imitate":11940,"naive":11941,"ging":11942,"ä":11943,"relating":11944,"voltage":11945,"graph":11946,"1074":11947,"Mature":11948,"worthy":11949,"Cores":11950,"Install":11951,"xxv":11952,"Mensch":11953,"largely":11954,"patchifies":11955,"stayed":11956,"884":11957,"Shun":11958,"Twice":11959,"Balso":11960,"Used":11961,"SN2":11962,"销售":11963,"erful":11964,"homelessness":11965,"𝑀":11966,"concretely":11967,"Convnets":11968,"Variable":11969,"colormap":11970,"Roychowdhury":11971,"allowing":11972,"phone":11973,"leaves":11974,"1072":11975,"races":11976,"usual":11977,"vests":11978,"Remember":11979,"Round":11980,"were":11981,"ta":11982,"Forfeitures":11983,"74":11984,"holding":11985,"derives":11986,"reasonableness":11987,"8103":11988,"01392":11989,"Actual":11990,"INT8":11991,"1543":11992,"1087":11993,"resis":11994,"settlements":11995,"Lengthy":11996,"1.2412":11997,"disseminating":11998,"blue":11999,"5444":12000,"Xiaomi":12001,"partnered":12002,"Book312":12003,"knows":12004,"contextualized":12005,"Summarize":12006,"coupled":12007,"modeled":12008,"Lafeez":12009,"N95":12010,"editing":12011,"Requirements":12012,"beginners":12013,"三段":12014,"terminating":12015,"Kindi":12016,"𝜃":12017,"viewpoints":12018,"mydict":12019,"dynamic":12020,"080":12021,"Datla":12022,"Mem":12023,"and":12024,"retrospectively":12025,"tying":12026,"1860":12027,"detour":12028,"VB":12029,"Kingma":12030,"visualizing":12031,"NIVIDA":12032,"Epyc":12033,"Albumentations":12034,"HBM":12035,"277195":12036,"Discussions136":12037,"handle":12038,"207":12039,"571":12040,"engines":12041,"naively":12042,"5393":12043,"OVERVIEW":12044,"prepended":12045,"ditches":12046,"Gerschgorin":12047,"testable":12048,"3125":12049,"shortened":12050,"injunctive":12051,"Rhyu":12052,"Gholampoor":12053,"Aboobakuru":12054,"scene":12055,"luxury":12056,"pAdvisor":12057,"csv":12058,"sporting":12059,"players":12060,"squeezing":12061,"attends":12062,"ace":12063,"compilers":12064,"Silicon":12065,"Eliot":12066,"On":12067,"erably":12068,"computationally":12069,"leaderboard":12070,"5826":12071,"Vesting":12072,"spades":12073,"Radford":12074,"letter":12075,"Pointwise":12076,"Frozen":12077,"defined":12078,"数据表":12079,"06125":12080,"charms":12081,"25":12082,"RMS":12083,"mean":12084,"876":12085,"disability":12086,"896":12087,"𝐷":12088,"routinely":12089,"385":12090,"sheer":12091,"evil":12092,"suspend":12093,"threads":12094,"pins":12095,"minimal":12096,"1004":12097,"足够":12098,"patent":12099,"tial":12100,"306":12101,"symbolic":12102,"baselines":12103,"μ":12104,"105":12105,"NAC":12106,"Eigenvectors":12107,"nominated":12108,"characters":12109,"0821":12110,"GUI":12111,"Shift":12112,"Uhlenbeck":12113,"consecu":12114,"Multiplication":12115,"solely":12116,"Concurrently":12117,"traversed":12118,"Feurer":12119,"CoT":12120,"Linux":12121,"extractive":12122,"00100":12123,"Eugene":12124,"Bell":12125,"diner":12126,"Higher":12127,"能力":12128,"fatal":12129,"Epidemiology":12130,"indexing51":12131,"transforms":12132,"neither":12133,"196":12134,"expla":12135,"7A":12136,"API":12137,"compresses":12138,"Expanding":12139,"3009":12140,"beings":12141,"Fitting":12142,"268":12143,"Compare":12144,"keeps":12145,"obligations":12146,"runs":12147,"Pulse":12148,"Comprehensive":12149,"subprocess":12150,"Granted":12151,"simplicity":12152,"discrepancy":12153,"Papamarkou":12154,"Spam":12155,"238":12156,"1010":12157,"Switch":12158,"clarity":12159,"Longformer":12160,"packaged":12161,"theoretical":12162,"duet":12163,"readability":12164,"blows":12165,"hiddens":12166,"taken":12167,"HyperParameters":12168,"scheduler":12169,"Stripe":12170,"erf":12171,"COSO":12172,"multiscale":12173,"Formulate":12174,"QARAG":12175,"trader":12176,"stitches":12177,"796":12178,"Laboratories":12179,"lengthens":12180,"DISC":12181,"Marketable":12182,"stick":12183,"𝑛":12184,"segmentation":12185,"1805":12186,"based":12187,"interaction":12188,"outlandish":12189,"932":12190,"Deadlines":12191,"Supermajority":12192,"speak":12193,"obviously":12194,"poly":12195,"OpenUSD":12196,"874":12197,"differently":12198,"bottlenecked":12199,"piece":12200,"allocate":12201,"portions":12202,"coelestum":12203,"containing":12204,"boosted":12205,"audio":12206,"1071":12207,"trices":12208,"painting":12209,"popularized":12210,"Processes":12211,"1013":12212,"Shortly":12213,"apart":12214,"680":12215,"item":12216,"hits":12217,"83%":12218,"Alphabet":12219,"Sonnet":12220,"incomplete":12221,"GRUs":12222,"Ignoring":12223,"embeds":12224,"get":12225,"Rumelhart":12226,"KGs":12227,"296":12228,"UCI":12229,"Transposition":12230,"4708":12231,"nearest":12232,"Arks":12233,"Oren":12234,"quantitative":12235,"Recurrent":12236,"1648877":12237,"wanted":12238,"Blackwell":12239,"throw":12240,"ODMs":12241,"Neocognitron":12242,"Wood":12243,"evalu":12244,"Bokeh48":12245,"MLPs":12246,"Gkioxari":12247,"ReLKT":12248,"applicants":12249,"918":12250,"PRELIMINARY":12251,"710":12252,"二段":12253,"Aircraft":12254,"BASHEX":12255,"这是":12256,"ambiguity":12257,"Nakkiran":12258,"ate":12259,"adjustable":12260,"Single":12261,"complaint":12262,"turbocharging":12263,"hashing":12264,"Hence":12265,"Ee":12266,"Huawei":12267,"surpris":12268,"初步":12269,"clearance":12270,"Goals":12271,"inherit":12272,"billion":12273,"1954":12274,"Valuation":12275,"1111":12276,"inform":12277,"inception":12278,"____________________________________________________":12279,"composition":12280,"Vanhoucke":12281,"cient":12282,"3860":12283,"GmbH":12284,"coffee":12285,"loading":12286,"Besides":12287,"quarter":12288,"demonstrating":12289,"nan":12290,"plementation":12291,"concentrated":12292,"casualty":12293,"far":12294,"eigen":12295,"Φ":12296,"sidering":12297,"hyperparameter":12298,"Discussions238":12299,"Advancing":12300,"owing":12301,"Figure":12302,"Discussions176":12303,"CLASSES":12304,"A.48":12305,"axis":12306,"𝑆":12307,"10.7":12308,"18.3":12309,"日期":12310,"4f":12311,"2.1695":12312,"repertoire":12313,"manner":12314,"fun":12315,"笔记本电脑":12316,"philosophical":12317,"distinguishes":12318,"confused":12319,"retaining":12320,"7924":12321,"Zentropa":12322,"multidimensional":12323,"hard":12324,"liaison":12325,"hid":12326,"verbally":12327,"attach":12328,"premiums":12329,"fundamentally":12330,"overlap":12331,"House":12332,"Number":12333,"dia":12334,"Jose":12335,"Chairperson":12336,"Tasks":12337,"affirmative":12338,"safer":12339,"Complete":12340,"intrinsically":12341,"theorem177":12342,"However":12343,"2680":12344,"Frobenius":12345,"traverses":12346,"responds":12347,"underscores":12348,"yourself":12349,"Accumulator":12350,"computation":12351,"Guilherme":12352,"MAE":12353,"seminal":12354,"0.023":12355,"544":12356,"Cambrian":12357,"spells":12358,"Cordonnier":12359,"Reitter":12360,"Col":12361,"provisioned":12362,"𝜎":12363,"𝐴":12364,"nearly":12365,"multiclass":12366,"2306":12367,"Utilization":12368,"remaster":12369,"moi":12370,"mid":12371,"randomized":12372,"348":12373,"predictors":12374,"sixth":12375,"Prices":12376,"James":12377,"Probabilistic":12378,"8763":12379,"wing":12380,"3482":12381,"CONFLICTINGQA":12382,"vii":12383,"discovery":12384,"distributions":12385,"acid":12386,"illegible":12387,"Swin":12388,"Leadership":12389,"disincentive":12390,"elusive":12391,"1000":12392,"tuple":12393,"dou":12394,"discarded":12395,"":12396,"combination":12397,"international":12398,"Ramachandra":12399,"peculiar":12400,"conceived":12401,"lightly":12402,"Localize":12403,"disks":12404,"´":12405,"co":12406,"ms":12407,"Enterprise":12408,"Cherti":12409,"committees":12410,"2000W":12411,"Pascanu":12412,"subs":12413,"07597":12414,"Archambeau":12415,"Con":12416,"Handle":12417,"Markov":12418,"publishing":12419,"mostly":12420,"基础":12421,"111483":12422,"sparked":12423,"languages":12424,"evaluative":12425,"typo":12426,"bh":12427,"argsort":12428,"Protection":12429,"chronized":12430,"Doing":12431,"Bad":12432,"584605":12433,"OEM":12434,"keyboard":12435,"Nominations":12436,"Doersch":12437,"semantic":12438,"According":12439,"countersuits":12440,"Fusing":12441,"Nuro":12442,"reporter":12443,"Simple":12444,"cohesive":12445,"1%":12446,"coarser":12447,"Except":12448,"上海":12449,"R2A":12450,"Japan":12451,"ice":12452,"Aside":12453,"cheap":12454,"DistilBERT":12455,"JOHN":12456,"0614":12457,"Tests":12458,"mitigates":12459,"KB":12460,"incurs":12461,"averaged":12462,"117":12463,"foundries":12464,"sweet":12465,"Lower":12466,"amplified":12467,"factor":12468,"9":12469,"bears":12470,"ramping":12471,"Schockaert":12472,"Digitalization":12473,"048":12474,"Wells":12475,"4795":12476,"Structure":12477,"probabili":12478,"artists":12479,"entrants":12480,"priori":12481,"Queries":12482,"Hutchins":12483,"England":12484,"WILL":12485,"shape":12486,"asymptotics":12487,"versus":12488,"Brooke":12489,"Wave":12490,"Atwood":12491,"fare":12492,"repos":12493,"生成":12494,"Averaging":12495,"2346":12496,"Count":12497,"K520":12498,"Maaten":12499,"Language":12500,"mix":12501,"Pay":12502,"lkelihood":12503,"rected":12504,"Worse":12505,"AN":12506,"degrees":12507,"stitutional":12508,"correcting":12509,"purchases":12510,"unfolds":12511,"degree":12512,"𝜆":12513,"tayfununal":12514,"Monitors":12515,"tensors":12516,"345":12517,"Refsql":12518,"Veness":12519,"GB":12520,"multiplica":12521,"filevich":12522,"1RealSoftMax":12523,"customized":12524,"evoke":12525,"Ignore":12526,"Buslaev":12527,"schemes":12528,"PageRank":12529,"leaky":12530,"08894":12531,"reg":12532,"obliterating":12533,"extensions":12534,"inner":12535,"outperform":12536,"plausible":12537,"Krema":12538,"unrolled":12539,"2309":12540,"Jindal":12541,"between":12542,"Rackoff":12543,"Tay":12544,"Epsilon":12545,"gpytorch":12546,"indirect":12547,"invites":12548,"Liaw":12549,"能手":12550,"sup":12551,"Dot":12552,"Ding":12553,"Scott":12554,"Finetuned":12555,"Pennington":12556,"corresponds":12557,"Visa":12558,"548":12559,"fusing":12560,"underscore":12561,"Memory":12562,"stockholders":12563,"generalize":12564,"io":12565,"}":12566,"nicate":12567,"Ilyas":12568,"Numerical":12569,"nn":12570,"land":12571,"flush":12572,"estima":12573,"Financial":12574,"thirty":12575,"561":12576,"uates":12577,"emp":12578,"poses":12579,"𝑥":12580,"Poloczek":12581,"advancements":12582,"girl":12583,"penghao":12584,"100002":12585,"Degree":12586,"369000":12587,"Retrieving":12588,"Arun":12589,"mainstay":12590,"distinction":12591,"equal":12592,"resonance":12593,"Turner":12594,"𝑞":12595,"aforementioned":12596,"Others":12597,"inappropriate":12598,"procurement":12599,"XBRL":12600,"transpose":12601,"Text":12602,"Joshua":12603,"iou":12604,"ab":12605,"tolerance":12606,"APPROVED":12607,"profiling":12608,"top":12609,"Imagnet":12610,"checks":12611,"unified":12612,"332":12613,"tails":12614,"corpus":12615,"clients":12616,"10694":12617,"nat":12618,"optimized":12619,"Schlatter":12620,"188":12621,"either":12622,"xd":12623,"hatch":12624,"图像":12625,"utili":12626,"workflows":12627,"sugges":12628,"AffineTransform":12629,"28th":12630,"videos":12631,"consuming":12632,"accepted":12633,"leon":12634,"x0":12635,"bunch":12636,"0.73":12637,"analy":12638,"beneath":12639,"05148":12640,"Thanh":12641,"inspiring":12642,"manual":12643,"There":12644,"Apricot":12645,"calculations":12646,"br":12647,"0.9713":12648,"Corrado":12649,"BURGESS":12650,"subregions":12651,"pad":12652,"toss":12653,"AND":12654,"gradient":12655,"ence":12656,"2024":12657,"dramati":12658,"mzz2017":12659,"xh":12660,"Khisamutdinov":12661,"0.5441":12662,"LazyBatchNorm1d":12663,"Conflict":12664,"devoting":12665,"213MB":12666,"660":12667,"Colmenarejo":12668,"Erhan":12669,"transaction":12670,"crops":12671,"161":12672,"Area":12673,"fueling":12674,"AWS":12675,"Fees":12676,"809":12677,"ln2":12678,"ubuntu":12679,"SEAB":12680,"SNLI":12681,"版":12682,"GRUScratch":12683,"Rectified":12684,"ogy":12685,"770":12686,"threats":12687,"share":12688,"vein":12689,"mixing":12690,"forwarded":12691,"4542":12692,"ADDITIONAL":12693,"dealt":12694,"liquid":12695,"executives":12696,"Electing":12697,"Amortizable":12698,"Top":12699,"We":12700,"moniker":12701,"exploit":12702,"Minima":12703,"14831":12704,"3557":12705,"Hsu":12706,"unidirectional":12707,"preventative":12708,"overfit":12709,"stalled":12710,"universities":12711,"Sukhbaatar":12712,"vec":12713,"sam":12714,"adap":12715,"Absolute":12716,"themselves":12717,"sich":12718,"restricts":12719,"01274":12720,"Discussions129":12721,"signif":12722,"decelerated":12723,"Complying":12724,"throttle":12725,"hotdog":12726,"chimera":12727,"perceptual":12728,"yscale":12729,"00012":12730,"itate":12731,"1301":12732,"gender":12733,"Transactions":12734,"generalization":12735,"Tech":12736,"06815":12737,"900037":12738,"Guyon":12739,"discovered":12740,"repurposing":12741,"B.11":12742,"erywhere":12743,"Jacob":12744,"probability":12745,"Massive":12746,"researcher":12747,"mentoring":12748,"ster":12749,"machinery":12750,"accountability":12751,"Techniques":12752,"Colin":12753,"fc":12754,"complement":12755,"Additions":12756,"compounds":12757,"supporting":12758,"829":12759,"Patch":12760,"文件":12761,"Recommending":12762,"continuous":12763,"minus":12764,"202":12765,"Prasanth":12766,"640":12767,"Staff":12768,"mem":12769,"TAG":12770,"pandas":12771,"hurts":12772,"1259":12773,"sity":12774,"Cola":12775,"rifts":12776,"datastore":12777,"unsatisfy":12778,"Effect":12779,"mandate":12780,"Microarchitecture":12781,"employers":12782,"canonical":12783,"hyperparame":12784,"joseppinilla":12785,"invertible":12786,"587":12787,"trend":12788,"engulfs":12789,"theorem":12790,"Payments":12791,"rically":12792,"Fu":12793,"02219":12794,"Ahmad":12795,"worldwide":12796,"Southeast":12797,"Performing":12798,"isinstance":12799,"Continuous":12800,"Kipf":12801,"Return":12802,"Early":12803,"Piktus":12804,"internal":12805,"146":12806,"684":12807,"Malachowsky":12808,"66":12809,"striking":12810,"recorded":12811,"--":12812,"introduced":12813,"Legal":12814,"downloadable":12815,"fmts":12816,"7640":12817,"Freund":12818,"7.2699":12819,"Canim":12820,"classifies":12821,"Replace":12822,"lousy":12823,"erring":12824,"commu":12825,"0314":12826,"den":12827,"cated":12828,"defending":12829,"principled":12830,"Anke":12831,"2081":12832,"Pareto":12833,"ensuring":12834,"unfortunate":12835,"Asynchronous":12836,"tour":12837,"Olshausen":12838,"Sutter":12839,"LORA":12840,"Lehtinen":12841,"tok":12842,"performing":12843,"Reader":12844,"Group":12845,"11205":12846,"Mo":12847,"stopping":12848,"const":12849,"identical":12850,"__":12851,"tends":12852,"EDIT":12853,"wheel":12854,"1069":12855,"Alobeidli":12856,"torchscript":12857,"focuses":12858,"final":12859,"0.0001":12860,"506":12861,"cnn":12862,"my":12863,"Parsing":12864,"Add":12865,"theoret":12866,"School":12867,"reduc":12868,"translated":12869,"sheets":12870,"frequent":12871,"forcing":12872,"pytorch":12873,"mum":12874,"racks":12875,"Defining":12876,"4465":12877,"collaborate":12878,"forest":12879,"shrinkage":12880,"0.92":12881,"console":12882,"Ill":12883,"constraint":12884,"Dating":12885,"selective":12886,"Chi2":12887,"Yasunaga":12888,"Applying":12889,"一个":12890,"sea":12891,"pre":12892,"1997":12893,"solutions":12894,"included":12895,"variability":12896,"ity":12897,"subsample":12898,"lawllm":12899,"smell":12900,"OV":12901,"status":12902,"memberships":12903,"agg":12904,"downwards":12905,"496118":12906,"comes":12907,"struct":12908,"rent":12909,"5684e":12910,"total":12911,"moments":12912,"drafts":12913,"comorbidities":12914,"02913976299993913":12915,"lters":12916,"Conv1d":12917,"Nonparametrics":12918,"representer":12919,"earning":12920,"Saad":12921,"Boards":12922,"theta":12923,"Term":12924,"Standardize":12925,"5998":12926,"fills":12927,"amino":12928,"Rose":12929,"Waveform":12930,"DPU":12931,"Recap":12932,"floor":12933,"Sigmoid":12934,"logo":12935,"argmax":12936,"\u0014":12937,"181600":12938,"Walter":12939,"deteriorate":12940,"Methodist":12941,"Minimum":12942,"年":12943,"engineer":12944,"interested":12945,"passing":12946,"1cm":12947,"Continued":12948,"benchmark":12949,"Docprompting":12950,"hensive":12951,"mae":12952,"prevails":12953,"transferable":12954,"Roots":12955,"Obviously":12956,"Bardenet":12957,"500000":12958,"Carlini":12959,"Encoders":12960,"glove":12961,"dos":12962,"shipping":12963,"Certificate":12964,"Interacting":12965,"ML":12966,"centrifugal":12967,"Islam":12968,"sensitivity":12969,"1600":12970,"952":12971,"primer":12972,"pieds":12973,"driving":12974,"Indian":12975,"recommender":12976,"tions":12977,"det":12978,"Horanic":12979,"Y2":12980,"slides":12981,"Left":12982,"colleague":12983,"1.4":12984,"Gram":12985,"sketches":12986,"weaknesses":12987,"restricting":12988,"Biswajit":12989,"utilized":12990,"Learned":12991,"7313":12992,"commenced":12993,"quickly":12994,"living":12995,"Packaged":12996,"geriatric":12997,"constantly":12998,"34":12999,"Sainath":13000,"7892434579795236":13001,"Budget":13002,"dissatisfaction":13003,"allocates":13004,"Managing":13005,"515":13006,"soft":13007,"488018":13008,"mecha":13009,"INVESTOR":13010,"neu":13011,"CrossEntropyLoss":13012,"intellectual":13013,"arately":13014,"confers":13015,"ephemeral":13016,"post188":13017,"NN":13018,"linalg":13019,"runtimes":13020,"shade":13021,"Like":13022,"Rademacher":13023,"tapped":13024,"0819":13025,"确保":13026,"bearing":13027,"dollars":13028,"Finished":13029,"b4":13030,"L4":13031,"functionalities":13032,"residential":13033,"revenue":13034,"inadvisable":13035,"Estimators":13036,"xz":13037,"Stand":13038,"application":13039,"chang":13040,"Nonlinear":13041,"presently":13042,"1964":13043,"Investigation":13044,"timemachine":13045,"2c":13046,"0318":13047,"754":13048,"Taylor":13049,"impinge":13050,"broadens":13051,"Gated":13052,"member":13053,"representation":13054,"exceptional":13055,"completing":13056,"Discussions102":13057,"articles":13058,"ServiceNow":13059,"William":13060,"693":13061,"ment":13062,"0.000018":13063,"plans":13064,"ctbl":13065,"𝜙":13066,"undue":13067,"1970s":13068,"daunting":13069,"cased":13070,"density":13071,"multinomial":13072,"Padding":13073,"Komeili":13074,"vigilance":13075,"indication":13076,"Janmey":13077,"Gopher":13078,"Slice":13079,"replacing":13080,"3623":13081,"Iyyer":13082,"softmin":13083,"striate":13084,"evolved":13085,"distances":13086,"relevance":13087,"probably":13088,"Regulators":13089,"chairperson":13090,"Jurisdictions":13091,"CEG":13092,"NishantTharani":13093,"DEF":13094,"Bowen":13095,"Likelihood":13096,"format":13097,"Similar":13098,"2040":13099,"grass":13100,"第二季度":13101,"transitioning":13102,"outweighs":13103,"annualized":13104,"Strategies":13105,"hunting":13106,"Welch":13107,"beliefs":13108,"Changes":13109,"RBF":13110,"011":13111,"172":13112,"mastered":13113,"explaining":13114,"intensities":13115,"every":13116,"telephone":13117,"modal":13118,"Claude":13119,"environments":13120,"ni":13121,"1448":13122,"Reveal":13123,"alignment":13124,"Randomized":13125,"Warde":13126,"skipping":13127,"animator":13128,"densities":13129,"preliminary":13130,"Pouplin":13131,"Instructions":13132,"Sarwar":13133,"Shamma":13134,"EXTRA":13135,"Subsequently":13136,"Sintaha":13137,"instabilities":13138,"differentiates":13139,"Hossain":13140,"623":13141,"reflections":13142,"report":13143,"misstatement":13144,"1182":13145,"ensembles":13146,"653495":13147,"客户":13148,"内部":13149,"MFLOPs":13150,"deepen":13151,"applicability":13152,"MONO":13153,"mous":13154,"05676":13155,"MELISSA":13156,"Precision":13157,"rest":13158,"951":13159,"Verification":13160,"Sundar":13161,"meticulously":13162,"anc":13163,"sensor":13164,"3032613031191755":13165,"injection":13166,"encodes":13167,"RESOLVED":13168,"SemEval":13169,"Much":13170,"necessitate":13171,"tbaums":13172,"9500":13173,"808":13174,"remote":13175,"339":13176,"Charter":13177,"own":13178,"Elman":13179,"train":13180,"housekeeping":13181,"finely":13182,"genera":13183,"Sort":13184,"ement":13185,"05085":13186,"EV":13187,"Zoe":13188,"fostering":13189,"Angeli":13190,"VOCtrainval":13191,"Gulwani":13192,"interpretability":13193,"hitting":13194,"sagemaker":13195,"one":13196,"teaching":13197,"v2":13198,"717":13199,"beijing":13200,"1.0022":13201,"err":13202,"overly":13203,"Prototype":13204,"138":13205,"institutional":13206,"Mizutani":13207,"MF":13208,"bottleneck":13209,"recipe":13210,"Khandelwal":13211,"reflection":13212,"Dividend":13213,"服务器":13214,"drug":13215,"apparent":13216,"Knowledgpt":13217,"expansion":13218,"comments":13219,"ICSME":13220,"ues":13221,"notedown":13222,"250%":13223,"730":13224,"observed":13225,"429":13226,";":13227,"threat":13228,"Sifre":13229,"Grants":13230,"keyword":13231,"compactly":13232,"consume":13233,"Inheriting":13234,"Paid":13235,"𝑜":13236,"Iterate":13237,"72%":13238,"flexible":13239,"RATP":13240,"oc":13241,"strike":13242,"agriculture":13243,"utterances":13244,"straightforward":13245,"JAX42":13246,"Zha":13247,"Pedapati":13248,"Normalization":13249,"fo":13250,"库存":13251,"spend":13252,"Almahairi":13253,"269":13254,"Suppression":13255,"thousands":13256,"159":13257,"Repeated":13258,"Those":13259,"consisting":13260,"Gool":13261,"courez":13262,"Contex":13263,"890":13264,"integer":13265,"trieval":13266,"Pillar":13267,"purpose":13268,"321":13269,"Greece":13270,"GeForce":13271,"ideal":13272,"email":13273,"compositions":13274,"scans":13275,"distributed":13276,"install":13277,"Cloning":13278,"pursuit":13279,"partner":13280,"Includes":13281,"708":13282,"bernoulli":13283,"itive":13284,"Cybersecurity":13285,"chaotic":13286,"begs":13287,"inspector":13288,"N1":13289,"ciency":13290,"68e":13291,"9991":13292,"Done":13293,"reconsider":13294,"shelf":13295,"International":13296,"Poet":13297,"volunteers":13298,"attentive":13299,"Concatenate":13300,"\t":13301,"Hebbian":13302,"quires":13303,"A.19":13304,"Wxi":13305,"837":13306,"LaMP":13307,"books5":13308,"Aston":13309,"MeanBackward0":13310,"III":13311,"intuitive":13312,"awakened":13313,"million":13314,"alent":13315,"underpin":13316,"compiling":13317,"3237":13318,"dereference":13319,"instant":13320,"Positional":13321,"Mechanical":13322,"Scalars":13323,"0.1124":13324,"Would":13325,"Smeulders":13326,"behavior":13327,"exponentiation":13328,"2026":13329,"Catastrophic":13330,"inf":13331,"gathered":13332,"angles":13333,"linspace":13334,"ward":13335,"biases":13336,"overshoots":13337,"ferent":13338,"installing":13339,"170498071":13340,"desired":13341,"Remediation":13342,"Employees":13343,"Node":13344,"boundaries":13345,"Become":13346,"Brunot":13347,"1206":13348,"Hastorun":13349,"Tossing":13350,"1090":13351,"alphabetically":13352,"vectors":13353,"Great":13354,"Execute":13355,"disrupted":13356,"signifies":13357,"729115":13358,"partials":13359,"Benefit":13360,"Sebag":13361,"layers":13362,"Leveraging":13363,"Mahalanobis":13364,"Classifying":13365,"influenced":13366,"titled":13367,"Configurations":13368,"1.2":13369,"models":13370,"Discussions243":13371,"0.002553":13372,"grace":13373,"650":13374,"Discussions107":13375,"surged":13376,"pendence":13377,"𝝐":13378,"D2L":13379,"both":13380,"Obsolete":13381,"q":13382,"tells":13383,"UDP":13384,"tializations":13385,"gold":13386,"Convening":13387,"------------":13388,"plemented":13389,"0.17762434482574463":13390,"MacKay":13391,"12.4":13392,"Warranties":13393,"Shrivastava":13394,"PatchEmbedding":13395,"protocol":13396,"5200":13397,"approach":13398,"brush":13399,"0.0986":13400,"sure":13401,"Knowing":13402,"Hesslow":13403,"attributable":13404,"likelihood":13405,"defeat":13406,"102143":13407,"insur":13408,"Ahuja":13409,"￿":13410,"134":13411,"Op":13412,"Campbell":13413,"217%":13414,"reserve":13415,"scattered":13416,"documentation65":13417,"portability":13418,"Dependency":13419,"watershed":13420,"ﬃ":13421,"Many":13422,"detrimental":13423,"transposition":13424,"Risks":13425,"surround":13426,"NetDynamics":13427,"tice":13428,"translating":13429,"October":13430,"source":13431,"Service":13432,"Chao":13433,"B.8":13434,"R2":13435,"Neubig":13436,"subwindow":13437,"99":13438,"char":13439,"simulators":13440,"destined":13441,"aspects":13442,"Ling":13443,"760":13444,"bq":13445,"transactional":13446,"phones":13447,"Generators":13448,"structure":13449,"155":13450,"11.5":13451,"QCOM":13452,"MSELoss":13453,"Progressive":13454,"impede":13455,"29":13456,"pth":13457,"9316":13458,"Appendix":13459,"drops":13460,"Deviations":13461,"cubic":13462,"sent":13463,"distribution":13464,"ratified":13465,"13.4":13466,"sampled":13467,"upgrade":13468,"particles":13469,"Ng":13470,"9.3":13471,"subtly":13472,"SyntheticRegressionData":13473,"sizes":13474,"Yogi":13475,"1025":13476,"orange":13477,"boxes":13478,"glad":13479,"se":13480,"deadly":13481,"Dwivedi":13482,"nals":13483,"worlds":13484,"monies":13485,"versatile":13486,"webpages":13487,"125":13488,"Choi":13489,"engineering":13490,"agreement":13491,"∪":13492,"11":13493,"x":13494,"Pena":13495,"distributor":13496,"mkdir":13497,"policies":13498,"Northwestern":13499,"GDDR6":13500,"Cour":13501,"intermediate":13502,"accelerated":13503,"drivers":13504,"shadows":13505,"ID":13506,"holes":13507,"81":13508,"CUDA117":13509,"feeding":13510,"predicts":13511,"preventing":13512,"Profit":13513,"systematize":13514,"imposed":13515,"comfort":13516,"etin":13517,"Control":13518,"debugging":13519,"evolution":13520,"Bahri":13521,"sense":13522,"Formal":13523,"Nicolas":13524,"trademarks":13525,"J":13526,"Larger":13527,"picture":13528,"Williams":13529,"avoca":13530,"gpus":13531,"practically":13532,"SageMaker":13533,"Ö":13534,"ics":13535,"8595":13536,"symmetrical":13537,"PCs":13538,"Payout":13539,"Choosing":13540,"terrorist":13541,"Plus":13542,"Aila":13543,"Cao":13544,"Salakhutdinov":13545,"captured":13546,"hedges":13547,"fill":13548,"REST":13549,"WeightDecayScratch":13550,"Dear":13551,"1038":13552,"well":13553,"factual":13554,"Pacific":13555,"indicate":13556,"Store":13557,"Towards":13558,"Aarush":13559,"suggestions":13560,"Fully":13561,"ICL":13562,"3819":13563,"countered":13564,"Derivatives":13565,"46":13566,"Ghosh":13567,"Masius":13568,"responsible":13569,"cell":13570,"announcement":13571,"unrealistic":13572,"397":13573,"insulating":13574,"Chernovenkis":13575,"Tang":13576,"935":13577,"120000":13578,"edgecolor":13579,"rejecting":13580,"294430":13581,"Rearranging":13582,"rotates":13583,"gi":13584,"Lagrange":13585,"nets":13586,"world":13587,"Below":13588,"calls":13589,"Accelerators":13590,"513":13591,"frontend":13592,"extraneous":13593,"Conversation":13594,"Global":13595,"distant":13596,"CAPTION":13597,"Encoded":13598,"Most":13599,"factorization":13600,"hopped":13601,"inelegant":13602,"147":13603,"disparities":13604,"Updating":13605,"assis":13606,"Instead":13607,"Kalchbrenner":13608,"Pearson":13609,"improves":13610,"resultant":13611,"0.9":13612,"824":13613,"Cholesky":13614,"activations":13615,"用于":13616,"spreadsheet":13617,"pi":13618,"optimizes":13619,"326":13620,"particu":13621,"appetite":13622,"Tanida":13623,"Oregon":13624,"parsimonious":13625,"solution":13626,"splits":13627,"omelette":13628,"exclusions":13629,"AAAI":13630,"certainty":13631,"file52":13632,"lifetime":13633,"semester":13634,"less":13635,"observer":13636,"block4":13637,"selectively":13638,"食品":13639,"ranker":13640,"Pascal":13641,"SOFTWARE":13642,"belonged":13643,"Callan":13644,"图":13645,"reside":13646,"channel":13647,"securities":13648,"SoftmaxTransform":13649,"information":13650,"Regression":13651,"capacity":13652,"1357":13653,"026035979388614055":13654,"expressive":13655,"tracking":13656,"ImageSets":13657,"5036":13658,"allreduce":13659,"Rap":13660,"Category":13661,"sun":13662,"ailments":13663,"forms":13664,"month":13665,"earmarked":13666,"0.125":13667,"804":13668,"stale":13669,"Juergen":13670,"quantify":13671,"disciplines":13672,"Torr":13673,"682":13674,"inference":13675,"abstentions":13676,"3332":13677,"Exercises":13678,"7549":13679,"idio":13680,"1.2890":13681,"permute":13682,"Discussions150":13683,"expensed":13684,"CALIFORNIA":13685,"07164":13686,"309%":13687,"Whether":13688,"abstract":13689,"14887":13690,"Izmailov":13691,"approxima":13692,"complex":13693,"franchises":13694,"5234904.66":13695,"Final":13696,"dif":13697,"Detecting":13698,"DPR":13699,"shifting":13700,"capitalize":13701,"connects":13702,"1.9390":13703,"MIT":13704,"emphasis":13705,"Elsevier":13706,"Redefining":13707,"1.52":13708,"473":13709,"283":13710,"rounding":13711,"conveniences":13712,"308":13713,"606":13714,"Completed":13715,"prevalences":13716,"AVX2":13717,"Physics":13718,"min":13719,"859":13720,"recenters":13721,"ICSE":13722,"2305":13723,"777":13724,"Arguably":13725,"builds":13726,"layered":13727,"concatenates":13728,"773":13729,"Require":13730,"Two":13731,"489":13732,"passive":13733,"batches":13734,"4KB":13735,"par":13736,"Expanded":13737,"independencies":13738,"respect":13739,"Compared":13740,"headlines":13741,"sphere":13742,"O":13743,"Cross":13744,"3422":13745,"c":13746,"Started":13747,"settle":13748,"Scholes":13749,"interpretation":13750,"configura":13751,"Speelpenning":13752,"substitution":13753,"var":13754,"presentations":13755,"Weakly":13756,"chipset":13757,"GH200":13758,"torques":13759,"Robertson":13760,"阶段":13761,"Gutenberg":13762,"Chapman":13763,"fund":13764,"diver":13765,"Royal":13766,"niplus1":13767,"innovation":13768,"Improving":13769,"shared":13770,"LakshKD":13771,"Title":13772,"Extract":13773,"cre":13774,"HUB":13775,"Sulla":13776,"ResNeXtBlock":13777,"dedicated":13778,"xlim":13779,"1.9090":13780,"unification":13781,"Sedlmeyer":13782,"ality":13783,"651":13784,"loses":13785,"progressing":13786,"implementaitons":13787,"proved":13788,"Schuurmans":13789,"ii":13790,"slot":13791,"Ensure":13792,"behaves":13793,"staged":13794,"Second":13795,"处理":13796,"uncontested":13797,"256MB":13798,"weeks":13799,"alleviating":13800,"uler":13801,"tighter":13802,"persistent":13803,"Regulations":13804,"inferred":13805,"403":13806,"Inter":13807,"Supercharging":13808,"via":13809,"computations":13810,"distri":13811,"deceptive":13812,"triplets":13813,"adaptable":13814,"situated":13815,"powerful":13816,"074104":13817,"difficult":13818,"analyzed":13819,"inclines":13820,"tapestry":13821,"Did":13822,"Samples":13823,"LSTM":13824,"dw":13825,"Discount":13826,"bn2":13827,"lizing":13828,"带有":13829,"Academies":13830,"Discussions185":13831,"Earth":13832,"imagine":13833,"ering":13834,"u1":13835,"1068":13836,"1084":13837,"lacked":13838,"0022":13839,"man":13840,"abundance":13841,"facilities":13842,"Bio":13843,"fu":13844,"revisit":13845,"maker1":13846,"classify":13847,"contractually":13848,"jupyter":13849,"Follow":13850,"white":13851,"Bansal":13852,"Complex":13853,"Discussions275":13854,"ideas":13855,"1608":13856,"Linguistics":13857,"bonds":13858,"Show":13859,"5e":13860,"tencent":13861,"electronic":13862,"Codegen4libs":13863,"preprocess":13864,"recording":13865,"state":13866,"suggest":13867,"☒":13868,"Instance":13869,"generalists":13870,"statutes":13871,"Mathematicians":13872,"DABIRI":13873,"arguments":13874,"morphology":13875,"sparser":13876,"asks":13877,"determination":13878,"Trigonom":13879,"Handling":13880,"100d":13881,"densely":13882,"proxy":13883,"coin":13884,"Communications":13885,"fying":13886,"Matrix":13887,"Commitment":13888,"1278":13889,"Write":13890,"computable":13891,"legislative":13892,"runners":13893,"reflected":13894,"safeguarding":13895,"Anirudh":13896,"reasoners":13897,"consumer":13898,"preprocessed":13899,"neat":13900,"Ouyang":13901,"offsetting":13902,"helpful":13903,"140":13904,"Knn":13905,"Chat":13906,"doi":13907,"lecun":13908,"shoes":13909,"A.21":13910,"noteworthy":13911,"1223":13912,"115752065.81":13913,"regulariza":13914,"Arx":13915,"NEO":13916,"第二段":13917,"render":13918,"2212":13919,"brands":13920,"defect":13921,"water":13922,"Poggio":13923,"629":13924,"cision":13925,"unknowns":13926,"lighter":13927,"traveling":13928,"CNBC":13929,"TVQA":13930,"restores":13931,"DeSantis":13932,"regarded":13933,"President":13934,"Peace":13935,"Kokhlikyan":13936,"generated":13937,"nS":13938,"compatibility":13939,"快速":13940,"Biology":13941,"899917":13942,"sick":13943,"owning":13944,"repurchased":13945,"Expressed":13946,"reranker":13947,"ambient":13948,"li":13949,"our":13950,"Khamy":13951,"tabular":13952,"mantic":13953,"repurchase":13954,"8.2":13955,"Reading":13956,"codeblock":13957,"1081":13958,"priced":13959,"matching":13960,"profit":13961,"Limitations":13962,"Page":13963,"malfunctions":13964,"REVEAL":13965,"8730":13966,"bookkeeping":13967,"Werness":13968,"FP8":13969,"dir":13970,"Expressway":13971,"hallucination":13972,"logistic":13973,"NER":13974,"Surbhi":13975,"expect":13976,"detected":13977,"Enhancement":13978,"finds":13979,"Sch":13980,"04805":13981,"unsuccessful":13982,"Yao":13983,"12.05":13984,"Design":13985,"brings":13986,"Whz":13987,"Converting":13988,"registry":13989,"Bhunia":13990,"0.15":13991,"authorized":13992,"815":13993,"GMD":13994,"vocabularies":13995,"Noyce":13996,"Elegant":13997,"meetings":13998,"DISCOVERY":13999,"ff7f0e":14000,"642":14001,"Classification":14002,"Visual":14003,"suffix":14004,"Operators":14005,"Remeasurement":14006,"Llama":14007,"ignited":14008,"Slots":14009,"13179":14010,"2826":14011,"null":14012,"contradicting":14013,"Jetson":14014,"4253":14015,"Use":14016,"paste":14017,"Specifying":14018,"prices":14019,"domVerticalFlip":14020,"HybridSequential":14021,"078":14022,"Hint":14023,"units":14024,"desirable":14025,"failing":14026,"652":14027,"AB":14028,"replies":14029,"Scheduler":14030,"properties":14031,"known":14032,"indemnities":14033,"myopically":14034,"old":14035,"Officer":14036,"unaware":14037,"os":14038,"concurrently":14039,"dinner":14040,"Punkt":14041,"multiples":14042,"binding":14043,"records":14044,"Polynomial":14045,"impairment":14046,"Oxley":14047,"Hanazawa":14048,"Caption":14049,"dat":14050,"336":14051,"randomness":14052,"likely":14053,"Outside":14054,"244%":14055,"hypers":14056,"bandit":14057,"KBQA":14058,"903":14059,"ringbus":14060,"7170":14061,"covariance":14062,"equivalent":14063,"refer":14064,"cheaper":14065,"087":14066,"lowing":14067,"7544":14068,"plies":14069,"chemist":14070,"Discussions44":14071,"rewarding":14072,"stays":14073,"unleashing":14074,"overheads":14075,"Papineni":14076,"Transforming":14077,"ArXiv":14078,"873":14079,"KSJM":14080,"reporters":14081,"1012":14082,"proper":14083,"982":14084,"Roller":14085,"faculty":14086,"sive":14087,"959":14088,"petitive":14089,"lan":14090,"37":14091,"2401":14092,"1Whc":14093,"Vectors":14094,"literature":14095,"db":14096,"⌉":14097,"dsweet":14098,"thermore":14099,"specifying":14100,"takeaway":14101,"spacy":14102,"ers":14103,"explo":14104,"Jacobians":14105,"predominantly":14106,"测试阶段":14107,"SIGOPS":14108,"\f":14109,"spirit":14110,"appeal":14111,"1324":14112,"552":14113,"ASIF":14114,"figure":14115,"Navigating":14116,"Daly":14117,"cancelable":14118,"AnyNetC":14119,"B200":14120,"3368":14121,"xAx":14122,"Investment":14123,"608":14124,"Posts":14125,"aggressively":14126,"Business":14127,"Appendix4":14128,"046":14129,"lieu":14130,"performant":14131,"Oxfords":14132,"∉":14133,"getting":14134,"Reduced":14135,"NestMLP":14136,"mediated":14137,"facil":14138,"lovely":14139,"𝑙":14140,"Emergence":14141,"463":14142,"Minerva":14143,"sen":14144,"correct":14145,"Science":14146,"Kimeldorf":14147,"registers":14148,"icant":14149,"court":14150,"accurate":14151,"considerable":14152,"9923":14153,"AdaptiveAvgPool2d":14154,"550000":14155,"Concentration":14156,"Gomez":14157,"benefits":14158,"anonymously":14159,"将":14160,"523":14161,"80":14162,"retained":14163,"058":14164,"Snoek":14165,"%":14166,"centers":14167,"hf":14168,"maximize":14169,"processed":14170,"0.8944":14171,"revise":14172,"Waymo":14173,"Finamore":14174,"filtered":14175,"synthesized":14176,"Army":14177,"Infrequent":14178,"say":14179,"Francesco":14180,"Writing":14181,"T5":14182,"knowl":14183,"approxi":14184,"0cm":14185,"fied":14186,"Inventories":14187,"repository318":14188,"NumRooms":14189,"deploy":14190,"exorbitant":14191,"430":14192,"boggling":14193,"zyhazwraith":14194,"Fixing":14195,"hot":14196,"salvage":14197,"Embedding":14198,"Potential":14199,"link":14200,"Assets":14201,"sends":14202,"variance":14203,"2108":14204,"392":14205,"gpu":14206,"paragraph":14207,"infinity":14208,"me":14209,"Scratch":14210,"Technical":14211,"Leasehold":14212,"Act":14213,"bake":14214,"Importantly":14215,"Seattle":14216,"ascendance":14217,"Hoping":14218,"ODQA":14219,"maintaining":14220,"H800":14221,"398":14222,"bos":14223,"Discussions143":14224,"transistors":14225,"Optimality":14226,"pessimistic":14227,"06541275978088379":14228,"hormone":14229,"3085":14230,"reduces":14231,"Secrets":14232,"CRAG":14233,"collect":14234,"Filing":14235,"939":14236,"Self":14237,"Execution":14238,"Significance":14239,"shareowners":14240,"TextCNN":14241,"Modeling":14242,"Bandwidth":14243,"cys4":14244,"demanding":14245,"Minor":14246,"Gamma":14247,"avoided":14248,"topics":14249,"08477":14250,"Money":14251,"excessively":14252,"Roth":14253,"settings":14254,"encode":14255,"1.0":14256,"Coreware":14257,"Offsets":14258,"Thus":14259,"lead":14260,"assumed":14261,"though":14262,"Launched":14263,"View":14264,"that":14265,"refusal":14266,"H1":14267,"suppress":14268,"mandatory":14269,"Capitalized":14270,"dental":14271,"Skeleton":14272,"Issuable":14273,"Jain":14274,"14.7":14275,"encounters":14276,"R1000":14277,"repair":14278,"monstrous":14279,"Policy":14280,"form":14281,"860":14282,"birth":14283,"Express":14284,"Family":14285,"verify":14286,"笔记本":14287,"zon":14288,"Lepikhin":14289,"Tensor":14290,"imizing":14291,"Covenant":14292,"adhere":14293,"Conversational":14294,"Joji":14295,"decaying":14296,"Treadway":14297,"LAION":14298,"fluency":14299,"bb":14300,"tionship":14301,"Margin":14302,"theory":14303,"egou":14304,"1053":14305,"Discriminator":14306,"0473":14307,"Vencu":14308,"net2":14309,"Courville":14310,"08361":14311,"Medicines":14312,"Janzing":14313,"52":14314,"2020":14315,"inaccessible":14316,"disable":14317,"Through":14318,"277":14319,"Josifovski":14320,"900":14321,"DTD":14322,"proposing":14323,"directors":14324,"Flammarion":14325,"arrivals":14326,"initializa":14327,"article":14328,"bidi":14329,"interests":14330,"ered":14331,"1609":14332,"although":14333,"downloaded":14334,"Mastering":14335,"scoliosis":14336,"retrieved":14337,"communi":14338,"5602":14339,"Purchase":14340,"malizing":14341,"Akiba":14342,"magnitudes":14343,"LLC":14344,"20cm":14345,"Linkbase":14346,"___.":14347,"dawn":14348,"1158":14349,"impractical":14350,"Hewlett":14351,"Notebook":14352,"776":14353,"paddings":14354,"stochasticity":14355,"Leary":14356,"“":14357,"Hon":14358,"redeem":14359,"pillar":14360,"Does":14361,"cludes":14362,"Metzen":14363,"idx3":14364,"Kojima":14365,"Ducharme":14366,"prefer":14367,"Park":14368,"post":14369,"leftwards":14370,"Verbeek":14371,"vice":14372,"worst":14373,"INPUT":14374,"Silverman":14375,"483":14376,"tually":14377,"Hao":14378,"Hyperparameters":14379,"Banach":14380,"COMMISSION":14381,"Living":14382,"article171":14383,"Trappolini":14384,"element":14385,"interchange":14386,"Novikov":14387,"saving":14388,"grasp":14389,"Attend":14390,"showing":14391,"Demonstrate":14392,"Cookbook":14393,"textCNN":14394,"08":14395,"DISTANCES":14396,"259":14397,"Euclidean":14398,"ually":14399,"coaching":14400,"Vietnam":14401,"Golde":14402,"gridworld":14403,"LIBRARIES":14404,"08e":14405,"gray":14406,"Percentages":14407,"Approximators":14408,"selector":14409,"1.4887":14410,"fused":14411,"maximizing":14412,"divert":14413,"theo":14414,"runnable":14415,"accu":14416,"spectro":14417,"Penalties":14418,"Council":14419,"shine":14420,"As":14421,"6.5":14422,"380":14423,"Once":14424,"insurers":14425,"scientists":14426,"block3":14427,"507":14428,"CONCRETE":14429,"Loukas":14430,"platters":14431,"jurisdictions":14432,"services":14433,"names":14434,"instantaneously":14435,"150":14436,"switch":14437,"Bowman":14438,"ria":14439,"fluctuated":14440,"comprises":14441,"599":14442,"degrade":14443,"gru":14444,"743":14445,"respects":14446,"additions":14447,"Liujun":14448,"impossible":14449,"attorney":14450,"Created":14451,"Annuity":14452,"Smola":14453,"Gym":14454,"circular":14455,"unaccounted":14456,"___":14457,"Chaudhuri":14458,"multiplications":14459,"troller":14460,"Medium":14461,"1145":14462,"Anecdotes":14463,"quarters":14464,"warmup":14465,"medical":14466,"Choose":14467,"directionality":14468,"group":14469,"0.250":14470,"platforms":14471,"Boucheron":14472,"Upload":14473,"ditional":14474,"exponential":14475,"Resulting":14476,"end":14477,"loads":14478,"serendipitous":14479,"ai11":14480,"opponents":14481,"demographics":14482,"concise":14483,"Then":14484,"photographs":14485,"vGPU":14486,"opinion":14487,"owes":14488,"9079":14489,"berghe":14490,"heavily":14491,"mind":14492,"colors":14493,"microservices":14494,"Siemens":14495,"Collecting":14496,"RetMol":14497,"concatenations":14498,"than":14499,"webpage":14500,"besides":14501,"Moschella":14502,"rain":14503,"initially":14504,"formulations":14505,"Discussions116":14506,"arbitrarily":14507,"067":14508,"7484":14509,"rerankers":14510,"regularizes":14511,"inconsistent":14512,"Zisserman":14513,"734":14514,"echo":14515,"9905":14516,"Poisson":14517,"continued":14518,"principally":14519,"equation":14520,"submits":14521,"Stakeholder":14522,"Informatica":14523,"Synergizing":14524,"notorious":14525,"Novak":14526,"Increase":14527,"Kapoor":14528,"solu":14529,"208500":14530,"12GB":14531,"018":14532,"FILED":14533,"Exactly":14534,"Narang":14535,"42B":14536,"deliver":14537,"Raw":14538,"architectures":14539,"RTLFixer":14540,"Cache":14541,"identifying":14542,"ious":14543,"communicate":14544,"Discussions224":14545,"304":14546,"Krause":14547,"determinable":14548,"recommended":14549,"watt":14550,"C2":14551,"frontier":14552,"ECBRF":14553,"NLRSE":14554,"doing":14555,"301":14556,"material":14557,"020":14558,"moderate":14559,"tap":14560,"Ghazvininejad":14561,"accountants":14562,"𝑁":14563,"Prepaid":14564,"PuTTY":14565,"fore":14566,"KRESS":14567,"Independence":14568,"674":14569,"coerce":14570,"tests":14571,"brittle":14572,"4109":14573,"Boser":14574,"hope":14575,"Corresponding":14576,"tremendously":14577,"keys":14578,"expanded":14579,"broke":14580,"stream":14581,"Theorem":14582,"Hewitt":14583,"losing":14584,"oftentimes":14585,"Wetzel":14586,"5395":14587,"Club":14588,"986":14589,"ling":14590,"flaws":14591,"Arizona":14592,"DCGAN":14593,"blissfully":14594,"Step":14595,"Mine":14596,"JPEGImages":14597,"349":14598,"390":14599,"observe":14600,"responsive":14601,"revolutionizing":14602,"Ollivier":14603,"speedup":14604,"tain":14605,"Gauss":14606,"DARTS":14607,"waits":14608,"Blog":14609,"or":14610,"3092":14611,"lin":14612,"confidence":14613,"suffices":14614,"reproducible":14615,"953":14616,"explores":14617,"crease":14618,"finish":14619,"Saint":14620,"0909":14621,"Friedrich":14622,"0825770880068151":14623,"eters":14624,"Cryptology":14625,"Jiekui":14626,"GPyTorch":14627,"paywalls":14628,"KNN":14629,"maximally":14630,"070776":14631,"superhuman":14632,"789243":14633,"properly":14634,"Fallacy":14635,"possesses":14636,"rigorous":14637,"decommitment":14638,"1020":14639,"tuning":14640,"CPUs":14641,"tured":14642,"enlarges":14643,"States":14644,"Despite":14645,"Contingencies":14646,"enduring":14647,"generalized":14648,"MLL":14649,"DG":14650,"determinant":14651,"res":14652,"445":14653,"trivial":14654,"tinuous":14655,"126":14656,"Mercedes":14657,"Shelhamer":14658,"0000000000001":14659,"practitioners":14660,"commonalities":14661,"Holdings":14662,"exploding":14663,"Flatten":14664,"Measure":14665,"adtygan":14666,"facts":14667,"完成":14668,"Kang":14669,"fluctuates":14670,"sourced":14671,"linking":14672,"264":14673,"backpropagate":14674,"170284":14675,"consequences":14676,"Percentile":14677,"inefficient":14678,"Tobias":14679,"Ad":14680,"ev":14681,"427":14682,"0577":14683,"refining":14684,"Quality":14685,"bedrock":14686,"branching":14687,"方案":14688,"632":14689,"menial":14690,"6980":14691,"tionships":14692,"xy":14693,"10.3":14694,"neighborhoods":14695,"667":14696,"lottery":14697,"7890":14698,"informs":14699,"mani2106":14700,"3319":14701,"0.194":14702,"Assign":14703,"44%":14704,"Whx":14705,"1973":14706,"jake221":14707,"notes":14708,"explored":14709,"claiming":14710,"maximised":14711,"𝐻":14712,"usefulness":14713,"replaced":14714,"enterprise":14715,"AvgPool2d":14716,"Forrester":14717,"项目":14718,"comma":14719,"Vincent":14720,"Airlines":14721,"Superchips":14722,"TOMCCAP":14723,"dardization":14724,"grossartige":14725,"Performance":14726,"08812857364095393":14727,"exceeding":14728,"surrogate":14729,"assumption":14730,"Base":14731,"alleging":14732,"scan":14733,"physics96":14734,"garter":14735,"Obtain":14736,"violate":14737,"CSSC":14738,"increasing":14739,"276%":14740,"converging":14741,"subsequently":14742,"strategically":14743,"anyway":14744,"reinvestment":14745,"needs":14746,"translates":14747,"diversion":14748,"---":14749,"TF":14750,"RALM":14751,"transforming":14752,"classification":14753,"Della":14754,"Discussions206":14755,"air":14756,"788":14757,"rare":14758,"0033":14759,"5929":14760,"4641":14761,"管理":14762,"subgraph":14763,"marvelous":14764,"Mellon":14765,"simulate":14766,"banks":14767,"Summer":14768,"characterizes":14769,"syntactic":14770,"USSR":14771,"641":14772,"fid":14773,"Frequency":14774,"parametrize":14775,"owners":14776,"Code4UIE":14777,"subspace":14778,"Images":14779,"logged":14780,"bygone":14781,"wM":14782,"3219":14783,"CI":14784,"0.97":14785,"lstm":14786,"varied":14787,"millimeters":14788,"11487":14789,"marketplaces":14790,"business":14791,"1286":14792,"30X":14793,"detector":14794,"Bishop":14795,"weaker":14796,"pollution":14797,"133%":14798,"daughter":14799,"Kolesnikov":14800,"skilled":14801,"intu":14802,"EOS":14803,"abuse":14804,"Chain":14805,"Lorenz":14806,"HyMap":14807,"Concatenation":14808,"received":14809,"compress":14810,"invali":14811,"segmenting":14812,"mizing":14813,"2d":14814,"ray":14815,"1105":14816,"Unallocated":14817,"25088":14818,"Technology":14819,"293":14820,"propagating":14821,"suppliers":14822,"falsifiability":14823,"SAN":14824,"GPyTorch261":14825,"Transformers":14826,"Cremonesi":14827,"television":14828,"exhausted":14829," ":14830,"daily":14831,"Professor":14832,"tokens":14833,"lasting":14834,"𝐾":14835,"Audience":14836,"keepdim":14837,"Tung":14838,"1099":14839,"Heck":14840,"liefs":14841,"almost":14842,"6347":14843,"SKCODER":14844,"362":14845,"Georgetown":14846,"twins":14847,"streamers":14848,"RAPIDS":14849,"inverted":14850,"Jiang":14851,"Asso":14852,"isometry":14853,"now":14854,"+":14855,"Bi":14856,"Cockpit":14857,"successfully":14858,"accesses":14859,"disk":14860,"1809":14861,"composing":14862,"Quite":14863,"tural":14864,"Presidential":14865,"gories":14866,"sequen":14867,"measured":14868,"finer":14869,"Abstractive":14870,"revoke":14871,"Application":14872,"REQUESTS":14873,"403000":14874,"fixing":14875,"848":14876,"Visualization":14877,"stop":14878,"proactively":14879,"licensees":14880,"Evoking":14881,"Intangible":14882,"haria":14883,"DRNN":14884,"uating":14885,"bear":14886,"Prepares":14887,"0.24":14888,"389":14889,"Home":14890,"𝑉":14891,"298":14892,"cuDNN":14893,"groundedness":14894,"Determines":14895,"unique":14896,"Both":14897,"riddled":14898,"typically":14899,"prin":14900,"WeightDecay":14901,"Repeat":14902,"instantiations":14903,"Hron":14904,"individual":14905,"cleared":14906,"tackles":14907,"cursory":14908,"took":14909,"refinance":14910,"visualizations":14911,"Wan":14912,"Debut":14913,"word":14914,"704":14915,"0430":14916,"Balaji":14917,"logarithm":14918,"momentum":14919,"infre":14920,"Alternatively":14921,"0757":14922,"06471":14923,"staple":14924,"discontinue":14925,"u":14926,"ele":14927,"N2":14928,"Inference":14929,"renormalization":14930,"Artetxe":14931,"proxyvote":14932,"pggPL":14933,"Generate":14934,"inserts":14935,"Ownership":14936,"6040":14937,"ascertain":14938,"Map":14939,"VOCSegDataset":14940,"Anatomical":14941,"Biophysics":14942,"emulating":14943,"evaluate":14944,"14.2":14945,"Bag":14946,"13":14947,"Ramasesh":14948,"±":14949,"Rowen":14950,"按计划":14951,"First":14952,"outliers":14953,"went":14954,"2423":14955,"empty":14956,"Engagement":14957,"autopilots":14958,"tioned":14959,"Too":14960,"Nazih":14961,"punkt":14962,"intensify":14963,"mass":14964,"Noises":14965,"进行":14966,"prepaids":14967,"causality":14968,"according":14969,"Addi":14970,"fac":14971,"declare":14972,"sentence":14973,"inverse":14974,"d1":14975,"Recalling":14976,"SARS":14977,"unprecedented":14978,"solving":14979,"Dalal":14980,"Pandit":14981,"putting":14982,"Gen3":14983,"contests":14984,"sqrt":14985,"gression":14986,"motivates":14987,"Bajwa":14988,"AW":14989,"REPORT":14990,"Currently":14991,"outputs":14992,"hybridization":14993,"days":14994,"footage":14995,"mercial":14996,"holm":14997,"orders":14998,"immensely":14999,"Amounts":15000,"roadside":15001,"sands":15002,"TagLM":15003,"SUBMIT":15004,"GENERATIVE":15005,"virtualshareholder":15006,"268684":15007,"rstrip":15008,"887":15009,"forth":15010,"Fisch":15011,"extracted":15012,"cater":15013,"valuable":15014,"160":15015,"149":15016,"constructors":15017,"段落":15018,"prompt":15019,"clamp":15020,"strides":15021,"1508":15022,"Evaluate":15023,"assignments":15024,"RTL":15025,"1114":15026,"assessed":15027,"transmitting":15028,"31st":15029,"Gabriel":15030,"wait":15031,"Hoane":15032,"9026":15033,"46th":15034,"transposed":15035,"Earnings":15036,"contractual":15037,"Third":15038,"visualizes":15039,"targets":15040,"Cajal":15041,"terior":15042,"132":15043,"static":15044,"exdb":15045,"474":15046,"Materials":15047,"matched":15048,"Acknowledgments":15049,"rotations":15050,"Macau":15051,"publish":15052,"Recursive":15053,"Tran":15054,"unimodal":15055,"Automation":15056,"cost":15057,"rli":15058,"042":15059,"Algebraic":15060,"biomedicine":15061,"Qiu":15062,"manufactures":15063,"Kolter":15064,"Aru":15065,"open":15066,"representational":15067,"da":15068,"Going":15069,"logistics":15070,"musicians":15071,"cautious":15072,"DIGITAL":15073,"proposed":15074,"initialed":15075,"labels":15076,"TU102":15077,"deduce":15078,"Pigs":15079,"whether":15080,"fba480ffa8aa7e0febbb511d181409f899b9baa5":15081,"evaluation":15082,"pq1":15083,"nY":15084,"mature":15085,"next":15086,"restricted":15087,"Flow":15088,"pmi":15089,"memorize":15090,"03130":15091,"arc":15092,"weather":15093,"mitigated":15094,"pretrained":15095,"grants":15096,"00003":15097,"Kulits":15098,"ramble":15099,"’":15100,"risky":15101,"multiplicity":15102,"Resource":15103,"lev":15104,"Open":15105,"Fiscal":15106,"ports":15107,"Condition":15108,"Discussions218":15109,"illustration":15110,"change":15111,"Discussions232":15112,"discriminator":15113,"RM":15114,"Xeon":15115,"redirect":15116,"routine":15117,"百分比":15118,"inventions":15119,"teed":15120,"multinoulli":15121,"773950":15122,"translation":15123,"WITH":15124,"decisions":15125,"Tallec":15126,"stated":15127,"CEO":15128,"420":15129,"printed":15130,"adversely":15131,"climate":15132,"boats":15133,"description":15134,"redefines":15135,"violation":15136,"opened":15137,"uti":15138,"ImputBlaster":15139,"Typical":15140,"4096":15141,"Andersen":15142,"Pham":15143,"Empowering":15144,"?":15145,"Galactica":15146,"Space":15147,"Jamieson":15148,"dtypes":15149,"subpopulation":15150,"randomly":15151,"Symbol":15152,"fair":15153,"certifying":15154,"backpropagation":15155,"phenomenon":15156,"income":15157,"coincidence":15158,"opens":15159,"strings":15160,"0170":15161,"Directly":15162,"degenerate":15163,"puzzle":15164,"resolutions":15165,"absurd":15166,"because":15167,"turn":15168,"RichyChen":15169,"297":15170,"Tuner":15171,"5561":15172,"poker":15173,"3064":15174,"OneHotCategorical":15175,"Seo":15176,"Constant":15177,"GIL":15178,"propelled":15179,"paid":15180,"Approval":15181,"对":15182,"INTC":15183,"compromises":15184,"Ganguli":15185,"Integral":15186,"formally":15187,"DLSS":15188,"ciples":15189,"passage":15190,"Acl":15191,"Chip":15192,"argument":15193,"20":15194,"Power":15195,"abrupt":15196,"44th":15197,"haps":15198,"But":15199,"fontweight":15200,"Other":15201,"pothesis":15202,"obfuscate":15203,"pivot":15204,"unsu":15205,"ki":15206,"Segment":15207,"673":15208,"fluctuations":15209,"13474":15210,"QUANTUM":15211,"985":15212,"middle":15213,"𝑧":15214,"dynamics":15215,"At":15216,"behav":15217,"Ray":15218,"mislabeled":15219,"TKDE":15220,"screening":15221,"1032":15222,"newton":15223,"Zhou":15224,"offline":15225,"looping":15226,"caveats":15227,"966":15228,"001636":15229,"Disk":15230,"Feed":15231,"Perhaps":15232,"SigmoidBCELoss":15233,"calibration":15234,"unlike":15235,"Shakeri":15236,"formalized":15237,"doomed":15238,"2.9":15239,"vexing":15240,"hspace":15241,"per":15242,"pipeline":15243,"Sandholm":15244,"surrounded":15245,"butterfly":15246,"telecommunications":15247,"Ecker":15248,"indifferent":15249,"6213":15250,"contraction":15251,"Iwasawa":15252,"chronicles":15253,"developing":15254,"nobody":15255,"overlapped":15256,"inclusive":15257,"605":15258,"spatially":15259,"reason":15260,"0767":15261,"Chris":15262,"grandma":15263,"Pronouncements":15264,"blades":15265,"beta1":15266,"96%":15267,"ys":15268,"scale":15269,"veloping":15270,"⟩":15271,"Factory":15272,"incorrect":15273,"wake":15274,"roles":15275,"parametrization":15276,"grant":15277,"defines":15278,"MyLinear":15279,"counted":15280,"65":15281,"ITER":15282,"efficacy":15283,"tenders":15284,"Historically":15285,"Arste":15286,"1.8788":15287,"196842":15288,"safely":15289,"Programs":15290,"Hallucinator":15291,"MURRE":15292,"biographical":15293,"sponsored":15294,"2015":15295,"Loader":15296,"deals":15297,"Miao":15298,"National":15299,"G4":15300,"Pradel":15301,"sovereign":15302,"Dynamic":15303,"101":15304,"Farley":15305,"multipli":15306,"几个":15307,"Department":15308,"locality":15309,"types":15310,"1986":15311,"1103":15312,"solve":15313,"Ann":15314,"acquisitions":15315,"Slicing":15316,"0.060466":15317,"cui":15318,"CARE":15319,"remotely":15320,"repre":15321,"3818":15322,"Bylaws":15323,"concept":15324,"codypenta":15325,"737":15326,"Maria":15327,"dividend":15328,"math":15329,"intangibles":15330,"Lots":15331,"11000":15332,"asymptotes":15333,"present":15334,"24":15335,"repatriation":15336,"assessing":15337,"MIRAGE":15338,"multaneously":15339,"Robustness":15340,"eta":15341,"SPANN":15342,"Outreach":15343,"achieve":15344,"wb":15345,"summaries":15346,"market":15347,"r":15348,"Ruslan":15349,"flipped":15350,"Patidar":15351,"ongo":15352,"26":15353,"simplification":15354,"sexuality":15355,"updating":15356,"Cuconasu":15357,"l1":15358,"DGX":15359,"deployments":15360,"Named":15361,"tabu":15362,"vital":15363,"framed":15364,"1106":15365,"comparing":15366,"1965":15367,"evidenced":15368,"868":15369,"vis":15370,"imputation":15371,"niglich":15372,"Jamaoui":15373,"Mavromatis":15374,"hist":15375,"exponenti":15376,"Ohishi":15377,"mistakes":15378,"3431":15379,"Classi":15380,"M1":15381,"Hughes":15382,"plurality":15383,"Shared":15384,"idx1":15385,"academics":15386,"Plot":15387,"124":15388,"esis":15389,"3414":15390,"substance":15391,"Direct":15392,"Ko":15393,"borrow":15394,"Un":15395,"concentration":15396,"Neuroscience":15397,"exceedingly":15398,"turned":15399,"10M":15400,"Opportunity":15401,"mainboard":15402,"helping":15403,"intents":15404,"major":15405,"regards":15406,"Discussions106":15407,"partic":15408,"feet":15409,"Sequoia":15410,"cuted":15411,"Pedersen":15412,"build":15413,"Denton":15414,"Typically":15415,"guard":15416,"tran":15417,"means":15418,"imply":15419,"essence":15420,"text":15421,"sfilip":15422,"4322":15423,"eralize":15424,"Center":15425,"Iterative":15426,"2227":15427,"layouts":15428,"hazy":15429,"alize":15430,"different":15431,"closer":15432,"shipment":15433,"basics":15434,"attain":15435,"Philosophical":15436,"SUM":15437,"lawful":15438,"histograms":15439,"foot":15440,"Chihuahuas":15441,"mod":15442,"Majority":15443,"272":15444,"8755":15445,"ALEXANDER":15446,"HEREWITH":15447,"replicating":15448,"peel":15449,"encoun":15450,"Ampere":15451,"514":15452,"clear":15453,"warning":15454,"supervision":15455,"09085":15456,"07812":15457,"831":15458,"03653":15459,"semiannually":15460,"supplanted":15461,"Across":15462,"Riffel":15463,"Logic":15464,"A.10":15465,"Elements":15466,"werner":15467,"550MB":15468,"Emer":15469,"enforces":15470,"SoftmaxRegressionScratch":15471,"individ":15472,"metrics":15473,"corners":15474,"first":15475,"actu":15476,"Support":15477,"pausing":15478,"Levi":15479,"briefly":15480,"1091":15481,"efficiencies":15482,"Technically":15483,"0.7":15484,"UniK":15485,"adpated":15486,"definitive":15487,"07331":15488,"biomedical":15489,"qualitatively":15490,"0.245":15491,"Edit":15492,"Out":15493,"lower":15494,"BERT":15495,"Com":15496,"168":15497,"Hanover":15498,"1094":15499,"Thought":15500,"Thudumu":15501,"FactSet":15502,"multichannel":15503,"instruction":15504,"Discussions223":15505,"disadvantage":15506,"SSSR":15507,"2806":15508,"P":15509,"oscillate":15510,"721":15511,"vesting":15512,"culmination":15513,"详细":15514,"Platform":15515,"enumerating":15516,"intercompany":15517,"proactive":15518,"cumulant":15519,"acceptance":15520,"greater":15521,"cuDF":15522,"pedantic":15523,"introduces":15524,"07682":15525,"0741039859356903":15526,"resent":15527,"pose":15528,"Identifying":15529,"undermines":15530,"constituted":15531,"manipulation":15532,"ourselves":15533,"tconv":15534,"0.786":15535,"nectivity":15536,"swapping":15537,"Set":15538,"detriment":15539,"linreg":15540,"title":15541,"solid":15542,"Datta":15543,"smart":15544,"hexdigest":15545,"Entities":15546,"recommends":15547,"Valgimigli":15548,"undersigned":15549,"seq2tree":15550,"unam":15551,"favorable":15552,"Airflow":15553,"RPG":15554,"website236":15555,"fast":15556,"996":15557,"reveal":15558,"proven":15559,"convertible":15560,"partitioning":15561,"nbextension":15562,"Response":15563,"HNSW":15564,"A.13":15565,"license":15566,"Lucien":15567,"bullet":15568,"Leases":15569,"has":15570,"Multimedia":15571,"94304":15572,"each":15573,"estimator":15574,"6578e":15575,"manifestations":15576,"49346":15577,"hungry":15578,"653":15579,"emphasized":15580,"0.6958":15581,"4S":15582,"tripling":15583,"waves":15584,"Trustworthy":15585,"Tsipras":15586,"musical":15587,"BM25":15588,"456":15589,"retrievers":15590,"time":15591,"relationship":15592,"PoS":15593,"GluonCV":15594,"Threadripper":15595,"arises":15596,"800":15597,"rec":15598,"图片":15599,"appreciation":15600,"Arista":15601,"trying":15602,"Karlen":15603,"807":15604,"structuring":15605,"regress":15606,"upsampling":15607,"culating":15608,"rendered":15609,"Transfer":15610,"Bogin":15611,"CODM":15612,"symmetric":15613,"fork":15614,"Limited":15615,"bling":15616,"35":15617,"Lifu":15618,"1096":15619,"𝚺":15620,"tail":15621,"comprising":15622,"conceive":15623,"trends":15624,"bf":15625,"courses":15626,"questionnaires":15627,"081":15628,"summed":15629,"Rank":15630,"KNNLM":15631,"idation":15632,"repetitions":15633,"Frasconi":15634,"belongs":15635,"halved":15636,"372":15637,"Cognition":15638,"Qui":15639,"TF32":15640,"draft":15641,"Invent":15642,"avoids":15643,"Arab":15644,"Weston":15645,"Q1":15646,"2996":15647,"OPT":15648,"%.":15649,"zhz":15650,"Order":15651,"heat":15652,"comment":15653,"cut":15654,"awakening":15655,"iii":15656,"ffn":15657,"Carnegie":15658,"Sa":15659,"CMU":15660,"low":15661,"otherwise":15662,"formation":15663,"Stories":15664,"faces":15665,"pool2d":15666,"Objects":15667,"Yfcc100m":15668,"overview":15669,"dissemination":15670,"Loop":15671,"Alteration":15672,"559":15673,"cascading":15674,"Event":15675,"Abstract":15676,"Automated":15677,"adaptivity":15678,"xxxii":15679,"sine":15680,"13038":15681,"instruments":15682,"012271314788363914":15683,"documented":15684,"0.5723":15685,"lacking":15686,"electrons":15687,"exemplar":15688,"Upadhyay":15689,"Akabane":15690,"Podoprikhin":15691,"widespread":15692,"breaking":15693,"NotAnotherSystem":15694,"Chowdhery":15695,"Interactions":15696,"iden":15697,"rho":15698,"pinpoint":15699,"Naor":15700,"HyperPa":15701,"rapidly":15702,"volutions":15703,"D4":15704,"goes":15705,"Update":15706,"ds":15707,"reassemble":15708,"Zheng":15709,"resentation":15710,"overloaded":15711,"Demand":15712,"Additionally":15713,"502":15714,"Adjustments":15715,"09%":15716,"reflecting":15717,"444":15718,"Polozov":15719,"capturing":15720,"grew":15721,"depreciation":15722,"mainstays":15723,"Williamson":15724,"qkv":15725,"catdog":15726,"GFN":15727,"For":15728,"integra":15729,"absence":15730,"Intelligence":15731,"Koller":15732,"explains":15733,"diagram":15734,"boy":15735,"vertical":15736,"288%":15737,"900532":15738,"454":15739,"IOPs":15740,"Try":15741,"unzipping":15742,"pro":15743,"cclauss":15744,"plexity":15745,"libgfortran3":15746,"things":15747,"watch":15748,"Details":15749,"flaps":15750,"matplotlib49":15751,"resembled":15752,"talented":15753,"granted":15754,"Daniel":15755,"version":15756,"failure":15757,"tica":15758,"executed":15759,"09699":15760,"defense":15761,"10588":15762,"contributing":15763,"similarly":15764,"Haffner":15765,"controls":15766,"assignment":15767,"ce":15768,"hz":15769,"智能手机":15770,"slow":15771,"75%":15772,"Calc":15773,"indenture":15774,"Fusion":15775,"nuisance":15776,"Packard":15777,"rand":15778,"decoder":15779,"disam":15780,"texts":15781,"highly":15782,"stretches":15783,"anything":15784,"multiprocessors":15785,"blend":15786,"spare":15787,"∝":15788,"namely":15789,"conformance":15790,"Real":15791,"扫描":15792,"proliferation":15793,"korfmann":15794,"Canceled":15795,"pretraining":15796,"10063":15797,"tigation":15798,"ac":15799,"meanwhile":15800,"les":15801,"showed":15802,"Retrieval":15803,"Beach":15804,"Click":15805,"Issuance":15806,"most":15807,"1.1025":15808,"grad":15809,"Signal":15810,"0.224":15811,"selected":15812,"Reportable":15813,"Lubin":15814,"boat":15815,"originates":15816,"extractor":15817,"roads":15818,"Applicable":15819,"fetch":15820,"dramatic":15821,"Probab":15822,"induce":15823,"pz":15824,"converting":15825,"obstacle":15826,"AT":15827,"gyu":15828,"lawfully":15829,"𝜅":15830,"Farhadi":15831,"subplots":15832,"UR":15833,"Framewise":15834,"平板":15835,"Ranzato":15836,"Operation":15837,"feasibility":15838,"vector":15839,"IBM":15840,"tracks":15841,"receptive":15842,"Installing":15843,"mand":15844,"stamp":15845,"institutions":15846,"captures":15847,"media":15848,"han":15849,"Hopper":15850,"unary":15851,"resignation":15852,"Multihop":15853,"CREA":15854,"Discussions118":15855,"loaders":15856,"mixed":15857,"picks":15858,"wings":15859,"o":15860,"07892":15861,"Warehousing":15862,"lect":15863,"stimuli":15864,"Bornea":15865,"Outline":15866,"load":15867,"optimality":15868,"utiliz":15869,"Taxes":15870,"developers":15871,"537":15872,"Please":15873,"argue":15874,"mea":15875,"behaviour":15876,"472":15877,"Computers":15878,"Discussions207":15879,"embed":15880,"⌈":15881,"AMIs":15882,"93":15883,"688":15884,"106730":15885,"interactivity":15886,"Tench":15887,"raw":15888,"2202":15889,"Discussions112":15890,"GENREAD":15891,"dent":15892,"partitioned":15893,"Rusu":15894,"rewards":15895,"Multiple":15896,"394":15897,"supportive":15898,"3024":15899,"CoV":15900,"LIPTON":15901,"Patodia":15902,"1226":15903,"their":15904,"wise":15905,"Bai":15906,"0.5":15907,"10":15908,"Link":15909,"sponds":15910,"C5":15911,"Guu":15912,"resid":15913,"pervised":15914,"prematurely":15915,"Preliminaries":15916,"14.10":15917,"Poker":15918,"biguation":15919,"01798":15920,"whitespace":15921,"Amgen":15922,"thirds":15923,"Gan":15924,"Greedy":15925,"xmax":15926,"SYSTEMS":15927,"reply":15928,"notationally":15929,"decipher":15930,"supervisors":15931,"Pavlick":15932,"Mechanism":15933,"discussed":15934,"Association":15935,"3140976097":15936,"Feng":15937,"UninitializedParameter":15938,"treat":15939,"investments":15940,"Sampling":15941,"Discussions215":15942,"gpu1":15943,"mini":15944,"disregarding":15945,"phi":15946,"pandemics":15947,"Armed":15948,"treats":15949,"clawback":15950,"senses":15951,"Chu":15952,"Broadcom":15953,"hey":15954,"Preliminary":15955,"Evuru":15956,"WiFi":15957,"Lussier":15958,"8th":15959,"communicated":15960,"353":15961,"emergence":15962,"trailing":15963,"212":15964,"four":15965,"alleged":15966,"Hebb":15967,"ena":15968,"json":15969,"retrieving":15970,"Hedging":15971,"417":15972,"Conventions":15973,"Srivastava":15974,"demoted":15975,"dx":15976,"2.0":15977,"Rejection":15978,"Proxy":15979,"eliminated":15980,"Statement":15981,"conditioning":15982,"LD":15983,"UK":15984,"Cuts":15985,"occurring":15986,"position":15987,"compare":15988,"compromised":15989,"radar":15990,"spanning":15991,"detec":15992,"5938":15993,"multiplex":15994,"creators":15995,"pursued":15996,"Operational":15997,"Answering":15998,"Discussions290":15999,"int32":16000,"respected":16001,"robot":16002,"corrective":16003,"03181":16004,"ERATTA":16005,"limelight":16006,"1882":16007,"Arrangements":16008,"®":16009,"und":16010,"Manhattan":16011,"perplexing":16012,"SATA":16013,"产品名称":16014,"Assume":16015,"YouTube":16016,"Present":16017,"或":16018,"ls":16019,"CenterCrop":16020,"black":16021,"Identifies":16022,"Discussions301":16023,"connectors":16024,"debates":16025,"39":16026,"|":16027,"procuring":16028,"Nonethe":16029,"2805":16030,"Models":16031,"DC":16032,"3rd":16033,"double":16034,"needed":16035,"markedly":16036,"Miniconda3":16037,"Wiesel":16038,"MSE":16039,"glean":16040,"odically":16041,"fusion":16042,"herein":16043,"exclusion":16044,"001":16045,"table":16046,"permanent":16047,"ethernet":16048,"tapping":16049,"lame":16050,"misuse":16051,"cybersecurity":16052,"extent":16053,"reopening":16054,"features":16055,"Reliable":16056,"Discussions266":16057,"exchanges":16058,"Preferred":16059,"describing":16060,"Squared":16061,"abstractions":16062,"4660":16063,"allowed":16064,"believe":16065,"Scales":16066,"03635":16067,"2.6190":16068,"peripherals":16069,"bined":16070,"2307":16071,"4325":16072,"04":16073,"imputed":16074,"statistician":16075,"apocalypse":16076,"Chase":16077,"09844872561810249":16078,"malevolent":16079,"𝑤":16080,"essentially":16081,"upsample":16082,"SK":16083,"interpolation":16084,"Gbit":16085,"gaming":16086,"introduction":16087,"Bay":16088,"play":16089,"disclosed":16090,"Dec":16091,"Tenable":16092,"delta":16093,"6%":16094,"LSI":16095,"digitalize":16096,"257636":16097,"Droppo":16098,"conjecture":16099,"62":16100,"conflicting":16101,"Apart":16102,"ducts":16103,"Significant":16104,"1505":16105,"hyperkernels":16106,"l":16107,"Changing":16108,"Accountants":16109,"comparative":16110,"85%":16111,"Data":16112,"Scalar":16113,"querys":16114,"lowrank":16115,"Supervised":16116,"Horovod210":16117,"equi":16118,"diate":16119,"983":16120,"FFN":16121,"exercise":16122,"backgrounds":16123,"handily":16124,"regions":16125,"ﬀ":16126,"substitute":16127,"automatically192":16128,"Kaplan":16129,"unearned":16130,"替代":16131,"allocating":16132,"imported":16133,"Gunrock198":16134,"repositories":16135,"confronted":16136,"tab":16137,"Theoretical":16138,"effortlessly":16139,"Enter":16140,"haves":16141,"𝑢":16142,"ods":16143,"Saharia":16144,"Retention":16145,"demon":16146,"314":16147,"only":16148,"whose":16149,"truck":16150,"passed":16151,"reducing":16152,"6641":16153,"DeepSpeed":16154,"drift":16155,"et":16156,"Murat":16157,"Dataset":16158,"CorrCholeskyTransform":16159,"4648":16160,"detailing":16161,"6411":16162,"zoom":16163,"DEMAND":16164,"endre":16165,"Concerns":16166,"0.2":16167,"sauce":16168,"1088":16169,"deny":16170,"Deep":16171,"remain":16172,"quite":16173,"MIS":16174,"effec":16175,"Distributions":16176,"suboptimal":16177,"279":16178,"Shortcuts":16179,"Put":16180,"slices":16181,"nonzero":16182,"4e443f8a2eca6b1dac8a6c57641b67dd40621a49":16183,"connect":16184,"viewed":16185,"⇒":16186,"arno":16187,"1063":16188,"moreover":16189,"Measures":16190,"EditSum":16191,"Discussions134":16192,"A.5":16193,"Omeiza":16194,"encounter":16195,"14%":16196,"026":16197,"scaling":16198,"computes":16199,"Generalisable":16200,"7044":16201,"Interna":16202,"Pai":16203,"568":16204,"Additive":16205,"200W":16206,"Zisser":16207,"778":16208,"Pietra":16209,"Discussions211":16210,"execute":16211,"Polosukhin":16212,"BayesianOptimization":16213,"disabling":16214,"Zamani":16215,"sigmas":16216,"376":16217,"angle":16218,"Forcing":16219,"Some":16220,"Ever":16221,"DOWN":16222,"309":16223,"scheduled":16224,"Full":16225,"11049":16226,"prepay":16227,"issued":16228,"GHG":16229,"work":16230,"multitude":16231,"Zero":16232,"descriptors":16233,"affects":16234,"blurring":16235,"AMD":16236,"Providence":16237,"designees":16238,"drains":16239,"existence":16240,"vectorization":16241,"scalars":16242,"touches":16243,"WordPiece":16244,"8086":16245,"Substitute":16246,"stakeholders":16247,"Doso":16248,"invited":16249,"interrelations":16250,"recursively":16251,"Neighbor":16252,"capabilities":16253,"Terminal":16254,"bz":16255,"AVX":16256,"1506":16257,"HomunculusK":16258,"1f77b4":16259,"hand":16260,"errors":16261,"tip":16262,"profits":16263,"365970":16264,"1419":16265,"Steps":16266,"prohibits":16267,"zipping":16268,"2208":16269,"relevant":16270,"Rakib":16271,"180":16272,"place":16273,"resnet":16274,"En":16275,"Risk":16276,"Asian":16277,"architec":16278,"thumb":16279,"US":16280,"ati":16281,"Newsl":16282,"dispensable":16283,"INDUSTRIAL":16284,"577":16285,"Hwang":16286,"2468891379769198":16287,"Hennessy":16288,"prescription":16289,"tarfile":16290,"Gururangan":16291,"identify":16292,"8414":16293,"av":16294,"1412":16295,"hears":16296,"listed":16297,"tense":16298,"1.974459321485":16299,"diseases":16300,"Moritz":16301,"formula":16302,"intuit":16303,"oversaw":16304,"dropoutmlp":16305,"bills":16306,"editor":16307,"ConnectX":16308,"unpredictable":16309,"sharex":16310,"experiences":16311,"tune":16312,"Sorting":16313,"ISO":16314,"measure":16315,"Major":16316," ":16317,"Friedman":16318,"boxes2":16319,"Prior":16320,"vicinity":16321,"addressing":16322,"6756":16323,"Asynchrony":16324,"Dean":16325,"310":16326,"clicks":16327,"mitigating":16328,"actuator":16329,"1020.0":16330,"SalePrice":16331,"Gazpio":16332,"acquisition":16333,"Norick":16334,"Training":16335,"vergence":16336,"zxydi1992":16337,"Focuses":16338,"Provost":16339,"Grid":16340,"quantity":16341,"Babaei":16342,"4.0":16343,"nomials":16344,"1058":16345,"245":16346,"effi":16347,"win":16348,"Dagar":16349,"Uncertainty":16350,"\u0000":16351,"Gopalakrishna":16352,"Block":16353,"bbox":16354,"06279":16355,"399520":16356,"doesn":16357,"CVF":16358,"initializing":16359,"sector":16360,"quantization":16361,"optimum":16362,"advantage":16363,"深圳":16364,"SIGPLAN":16365,"inequalities":16366,"aimed":16367,"clouds":16368,"1982":16369,"Canny":16370,"Editing":16371,"conform":16372,"probit":16373,"ysraell":16374,"tool":16375,"meanings":16376,"nominees":16377,"reversible":16378,"app":16379,"082577":16380,"reconcile":16381,"standard":16382,"night":16383,"tectures":16384,"重要":16385,"AlexNet":16386,"expansive":16387,"aca":16388,"ally":16389,"Mitro":16390,"products":16391,"1s":16392,"plete":16393,"Leaky":16394,"RegNet":16395,"cropped":16396,"tered":16397,"quantities":16398,"AbsTransform":16399,"contract":16400,"quan":16401,"Breitkopf":16402,"Purchases":16403,"Warren":16404,"subspaces":16405,"&":16406,"fea":16407,"cope":16408,"3e":16409,"cycle":16410,"cc":16411,"687":16412,"Maui":16413,"std":16414,"perturbation":16415,"Discussions156":16416,"54%":16417,"8115":16418,"merical":16419,"116":16420,"doctorate":16421,"Credible":16422,"fin":16423,"reinvested":16424,"tossing":16425,"Here":16426,"llm":16427,"biggest":16428,"5840":16429,"05250":16430,"Genius":16431,"external":16432,"formance":16433,"last":16434,"2758":16435,"spline":16436,"revisited":16437,"Fakoor":16438,"iluu":16439,"Sensing":16440,"Discussions119":16441,"beat":16442,"Discussions248":16443,"trains":16444,"worked":16445,"K":16446,"11782":16447,"restate":16448,"Parti":16449,"Fluid":16450,"979":16451,"capture":16452,"noised":16453,"unwanted":16454,"category":16455,"closely":16456,"Launay":16457,"Adobe":16458,"ratify":16459,"Devices":16460,"Sano":16461,"BASE":16462,"driven":16463,"alter":16464,"cise":16465,"Lori":16466,"我们":16467,"14.11":16468,"fans":16469,"emit":16470,"963":16471,"Sooner":16472,"Moro":16473,"succes":16474,"UNK":16475,"safeguard":16476,"huge":16477,"644":16478,"click":16479,"sixty":16480,"38":16481,"attention1":16482,"versation":16483,"0.242":16484,"Negative":16485,"报告":16486,"AnyNet":16487,"Repofusion":16488,"revisions":16489,"resulted":16490,"Bollacker":16491,"726":16492,"†":16493,"standing":16494,"cessing":16495,"Novikoff":16496,"trainable":16497,"600":16498,"among":16499,"Rudin":16500,"American":16501,"downs":16502,"assertion":16503,"importance":16504,"Robotics":16505,"unduly":16506,"takeover":16507,"saturation":16508,"posits":16509,"development":16510,"Guggenheim":16511,"integrated":16512,"Reduction":16513,"transportation":16514,"IOS":16515,"Weak":16516,"564":16517,"levels":16518,"stages":16519,"Langevin":16520,"annotators":16521,"All":16522,"tlesnakes":16523,"requisite":16524,"comp":16525,"comparatively":16526,"Benchmark":16527,"Modify":16528,"ij":16529,"Udapdr":16530,"Reaches":16531,"ROBERTSON":16532,"820337":16533,"254":16534,"stands":16535,"diet":16536,"Electrical":16537,"solves":16538,"Utilities":16539,"Snappy":16540,"slowing":16541,"neering":16542,"Discussions151":16543,"1.45":16544,"nominee":16545,"letting":16546,"existing":16547,"Broadcast":16548,"0253":16549,"Sun":16550,"closets":16551,"66%":16552,"Dabiri":16553,"01722":16554,"accordance":16555,"Validation":16556,"publications":16557,"obligate":16558,"Vice":16559,"200MB":16560,"particle":16561,"pix":16562,"05150":16563,"ARES":16564,"367":16565,"Examples":16566,"Isola":16567,"Discussions306":16568,"Lou":16569,"Effectiveness":16570,"MY":16571,"thesis":16572,"2310":16573,"Repository50":16574,"DropoutMLP":16575,"arrow":16576,"gone":16577,"reinstall":16578,"017899":16579,"teach":16580,"033362897489792855":16581,"freqs":16582,"personal":16583,"Poole":16584,"1603":16585,"maxi":16586,"205652":16587,"Kg":16588,"家具":16589,"mycologist":16590,"may":16591,"Pretrain":16592,"Agarwal":16593,"0GB":16594,"1000000000":16595,"contiguous":16596,"unrepresented":16597,"Complexity":16598,"scenery":16599,"Careil":16600,"Countries":16601,"100":16602,"numbers":16603,"deter":16604,"extractall":16605,"Liang":16606,"counting":16607,"classi":16608,"AddmmBackward0":16609,"collaboration":16610,"sloppy":16611,"converge":16612,"000":16613,"State":16614,"Presiding":16615,"commonly":16616,"paulaurel":16617,"science":16618,"Implementing":16619,"unshared":16620,"virus":16621,"shot":16622,"surface":16623,"Token":16624,"spectral":16625,"1281":16626,"Liquidity":16627,"Conveniently":16628,"terrible":16629,"transit":16630,"plates":16631,"rightly":16632,"aggre":16633,"Recently":16634,"lowers":16635,"exerted":16636,"Semerci":16637,"clever":16638,"Alma":16639,"utility":16640,"Introduction":16641,"nll":16642,"Alan":16643,"matern":16644,"enforce":16645,"Backpropagation":16646,"bites":16647,"@":16648,"intake":16649,"Huber":16650,"Markovian":16651,"8037":16652,"payments":16653,"COG":16654,"sale":16655,"038":16656,"synchronized":16657,"role":16658,"Purchased":16659,"NotImplementedError":16660,"individuals":16661,"achine":16662,"Readsum":16663,"Baid":16664,"chooses":16665,"Ried":16666,"wrote":16667,"expecta":16668,"Speed":16669,"upsampled":16670,"displaying":16671,"Phuc":16672,"ankle":16673,"comprehen":16674,"trillions":16675,"DRUG":16676,"maximum":16677,"540":16678,"automating":16679,"light":16680,"prefix":16681,"488":16682,"concerning":16683,"holdings":16684,"abundant":16685,"alxnorden":16686,"573":16687,"studied":16688,"decompression":16689,"Projections":16690,"trillion":16691,"6851":16692,"Discussions260":16693,"synthe":16694,"825":16695,"alphas":16696,"distracted":16697,"820":16698,"Impatient":16699,"terize":16700,"Lu":16701,"clueless":16702,"936":16703,"∅":16704,"9580":16705,"raytune":16706,"Vest":16707,"Wistuba":16708,"7072":16709,"dissenting":16710,"Though":16711,"hinder":16712,"Swope":16713,"Feldman":16714,"moving":16715,"It":16716,"accrues":16717,"Multibox":16718,"318":16719,"virtuoso":16720,"incidents":16721,"entists":16722,"633":16723,"surprising":16724,"visu":16725,"ski":16726,"knowing":16727,"ll":16728,"Votes":16729,"should":16730,"Davide":16731,"Regularization":16732,"advisable":16733,"1080":16734,"Optuna":16735,"breach":16736,"resurgence":16737,"NIMs":16738,"classes":16739,"Lv":16740,"ani":16741,"clean":16742,"visualize":16743,"ingre":16744,"ating":16745,"Discussions103":16746,"¨":16747,"thermodynamic":16748,"entertainment":16749,"4110":16750,"branding":16751,"funk":16752,"tall":16753,"SIGGRAPH":16754,"Example":16755,"Teach":16756,"JMLR":16757,"appointment":16758,"wells":16759,"HalfNormal":16760,"experimentally":16761,"dog":16762,"Geng":16763,"thoroughness":16764,"PSUs":16765,"troubling":16766,"569":16767,"ea":16768,"929":16769,"eSports":16770,"bounded":16771,"Sharing":16772,"ticket":16773,"accidental":16774,"栏":16775,"Hasson":16776,"yes":16777,"FORM":16778,"hq":16779,"strictest":16780,"contin":16781,"RepoCoder":16782,"offering":16783,"2019":16784,"simulates":16785,"rigtorp":16786,"meanvec":16787,"refinement":16788,"another":16789,"COLETTE":16790,"ASTON":16791,"concatenated":16792,"Donhauser":16793,"Short":16794,"SNLIDataset":16795,"unravel":16796,"elite":16797,"subroutines":16798,"website235":16799,"Keen":16800,"Bessel":16801,"recovered":16802,"send":16803,"matter":16804,"factors":16805,"elementary":16806,"⌊":16807,"Parvez":16808,"backpropaga":16809,"Transition":16810,"566":16811,"practicing":16812,"Material":16813,"Iterating":16814,"=":16815,"Iscen":16816,"Jason":16817,"bones":16818,"imitating":16819,"unpack":16820,"404":16821,"elegant":16822,"minute":16823,"Conducting":16824,"Rockafellar":16825,"therapeutics":16826,"ratably":16827,"2705":16828,"groups":16829,"karolszk":16830,"architect":16831,"fiction":16832,"0679":16833,"Discussions213":16834,"Intellectual":16835,"nested":16836,"0.011485":16837,"Practices":16838,"16000":16839,"Ital":16840,"Riedl":16841,"Mining":16842,"shorthand":16843,"third":16844,"airplane":16845,"grabbing":16846,"References":16847,"1822":16848,"participates":16849,"trainLabels":16850,"Automatica":16851,"process":16852,"637":16853,"773617148399353":16854,"equivalents":16855,"323":16856,"Equipment":16857,"creation":16858,"mindful":16859,"superlative":16860,"discretize":16861,"vest":16862,"architects":16863,"website8":16864,"physician":16865,"Malvern":16866,"sible":16867,"outperforming":16868,"intercepts":16869,"facilitating":16870,"7th":16871,"delete":16872,"recurring":16873,"Monarch":16874,"Thieme":16875,"Anatomy":16876,"486":16877,"kernel":16878,"Optane":16879,"Rao":16880,"Fechner":16881,"Position":16882,"denoising":16883,"Under":16884,"2009":16885,"padding":16886,"scalar":16887,"H2":16888,"--------":16889,"sentient":16890,"BYD":16891,"UNA":16892,"complementary":16893,"Your":16894,"Discussions54":16895,"ourself":16896,"possi":16897,"806":16898,"during":16899,"343":16900,"3177549":16901,"visits":16902,":":16903,"目标":16904,"Discussions184":16905,"obscure":16906,"mutual":16907,"Region":16908,"Terriers":16909,"137080":16910,"unlocked":16911,"summing":16912,"Farri":16913,"netyster":16914,"treated":16915,"16543":16916,"somewhere":16917,"2004":16918,"quantize":16919,"judgments":16920,"limitations":16921,"illustrated":16922,"Predictive":16923,"096":16924,"Hongshen":16925,"SSRN":16926,"upcoming":16927,"Wide":16928,"visibility":16929,"1b2":16930,"Subsampling":16931,"695":16932,"blame":16933,"resumed":16934,"6907":16935,"B.10":16936,"1971":16937,"10524":16938,"Pathak":16939,"annually":16940,"diagram61":16941,"biopharmaceutical":16942,"Fujimoto":16943,"inventory":16944,"plugin":16945,"Narasimhan":16946,"Gad":16947,"feeling":16948,"target":16949,"ups":16950,"Ali":16951,"wave":16952,"bed":16953,"Hills":16954,"evangelize":16955,"implemen":16956,"retention":16957,"spending":16958,"admission":16959,"TV":16960,"Waterman":16961,"Affiliated":16962,"Dump":16963,"debugger":16964,"Social":16965,"inventories":16966,"building":16967,"4399":16968,"latent":16969,"1235":16970,"Broader":16971,"10001":16972,"Kumaraswamy":16973,"9321":16974,"latter":16975,"gotten":16976,"proxyholders":16977,"Avila":16978,"mtn":16979,"292":16980,"gadgets":16981,"lest":16982,"2434":16983,"benefited":16984,"Demographic":16985,"Observe":16986,"Discussions221":16987,"used":16988,"foundation":16989,"TNNLS":16990,"A.29":16991,"Employer":16992,"NVMe":16993,"Koizumi":16994,"Discussions113":16995,"predecessor":16996,"7822":16997,"359":16998,"75":16999,"4931":17000,"A.15":17001,"TimeMachine":17002,"Wentao":17003,"wildly":17004,"Accordingly":17005,"\u0012":17006,"multiplication":17007,"Trading":17008,"tremendous":17009,"accommodates":17010,"technological":17011,"eryone":17012,"7%":17013,"circumstances":17014,"Dendrite":17015,"smoothed":17016,"evolve":17017,"watson":17018,"notify":17019,"compelling":17020,"preceding":17021,"participated":17022,"Starcraft":17023,"relied":17024,"ambiguous":17025,"timing":17026,"wonder":17027,"Consider":17028,"Agnostic":17029,"sises":17030,"944":17031,"Resources":17032,"So":17033,"multiplicative":17034,"Clear":17035,"82":17036,"Monga":17037,"heightened":17038,"sorting":17039,"concat":17040,"written":17041,"Optimizing":17042,"220":17043,"Concept":17044,"BNLeNet":17045,"115584":17046,"GlobalP":17047,"Hall":17048,"Denmark":17049,"EFSUM":17050,"confer":17051,"muddier":17052,"58%":17053,"Hoa":17054,"correctness":17055,"Discussions279":17056,"unbelievable":17057,"Mangram":17058,"aid":17059,"1062":17060,"CNN":17061,"Josh":17062,"complexity":17063,"Passos":17064,"tailed":17065,"0.009948714636266232":17066,"sigmoidal":17067,"0668":17068,"depend":17069,"g":17070,"origin":17071,"indebtedness":17072,"theories":17073,"solicits":17074,"3538":17075,"Branch":17076,"18GB":17077,"𝑔":17078,"acts":17079,"Commonly":17080,"Treebank":17081,"1027":17082,"Belarus":17083,"Finally":17084,"combina":17085,"map":17086,"8584":17087,"registering":17088,"disclaims":17089,"Springer":17090,"2023":17091,"datum":17092,"Nothing":17093,"false":17094,"152":17095,"ballroom":17096,"Multiscale":17097,"hor":17098,"reasonably":17099,"approved":17100,"Chopra":17101,"Ended":17102,"ballpark":17103,"42069":17104,"Bashexplainer":17105,"maps":17106,"2v":17107,"0.7071":17108,"algorithms":17109,"mizations":17110,"Parmar":17111,"772":17112,"34th":17113,"":17114,"6750":17115,"uct":17116,"arrangement":17117,"Miniconda13":17118,"10000":17119,"humanoid":17120,"banking":17121,"Scientists":17122,"0545":17123,"Narayanamurthy":17124,"interpolate":17125,"Chiu":17126,"tinkering":17127,"notice":17128,"declarative":17129,"belong":17130,"RISK":17131,"billions":17132,"Launch":17133,"ethnicities":17134,"new":17135,"GPUs":17136,"StarCraft":17137,"Gardent":17138,"Llmlingua":17139,"335":17140,"accuracy":17141,"Teaching":17142,"project":17143,"REFERENCE":17144,"morally":17145,"rated":17146,"Model":17147,"pmuens":17148,"normalize":17149,"testament":17150,"Alcoa":17151,"epsilon":17152,"Scheduling":17153,"1v":17154,"流程图":17155,"Auto":17156,"plementations":17157,"kilometers":17158,"deductibles":17159,"Competition":17160,"fitting":17161,"Decomposing":17162,"MNIST":17163,"7.2":17164,"Bordes":17165,"competent":17166,"radius":17167,"ShiftNet":17168,"coder":17169,"axhline":17170,"colleagues":17171,"dying":17172,"subset":17173,"randint":17174,"597":17175,"desktops":17176,"completely":17177,"1970":17178,"simple":17179,"practical":17180,"easily":17181,"标题":17182,"force":17183,"Nos":17184,"12.6":17185,"729758":17186,"carryforwards":17187,"regression":17188,"GbE":17189,"filled":17190,"bylaws":17191,"2005":17192,"eliminate":17193,"April":17194,"occurrences":17195,"multiplicities":17196,"plications":17197,"contributed":17198,"contribute":17199,"Surprisingly":17200,"arena":17201,"2448":17202,"Discussions123":17203,"Caches":17204,"recipient":17205,"linearly":17206,"KGQA":17207,"Consolidation":17208,"quadraticity":17209,"covenants":17210,"enforced":17211,"dethroned":17212,"monotonicity":17213,"George":17214,"𝜂":17215,"Rabiner":17216,"multimodal":17217,"disagree":17218,"appropriate":17219,"VLSI":17220,"093798":17221,"Matthew":17222,"Unknown":17223,"2010189":17224,"Neurips":17225,"765":17226,"Handbook":17227,"Discussions43":17228,"Focal":17229,"insight":17230,"Provided":17231,"24900745354561854":17232,"informal":17233,"76e5be1548fd8222e5074cf0faae75edff8cf93f":17234,"Shoeb":17235,"reusable":17236,"NegativeLogLikelihood":17237,"7845737934112549":17238,"solute":17239,"OVERSIGHT":17240,"loaded":17241,"Relatively":17242,"aterzis":17243,"Bahdanau":17244,"candidate":17245,"LeanDojo":17246,"burgled":17247,"depths":17248,"533380":17249,"6482":17250,"jurisdiction":17251,"embs":17252,"063172":17253,"orates":17254,"currencies":17255,"assigns":17256,"Library157":17257,"dialogue":17258,"37th":17259,"city":17260,"fellow":17261,"infrequent":17262,"Tokens":17263,"members":17264,"multivariate":17265,"factorized":17266,"stay":17267,"disrupt":17268,"Strangely":17269,"Rewrite":17270,"0.25":17271,"BEING":17272,"statistic":17273,"leveraged":17274,"chatbots":17275,"delicious":17276,"Gaus":17277,"biometrics":17278,"225517":17279,"poral":17280,"579":17281,"efficiency":17282,"heuristics":17283,"somebody":17284,"strongly":17285,"anti":17286,"datapoints":17287,"A.1":17288,"perturbing":17289,"enforcement":17290,"purely":17291,"widely":17292,"Posed":17293,"follows":17294,"Popular":17295,"region":17296,"Local":17297,"Ramachandran":17298,"𝜉":17299,"configured":17300,"piouw":17301,"regularizers":17302,"ResNets":17303,"Preussische":17304,"055":17305,"upscaled":17306,"referring":17307,"distance":17308,"grapples":17309,"prepayment":17310,"society":17311,"floating":17312,"discusses":17313,"~":17314,"tensor":17315,"decoding":17316,"corrupted":17317,"causal":17318,"bypass":17319,"assert":17320,"indebted":17321,"Night":17322,"Zhai":17323,"port":17324,"globally":17325,"shard":17326,"27":17327,"13259":17328,"Pappas":17329,"linkedin":17330,"Shikano":17331,"HalfCauchy":17332,"AAL":17333,"upper":17334,"default":17335,"dictates":17336,"sneakers":17337,"Amplify":17338,"partite":17339,"Jupyter":17340,"instead":17341,"website16":17342,"cabularies":17343,"medium":17344,"movie":17345,"gems":17346,"rights":17347,"collectively":17348,"reimagined":17349,"thresholding":17350,"Exemplary":17351,"appeared":17352,"conceivably":17353,"14451533555984497":17354,"Rates":17355,"364":17356,"BioASQ":17357,"Request":17358,"feature":17359,"ECC":17360,"163":17361,"meant":17362,"advisers":17363,"ads":17364,"epicenter":17365,"op":17366,"complemented":17367,"trainings":17368,"Sri":17369,"Sen":17370,"lines":17371,"525":17372,"SY":17373,"simplistic":17374,"Illinois":17375,"028463":17376,"Oktay":17377,"GRU":17378,"27e":17379,"implied":17380,"stronger":17381,"decline":17382,"New":17383,"brought":17384,"实现":17385,"parabola":17386,"perspectives":17387,"Amari":17388,"curve":17389,"FISCAL":17390,"Koyama":17391,"harms":17392,"grey":17393,"23985":17394,"9cm":17395,"Discussions272":17396,"299":17397,"4%":17398,"laysum":17399,"b":17400,"329":17401,"Rangan":17402,"bleak":17403,"Covariances":17404,"subgraphs":17405,"00341":17406,"params":17407,"tantalum":17408,"Sentiment":17409,"71e":17410,"GloVe":17411,"Artisan":17412,"Understudy":17413,"overstate":17414,"Aeronautics":17415,"1992":17416,"14.5":17417,"Ratio":17418,"gpt":17419,"substantially":17420,"muscle":17421,"Machine":17422,"4656":17423,"ar":17424,"suit":17425,"contributors":17426,"requir":17427,"Broadwell":17428,"sibility":17429,"confidential":17430,"Donini":17431,"radial":17432,"Timer":17433,"unlimited":17434,"Omniverse":17435,"ents":17436,"906":17437,"5034":17438,"U":17439,"hyperparameters":17440,"1590":17441,"A.8":17442,"know":17443,"harming":17444,"culture":17445,"PwC":17446,"sonous":17447,"powerless":17448,"Uniphase":17449,"8888":17450,"43715298.68":17451,"Practical":17452,"activity":17453,"Pleiss":17454,"ACT":17455,"Officers":17456,"2762":17457,"PLUG":17458,"5040":17459,"Mention":17460,"023":17461,"Pan":17462,"niche":17463,"Meanwhile":17464,"Beta":17465,"Boston":17466,"dozen":17467,"10214259921521483":17468,"Economist":17469,"1904":17470,"Amsalem":17471,"Spectrum":17472,"Tra":17473,"ADBE":17474,"cate":17475,"forever":17476,"misgivings":17477,"Giel":17478,"187":17479,"ℰ":17480,"Garg":17481,"20B":17482,"Abnorml":17483,"Vu":17484,"continue":17485,"Multivariable":17486,"assets":17487,"versions":17488,"declaration":17489,"propagation":17490,"stor":17491,"toregressive":17492,"everything":17493,"heating":17494,"Atishay":17495,"它":17496,"价格":17497,"ethnic":17498,"Proposing":17499,"acceptable":17500,"Keeping":17501,"humanity":17502,"☐":17503,"talked":17504,"171314":17505,"pat":17506,"Upsampling":17507,"refund":17508,"1953":17509,"Schwenk":17510,"Eligible":17511,"raining":17512,"16009":17513,"conveniently":17514,"C3":17515,"stumbled":17516,"485":17517,"Elementary":17518,"quotient":17519,"2.0338":17520,"Gogh":17521,"HyDE":17522,"g1":17523,"disutility":17524,"NAN":17525,"Ope":17526,"reinvented":17527,"Ren":17528,"9113":17529,"Rozi":17530,"investigating":17531,"Watch":17532,"Willingness":17533,"mation":17534,"hairy":17535,"Soft":17536,"prepopulated":17537,"Slate":17538,"blanks":17539,"determining":17540,"formulaic":17541,"V":17542,"Labradors":17543,"internet":17544,"Centered":17545,"6469":17546,"Discussions283":17547,"instrumentation":17548,"tialization":17549,"Tapestry":17550,"17325432986021042":17551,"Dops":17552,"标准":17553,"mu":17554,"8738":17555,"Reimplement":17556,"rata":17557,"rattler":17558,"cv":17559,"illiquid":17560,"0568":17561,"closeness":17562,"Pool":17563,"exception":17564,"acceleration":17565,"ANY":17566,"DenseBlock":17567,"corr2d":17568,"1559":17569,"GBit":17570,"across":17571,"primitive":17572,"5f":17573,"improvements":17574,"ˆ":17575,"OECD":17576,"𝝈":17577,"appropriately":17578,"Audit":17579,"captions":17580,"6378":17581,"1.36":17582,"1.6":17583,"TensorBoard":17584,"Conference":17585,"won":17586,"recalculating":17587,"Rajbhandari":17588,"Extend":17589,"614":17590,"EgoInstructor":17591,"1864":17592,"Unit":17593,"635":17594,"pop":17595,"express":17596,"coherently":17597,"additive":17598,"agree":17599,"invocation":17600,"effects":17601,"SCH":17602,"S":17603,"Raffel":17604,"current":17605,"stability":17606,"progressive":17607,"creating":17608,"ai":17609,"asynchronous":17610,"1054":17611,"kb":17612,"Ba":17613,"Adversarial":17614,"出":17615,"Hawthorne":17616,"wasted":17617,"displacement":17618,"25000":17619,"produced":17620,"closet":17621,"becoming":17622,"Candidate":17623,"difficulty":17624,"urges":17625,"abhinavsp0730":17626,"proves":17627,"interdependent":17628,"Infusing":17629,"pwepoiut":17630,"ckstr":17631,"insofar":17632,"eos":17633,"Diluted":17634,"TransformerDecoder":17635,"SuperPOD":17636,"Goyal":17637,"Trade":17638,"depending":17639,"Partitioning":17640,"Wang":17641,"Mesbah":17642,"coherent":17643,"dtd":17644,"248":17645,"outs":17646,"horizon":17647,"pens":17648,"kinds":17649,"descent":17650,"irrevocable":17651,"8462":17652,"infrastructures":17653,"Pad":17654,"representations":17655,"autonomous":17656,"discourage":17657,"Foxconn":17658,"injustices":17659,"NotebookApp":17660,"predicted":17661,"foundational":17662,"Europe":17663,"coding":17664,"Approximately":17665,"Israel":17666,"Wengert":17667,"McCaffery":17668,"0.98":17669,"comprised":17670,"McClenny":17671,"Vandermersch":17672,"laborious":17673,"Analysis":17674,"observability":17675,"reconstructing":17676,"near":17677,"His":17678,"767":17679,"trails":17680,"dilemma":17681,"14a":17682,"Sufficed":17683,"mm":17684,"stops":17685,"与":17686,"unions":17687,"observable":17688,"Recog":17689,"Determinants":17690,"2.4857":17691,"Child":17692,"fall":17693,"CC":17694,"Gijs":17695,"Edge":17696,"streets":17697,"Ms":17698,"Holder":17699,"Hessian":17700,"situation":17701,"infeasible":17702,"Avvaru":17703,"achieving":17704,"valu":17705,"defendants":17706,"Dilutive":17707,"checking":17708,"sunglasses":17709,"jonathanhrandall":17710,"0.9486":17711,"identifier":17712,"Ils":17713,"eigenvectors":17714,"子产":17715,"findings":17716,"84s":17717,"grammer":17718,"unspecified":17719,"Datastore":17720,"Imperative":17721,"Lowe":17722,"outlining":17723,"internalizing":17724,"shaped":17725,"societies":17726,"Woolley":17727,"relies":17728,"HOG":17729,"bottom":17730,"projection":17731,"correlations":17732,"selling":17733,"UV":17734,"085":17735,"candidates":17736,"RegNets":17737,"TACL":17738,"iterrows":17739,"B100":17740,"ual":17741,"begin":17742,"nowhere":17743,"Mathematics":17744,"radiation":17745,"←":17746,"7141":17747,"685":17748,"ç":17749,"efficientqa":17750,"ucts":17751,"hiring":17752,"Shuai":17753,"reformulating":17754,"allows":17755,"Give":17756,"Ultimate":17757,"CIFAR":17758,"Property":17759,"interac":17760,"disposal":17761,"𝐽":17762,"marginalize":17763,"dists":17764,"NICE":17765,"P4":17766,"obtaining":17767,"residency":17768,"judge":17769,"repo":17770,"2029":17771,"Marketing":17772,"224":17773,"leading":17774,"monitor":17775,"609":17776,"disruptive":17777,"tex":17778,"stubbornly":17779,"child":17780,"interpreter":17781,"CIO":17782,"considerations":17783,"prehension":17784,"5.7":17785,"Biel":17786,"ALU":17787,"except":17788,"59e":17789,"Tram":17790,"Frankle":17791,"6.1":17792,"Massively":17793,"25%":17794,"mirac":17795,"topk":17796,"4413":17797,"Methods":17798,"2012":17799,"attainable":17800,"iPad":17801,"315":17802,"图片说明":17803,"Where":17804,"heatmaps":17805,"involving":17806,"_":17807,"Commercial":17808,"arrowstyle":17809,"Detaching":17810,"plot":17811,"803":17812,"enormous":17813,"565":17814,"construc":17815,"Oguz":17816,"whichever":17817,"constructive":17818,"mitigation":17819,"contractions":17820,"im":17821,"shareholders":17822,"dient":17823,"Intel":17824,"vances":17825,"former":17826,"PERRY":17827,"equations":17828,"Strauss":17829,"𝑚":17830,"22026":17831,"margin":17832,"reducible":17833,"RegNetY":17834,"positioned":17835,"down":17836,"varying":17837,"Delinquent":17838,"sify":17839,"verticals":17840,"attend":17841,"registered":17842,"bia":17843,"Torch":17844,"nonexistence":17845,"x16":17846,"awkward":17847,"Bayes":17848,"several":17849,"survivors":17850,"comprehension":17851,"Jatowt":17852,"Symposium":17853,"liter":17854,"trigger":17855,"Weerasekera":17856,"z":17857,"imaging":17858,"breathless":17859,"period":17860,"raise":17861,"Hierarchical":17862,"fauna":17863,"221":17864,"18264":17865,"ABSTAIN":17866,"tify":17867,"218990":17868,"division":17869,"happy":17870,"softly":17871,"illusion":17872,"5934":17873,"10.0":17874,"intended":17875,"Index":17876,"mining":17877,"0.1306":17878,"Wxh":17879,"expire":17880,"protein":17881,"Gradients":17882,"BCEWithLogitsLoss":17883,"compulsory":17884,"hinted":17885,"∈":17886,"0.002295":17887,"incentive":17888,"17e":17889,"Lars":17890,"Keras":17891,"complying":17892,"Discussions138":17893,"s3":17894,"litigating":17895,"revoking":17896,"AUC":17897,"15%":17898,"conse":17899,"9.1":17900,"Simulate":17901,"Subsample":17902,"跨越":17903,"1985":17904,"CEDAR":17905,"RETGEN":17906,"priors":17907,"releasing":17908,"labeling":17909,"tracing":17910,"precision":17911,"Xiang":17912,"Gain":17913,"Barkan":17914,"Emmanouilidou":17915,"neurally":17916,"keynote":17917,"sents":17918,"squish":17919,"approximated":17920,"Teo":17921,"Dog":17922,"bashrc":17923,"权限":17924,"vant":17925,"nate":17926,"knn":17927,"及":17928,"Chinchilla":17929,"buildings":17930,"weight":17931,"maxlen":17932,"conservative":17933,"placed":17934,"bowen0701":17935,"cols":17936,"learning":17937,"donkey":17938,"Vap":17939,"news":17940,"reorg":17941,"informa":17942,"connecting":17943,"RING":17944,"engage":17945,"nonpublic":17946,"xavier":17947,"1M2":17948,"PROXY":17949,"correctly":17950,"courses6":17951,"LLMs":17952,"emerges":17953,"concentrations":17954,"hold":17955,"densenets":17956,"d":17957,"documentation291":17958,"2022":17959,"TensorCores":17960,"7z":17961,"WRITTEN":17962,"b2":17963,"766":17964,"14.13":17965,"expenditures":17966,"Certification":17967,"313":17968,"unrest":17969,"cutting":17970,"312":17971,"Exploratory":17972,"0974":17973,"Hebrew":17974,"Similarity":17975,"approving":17976,"mlp":17977,"sentation":17978,"gab":17979,"13534":17980,"Rotate":17981,"Walsh":17982,"loud":17983,"Stoica":17984,"Encoder":17985,"anyone":17986,"expanding":17987,"rationale":17988,"Item":17989,"aggregated":17990,"all":17991,"numeric":17992,"dle":17993,"loch":17994,"02767":17995,"arm":17996,"rectifiers":17997,"Investigator":17998,"collapsed":17999,"misses":18000,"Myelin":18001,"Visualizing":18002,"evade":18003,"successive":18004,"quirks":18005,"verifying":18006,"consents":18007,"music":18008,"iterates":18009,"notified":18010,"Santurkar":18011,"Column":18012,"hedged":18013,"C":18014,"Beaumont":18015,"spaced":18016,"Compensate":18017,"01068":18018,"github":18019,"406":18020,"senorcinco":18021,"Melo":18022,"Diversity":18023,"capitalized":18024,"epistemic":18025,"adaptive":18026,"1093":18027,"doctor":18028,"Strides":18029,"3038":18030,"traverse":18031,"Boureau":18032,"covmat":18033,"synchronization":18034,"examining":18035,"weibull":18036,"1085":18037,"calm":18038,"Abdelzaher":18039,"competitor":18040,"1981":18041,"bring":18042,"4167":18043,"Discussions259":18044,"decrees":18045,"Policies":18046,"expectation":18047,"450":18048,"Several":18049,"Colors":18050,"corresponded":18051,"edu":18052,"mainstream":18053,"sequences":18054,"Bioinspired":18055,"Taco":18056,"answered":18057,"Hofst":18058,"0.00019":18059,"stochas":18060,"exacerbated":18061,"342":18062,"702":18063,"8516":18064,"No":18065,"she":18066,"452":18067,"2263":18068,"inflected":18069,"BPPT":18070,"regularizer":18071,"Contractual":18072,"2256":18073,"2.6461":18074,"border":18075,"associates":18076,"pic":18077,"05856":18078,"binomial":18079,"09288":18080,"2304":18081,"causing":18082,"758":18083,"678":18084,"sider":18085,"GTX":18086,"confirm":18087,"crime":18088,"hashlib":18089,"Houdt":18090,"Speech":18091,"312770":18092,"TOC":18093,"polynomials":18094,"rations":18095,"Chaudhari":18096,"carefully":18097,"Hx":18098,"Maximizing":18099,"glish":18100,"rolled":18101,"arxiv":18102,"--------------------":18103,"Designed":18104,"Termination":18105,"em":18106,"function":18107,"digging":18108,"hun":18109,"owe":18110,"queries":18111,"8kHz":18112,"Yuan":18113,"1949":18114,"compre":18115,"Interpretations":18116,"15084":18117,"bidirectionally":18118,"857":18119,"Solution":18120,"reproduce":18121,"meaningfully":18122,"husband":18123,"implement":18124,"Ming":18125,"33%":18126,"gen":18127,"eat":18128,"63":18129,"session":18130,"":18131,"nistic":18132,"Error":18133,"1011":18134,"uous":18135,"malicious":18136,"F1":18137,"WITHHOLD":18138,"papers":18139,"policy":18140,"firsthand":18141,"tiation":18142,"grade":18143,"adapts":18144,"playlist":18145,"SaleType":18146,"LMs":18147,"unintuitive":18148,"0100":18149,"Alliance":18150,"Monte":18151,"dynamical":18152,"retriev":18153,"sq":18154,"discussions":18155,"Sequences":18156,"distill":18157,"0.352":18158,"speedups":18159,"shouldn":18160,"Struct":18161,"23433":18162,"Discussions264":18163,"cohorts":18164,"2261":18165,"Discussions208":18166,"submit":18167,"modes":18168,"Andreassen":18169,"satisfied":18170,"accessing":18171,"server":18172,"forecasting":18173,"PROVIDE":18174,"justify":18175,"dots":18176,"140381179266448":18177,"Arsenin":18178,"sig":18179,"thing":18180,"flexibly":18181,"bankruptcy":18182,"schnauzer":18183,"babies":18184,"distribuzione":18185,"Datar":18186,"room":18187,"Synopsys":18188,"4573":18189,"Employment":18190,"1055":18191,"Mangasarian":18192,"constraining":18193,"Duchi":18194,"interdisciplinary":18195,"log2":18196,"eigenvector":18197,"Manipulation":18198,"eling":18199,"387":18200,"pReLU":18201,"Rethinking":18202,"q2p":18203,"inadvertently":18204,"fix":18205,"Merger":18206,"Yann":18207,"altering":18208,"performed":18209,"undistributed":18210,"Treasury":18211,"kill":18212,"afforded":18213,"albeit":18214,"author":18215,"yy":18216,"same":18217,"Forschungszentrum":18218,"extreme":18219,"ule":18220,"choice":18221,"guage":18222,"forc":18223,"ca":18224,"更":18225,"Wall":18226,"neglecting":18227,"stakeholder":18228,"wavelength":18229,"moves":18230,"SuccessiveHalvingSched":18231,"insider":18232,"accom":18233,"hopeful":18234,"损坏":18235,"locally":18236,"Define":18237,"cases":18238,"BPE":18239,"00005":18240,"Popescul":18241,"数据":18242,"242":18243,".__":18244,"EfficientQA":18245,"Sequence":18246,"astoundingly":18247,"past":18248,"terminal":18249,"obsolete":18250,"Neighbours":18251,"ZHANG":18252,"MGIC":18253,"feed":18254,"`":18255,"g4dn":18256,"preconditioner":18257,"older":18258,"Greenawald":18259,"accident":18260,"182764":18261,"randn":18262,"formats":18263,"Eds":18264,"Frequently":18265,"deeper":18266,"Imputation":18267,"through":18268,"CatTransform":18269,"claimed":18270,"wanting":18271,"2.8356":18272,"communications":18273,"Ryzen":18274,"Next":18275,"988":18276,"doc":18277,"taxation":18278,"Cambridge":18279,"s1":18280,"violated":18281,"postulated":18282,"hypercomplex":18283,"reinventing":18284,"helpfulness":18285,"Berkeley":18286,"explain":18287,"administer":18288,"16xlarge":18289,"validating":18290,"Penn":18291,"Cucchiara":18292,"dist":18293,"trivially":18294,"bang":18295,"915":18296,"8397":18297,"Yan":18298,"fr":18299,"corrupt":18300,"squarely":18301,"perceptron":18302,"enjoying":18303,"converse":18304,"director":18305,"0.7722":18306,"urban":18307,"443":18308,"Ingest":18309,"obstacles":18310,"norm":18311,"ful":18312,"diffusion":18313,"remedial":18314,"investors":18315,"627":18316,"1":18317,"059":18318,"2483":18319,"preserving":18320,"checkpoint":18321,"MICHAEL":18322,"consequently":18323,"textbook":18324,"decision":18325,"interfering":18326,"renormalizing":18327,"01652":18328,"hence":18329,"mirror":18330,"0.0993":18331,"Indices":18332,"Exchange":18333,"Miech":18334,"initializations":18335,"Vote":18336,"第一":18337,"verwandte":18338,"tative":18339,"250":18340,"loga":18341,"elegantly":18342,"Likun":18343,"y2":18344,"Explicit":18345,"nil":18346,"Maddison":18347,"arrival":18348,"Visually":18349,"Successive":18350,"cards":18351,"cally":18352,"logdet":18353,"Hyperparameter":18354,"disappear":18355,"Truncation":18356,"attn":18357,"obs":18358,"0055":18359,"encompasses":18360,"pervasive":18361,"KNOW":18362,"wireframe":18363,"downstream":18364,"quantifica":18365,"Fried":18366,"Cornia":18367,"60000":18368,"recogni":18369,"innovations":18370,"sharey":18371,"«":18372,"retains":18373,"ostensible":18374,"0108":18375,"2010":18376,".":18377,"discriminating":18378,"unity":18379,"confusion":18380,"overseas":18381,"alerts":18382,"Therefore":18383,"accomplished":18384,"philosophy":18385,"Nauk":18386,"override":18387,"Distinct":18388,"definitely":18389,"diagonally":18390,"12956867470224812":18391,"2087":18392,"Sometimes":18393,"parsing":18394,"Tricks":18395,"Mitliagkas":18396,"subclasses":18397,"70":18398,"𝑄":18399,"memorizes":18400,"medications":18401,"262":18402,"849":18403,"readlines":18404,"1536":18405,"Launching":18406,"BFLOAT16":18407,"Tanh":18408,"holdout":18409,"aggregations":18410,"14":18411,"derstand":18412,"03b":18413,"Delaware":18414,"Jacobian":18415,"refreshment":18416,"ognizing":18417,"unsophisticated":18418,"VQA":18419,"neural":18420,"491":18421,"transfer":18422,"Native":18423,"GitHub9":18424,"explosion":18425,"RNN":18426,"notification":18427,"Prince":18428,"linked":18429,"Betker":18430,"Ni":18431,"stacks":18432,"0.00078":18433,"05118":18434,"angeschaut":18435,"09237":18436,"Shah":18437,"chiplet":18438,"Another":18439,"CV":18440,"stall":18441,"nonnegative":18442,"h":18443,"events":18444,"11511":18445,"Recursion":18446,"button":18447,"broken":18448,"understand":18449,"CIFAR10":18450,"231":18451,"datacenter":18452,"predicting":18453,"borders":18454,"Aaron":18455,"Good":18456,"2312":18457,"minimized":18458,"decodes":18459,"crane":18460,"80186":18461,"finalization":18462,"fras":18463,"discuss":18464,"helps":18465,"ELMo":18466,"autoencoder":18467,"13256":18468,"服务":18469,"clustering":18470,"Nocedal":18471,"113":18472,"GPU2":18473,"Holt":18474,"FURNISH":18475,"rooster":18476,"subsets":18477,"\\":18478,"Sancak":18479,"preconceived":18480,"potheses":18481,"bc":18482,"late":18483,"Anil":18484,"STATEMENT":18485,"finishes":18486,"evaluates":18487,"initializers":18488,"breakthroughs":18489,"repetition":18490,"outputted":18491,"Understanding":18492,"Late":18493,"Gnn":18494,"Snack":18495,"2080":18496,"d2l":18497,"073":18498,"localization":18499,"1991":18500,"10.1":18501,"unit":18502,"Academy":18503,"topic":18504,"technically":18505,"look":18506,"emitting":18507,"realizations":18508,"nary":18509,"xa0":18510,"EEA":18511,"Surveys":18512,"pends":18513,"Abdallah":18514,"Arora":18515,"Asking":18516,"sticking":18517,"ming":18518,"3490":18519,"walkthrough":18520,"eye":18521,"EaE":18522,"scenario":18523,"sites":18524,"Various":18525,"XXL":18526,"xlarge":18527,"06990":18528,"057":18529,"cleaner":18530,"care":18531,"May":18532,"newly":18533,"respond":18534,"provision":18535,"dibs":18536,"965":18537,"collaborating":18538,"Derive":18539,"fluctuation":18540,"3460":18541,"connectivity":18542,"proach":18543,"Inventory":18544,"association":18545,"xxxvi":18546,"Can":18547,"OneHotCategoricalStraightThrough":18548,"loguniform":18549,"predicated":18550,"spect":18551,"Discussions187":18552,"artificial":18553,"Riccardo":18554,"deepteki":18555,"989":18556,"rgb":18557,"clone":18558,"row":18559,"solvable":18560,"0.246":18561,"341":18562,"RIAG":18563,"reader":18564,"Display":18565,"1777":18566,"LLP":18567,"amination":18568,"Hopefully":18569,"全面":18570,"diversification":18571,"Iterated":18572,"resources":18573,"GPU1":18574,"Penghao":18575,"Cauchy":18576,"plants":18577,"mimicks":18578,"enumerate":18579,"423":18580,"grocery":18581,"letters":18582,"AnyNetX":18583,"skins":18584,"Documentation":18585,"scholars":18586,"votes":18587,"site":18588,"Reclassification":18589,"Collobert":18590,"1147":18591,"Back":18592,"include":18593,"Paradoxically":18594,"safe":18595,"edge":18596,"depict":18597,"chunks":18598,"runtime":18599,"undo":18600,"treasury":18601,"iterated":18602,"Gou":18603,"squeeze":18604,"instants":18605,"1017":18606,"3836":18607,"432":18608,"takes":18609,"der":18610,"NEON":18611,"714568":18612,"attestation":18613,"A.32":18614,"733":18615,"Builders":18616,"Letham":18617,"RSUs":18618,"hypoth":18619,"starting":18620,"recycled":18621,"Governance":18622,"6B":18623,"Kirstain":18624,"overwhelming":18625,"multiset":18626,"amalgamates":18627,"tenfold":18628,"haystack":18629,"breakdown":18630,"Jen":18631,"filters":18632,"A.14":18633,"BNLeNetScratch":18634,"Gao":18635,"nodes":18636,"1039":18637,"690":18638,"Mavadia":18639,"capping":18640,"conventional":18641,"Learning":18642,"94":18643,"30th":18644,"Devanbu":18645,"17.3":18646,"your":18647,"1957":18648,"gram":18649,"Beyond":18650,"reaches":18651,"3929":18652,"Gibbs":18653,"Mask":18654,"formidable":18655,"Shoquist":18656,"𝜌":18657,"Redmon":18658,"RA":18659,"vote":18660,"Chishti":18661,"splitext":18662,"InferFix":18663,"move":18664,"outperforms":18665,"RPRR":18666,"FD":18667,"Shifting":18668,"MatteoFerrara":18669,"Receptive":18670,"Kuzovkin":18671,"picking":18672,"certainly":18673,"replacements":18674,"outdated":18675,"wrapper":18676,"9158":18677,"2017":18678,"understood":18679,"Truncating":18680,"520":18681,"metamind":18682,"reputation":18683,"Kadavath":18684,"counteracts":18685,"gio":18686,"seman":18687,"files":18688,"intangible":18689,"9328":18690,"Schwann":18691,"criticized":18692,"certificates":18693,"embracing":18694,"548M":18695,"upon":18696,"Reserved":18697,"yuqinhan":18698,"Aggarwal":18699,"Alas":18700,"mals":18701,"above":18702,"dirname":18703,"mises":18704,"dry":18705,"hop":18706,"answering":18707,"821":18708,"worrying":18709,"progress":18710,"96":18711,"racy":18712,"creative":18713,"homework":18714,"Splitting":18715,"Lumsdaine":18716,"Switches":18717,"said":18718,"suppression":18719,"motions":18720,"expressing":18721,"Excess":18722,"selections":18723,"Tools":18724,"published":18725,"perceptrons":18726,"artistic":18727,"sleeping":18728,"SEER":18729,"conclusions":18730,"ease":18731,"Regulatory":18732,"Energy":18733,"Symmetric":18734,"ages":18735,"Increases":18736,"980":18737,"objectives":18738,"Mechanics":18739,"风景":18740,"Mani":18741,"03360":18742,"reshape":18743,"15.2":18744,"y1":18745,"robotic":18746,"Crucially":18747,"Discussions244":18748,"permutation":18749,"entity":18750,"106000":18751,"sta":18752,"enhance":18753,"12.5":18754,"multiprocessing":18755,"influx":18756,"8":18757,"burst":18758,"genes":18759,"lots":18760,"basement":18761,"¸":18762,"frustrated":18763,"v1":18764,"43":18765,"ImageReadMode":18766,"3359885631737537":18767,"Glu":18768,"tries":18769,"novations":18770,"dreds":18771,"alcohol":18772,"GNN":18773,"hierarchi":18774,"highway":18775,"0.86":18776,"sliced":18777,"square":18778,"Monolingual":18779,"price":18780,"Qualcomm":18781,"BS":18782,"426524":18783,"incredibly":18784,"Jauvin":18785,"llms":18786,"consistency":18787,"skier":18788,"Experts":18789,"Budapest":18790,"OSDI":18791,"monetary":18792,"analytical":18793,"indi":18794,"explicit":18795,"efforts":18796,"memories":18797,"releases":18798,"economy":18799,"Wear":18800,"hours":18801,"ethics":18802,"rewrite":18803,"395":18804,"undesirable":18805,"Haben":18806,"68":18807,"crack":18808,"exp":18809,"links":18810,"calcu":18811,"moire":18812,"Eigendecompositions":18813,"unintended":18814,"Hou":18815,"secure":18816,"arrived":18817,"hospitalized":18818,"pressure":18819,"IV":18820,"structures":18821,"md":18822,"estimates":18823,"exten":18824,"plain":18825,"1780":18826,"aws":18827,"15939":18828,"Zan":18829,"07909":18830,"Announced":18831,"167":18832,"private":18833,"Divergence":18834,"France":18835,"00789":18836,"5940":18837,"AGX":18838,"Physiology":18839,"affirmed":18840,"informative":18841,"University":18842,"ptb":18843,"33":18844,"Severance":18845,"FreeBase":18846,"项":18847,"curatorial":18848,"leaf":18849,"Les":18850,"rabbit":18851,"smallest":18852,"catastrophic":18853,"percentage":18854,"manipulated":18855,"accruals":18856,"Ferrell":18857,"Socher":18858,"participating":18859,"design":18860,"Re2G":18861,"20158":18862,"Income":18863,"Executive":18864,"empha":18865,"Needless":18866,"justice":18867,"seed":18868,"variation":18869,"demand":18870,"1959":18871,"841":18872,"deduced":18873,"strict":18874,"\u0013":18875,"national":18876,"Locatello":18877,"2238":18878,"217":18879,"Unsupervised":18880,"Sum":18881,"Carbin":18882,"dients":18883,"246889":18884,"natural":18885,"subplot":18886,"Lipschitz":18887,"Upon":18888,"ECCV":18889,"raises":18890,"Teacher":18891,"ical":18892,"ToTensor":18893,"Image":18894,"monitors":18895,"initialization":18896,"Moore":18897,"Kubernetes":18898,"vious":18899,"inters":18900,"0.0017270983662456274":18901,"Cohesity":18902,"DALL":18903,"ExpTransform":18904,"shuffle":18905,"Patents":18906,"presents":18907,"Level":18908,"trainer":18909,"CBOW":18910,"processes":18911,"cond":18912,"ever":18913,"Shakespeare":18914,"maintenance":18915,"pulling":18916,"indications":18917,"Nevertheless":18918,"Sheet":18919,"TO":18920,"correction":18921,"anticipating":18922,"8.9":18923,"Sufficient":18924,"accelerators":18925,"206":18926,"posteriori":18927,"Controls":18928,"Billed":18929,"entire":18930,"9597":18931,"Discussions239":18932,"Related":18933,"MountainCar251":18934,"missed":18935,"tistical":18936,"Av":18937,"d2":18938,"background":18939,"credibility":18940,"balmy":18941,"breeds":18942,"Groups":18943,"Ong":18944,"disaggregate":18945,"flaw":18946,"separate":18947,"Society":18948,"tecture":18949,"Discussions79":18950,"adoption":18951,"Optionally":18952,"conspicuously":18953,"geometric":18954,"jacent":18955,"tion59":18956,"Strided":18957,"frivolous":18958,"regulations":18959,"vary":18960,"Discussions111":18961,"loose":18962,"race":18963,"entrepreneur":18964,"DuBois":18965,"finding":18966,"parse":18967,"lam":18968,"Pattern":18969,"531":18970,"overlapping":18971,"2.7434":18972,"Ginsburg":18973,"throwing":18974,"Taking":18975,"intermediaries":18976,"storms":18977,"Balance":18978,"24900506":18979,"magnum":18980,"355":18981,"TOTAL":18982,"attacked":18983,"778503":18984,"4.1":18985,"Harrison":18986,"1064":18987,"Christmann":18988,"A2":18989,"bottou":18990,"majority":18991,"isomorphisms":18992,"shortening":18993,"0.277":18994,"simplify":18995,"5744":18996,"cryptonaut":18997,"phylogenetic":18998,"incantations":18999,"Organize":19000,"configure":19001,"RetrieveGAN":19002,"basicConfig":19003,"understanding":19004,"exercises":19005,"Female":19006,"2384":19007,"dareddygari":19008,"Representative":19009,"tangible":19010,"Already":19011,"pd":19012,"updated":19013,"bi":19014,"Tom":19015,"Biological":19016,"rectangu":19017,"CodeICL":19018,"inspect":19019,"PCAOB":19020,"interpreted":19021,"Matsuo":19022,"h1":19023,"4208":19024,"¬":19025,"Philosophy":19026,"pseudoran":19027,"mailing":19028,"RohanKarthikeyan":19029,"289":19030,"4966":19031,"SOC":19032,"Ryder":19033,"S3510":19034,"poodle":19035,"operators":19036,"Brand":19037,"formers":19038,"BOS":19039,"spoke":19040,"Louis":19041,"before":19042,"Unremitted":19043,"buy":19044,"Feature":19045,"COPY":19046,"Planning":19047,"Ideally":19048,"instrumental":19049,"Sahoo":19050,"Initially":19051,"xvii":19052,"Pontil":19053,"Contribution":19054,"6912":19055,"R25":19056,"aspiring":19057,"release":19058,"organizational":19059,"fortuitous":19060,"740":19061,"Discussions255":19062,"administratively":19063,"Normalize":19064,"0129":19065,"Explore":19066,"differentiate":19067,"dreaded":19068,"compilation":19069,"sobering":19070,"crepancy":19071,"submissions":19072,"Standard":19073,"deb":19074,"":19075,"Cash":19076,"curated":19077,"SSH":19078,"omitted":19079,"Advanced":19080,"Explain":19081,"ensure":19082,"mul":19083,"hlines":19084,"1.1951":19085,"gunk":19086,"706":19087,"Prentice":19088,"413":19089,"counterparts":19090,"multiply":19091,"Repofuse":19092,"disruption":19093,"summarization":19094,"entrypoint":19095,"Xie":19096,"proxyholder":19097,"p2.16":19098,"observational":19099,"Transitions":19100,"BN":19101,"经由":19102,"strengthened":19103,"1009":19104,"predetermined":19105,"Description":19106,"Discussions104":19107,"dressing":19108,"mented":19109,"backprop":19110,"3.2":19111,"response":19112,"elide":19113,"Median":19114,"zucchinis":19115,"throughout":19116,"tired":19117,"subscripts":19118,"Luo":19119,"20%":19120,"at":19121,"dropout1":19122,"Manning":19123,"killer":19124,"elem":19125,"verified":19126,"Coherent":19127,"Zis":19128,"underweighted":19129,"clearer":19130,"tive":19131,"⊥":19132,"better":19133,"overwhelm":19134,"Revenue":19135,"16x":19136,"truncating":19137,"sadly":19138,"contribution":19139,"hyperpa":19140,"Dynamical":19141,"reimbursements":19142,"macroeconomic":19143,"settled":19144,"Hyperplanes":19145,"iterations":19146,"payable":19147,"amendments":19148,"BCom":19149,"Given":19150,"Background":19151,"127500":19152,"coins":19153,"clogging":19154,"super":19155,"arbitrage":19156,"Counter":19157,"Logical":19158,"509":19159,"094":19160,"withhold":19161,"devise":19162,"feedforward":19163,"spirals":19164,"Plans":19165,"A800":19166,"768":19167,"Together":19168,"popular":19169,"crafting":19170,"WWW":19171,"lacks":19172,"HD":19173,"JD":19174,"summa":19175,"Sections":19176,"Accrual":19177,"2.2":19178,"197":19179,"placement":19180,"enlarge":19181,"RESDSQL":19182,"datapoint":19183,"10612":19184,"712":19185,"notational":19186,"plus":19187,"addressed":19188,"communication":19189,"millions":19190,"Statistic":19191,"analogous":19192,"gaps":19193,"differentiability":19194,"Specify":19195,"integrand":19196,"安全性":19197,"sented":19198,"Nelson":19199,"tread":19200,"employment":19201,"necessary":19202,"LDM":19203,"today":19204,"strictly":19205,"Gemini":19206,"causes":19207,"493":19208,"oversees":19209,"ized":19210,"QPI":19211,"Precise":19212,"offending":19213,"625":19214,"rig":19215,"Pointer":19216,"realms":19217,"2104":19218,"Musto":19219,"Revels":19220,"sports":19221,"di":19222,"omitting":19223,"2188":19224,"长":19225,"Entity":19226,"498":19227,"convolves":19228,"outside":19229,"tomized":19230,"seemingly":19231,"Wistron":19232,"Built":19233,"saved":19234,"Identification":19235,"21.1":19236,"filed":19237,"Partnering":19238,"3111":19239,"E":19240,"iter":19241,"260":19242,"9000097513198853":19243,"monitoring":19244,"away":19245,"generalizable":19246,"此处":19247,"14.12":19248,"06175":19249,"货币":19250,"enjoy":19251,"syne":19252,"contri":19253,"gures":19254,"simplified":19255,"DataFrame":19256,"audios":19257,"rag":19258,"ciation":19259,"employed":19260,"Statisticians":19261,"rescale":19262,"Rabe":19263,"noiseless":19264,"modifier":19265,"ECOSYSTEM":19266,"trates":19267,"mentation":19268,"22nd":19269,"E5":19270,"timelines":19271,"pathological":19272,"Martin":19273,"27001":19274,"inequality":19275,"efficient":19276,"structurally":19277,"ingredients":19278,"Revisited":19279,"Chintala":19280,"miniconda3":19281,"ndarray":19282,"conducting":19283,"abstracting":19284,"organization":19285,"surgical":19286,"Retrieve":19287,"Accuracy":19288,"lung":19289,"ciently":19290,"filterwarnings":19291,"一节":19292,"restrictions":19293,"10789":19294,"adult":19295,"surfaces":19296,"Ichioka":19297,"expository":19298,"gammas":19299,"sin2":19300,"Element":19301,"cease":19302,"05100":19303,"VonMises":19304,"topology":19305,"prize":19306,"initializes":19307,"Pong":19308,"reinforce":19309,"referred":19310,"chronological":19311,"06490":19312,"69":19313,"reduce":19314,"accelerating":19315,"cancels":19316,"attention2":19317,"899996":19318,"ownership":19319,"Accumulated":19320,"factoring":19321,"465":19322,"hurting":19323,"Best":19324,"ﬁ":19325,"0.108":19326,"gradi":19327,"movements":19328,"volatile":19329,"forgetting":19330,"Continuum":19331,"dense2":19332,"Cours":19333,"React":19334,"hpo":19335,"DropoutMLPScratch":19336,"6132":19337,"save":19338,"Student":19339,"ideally":19340,"Xavier":19341,"abilities":19342,"Byte":19343,"git":19344,"endowed":19345,"broad":19346,"children":19347,"2008":19348,"transcoding":19349,"facilitates":19350,"Fund":19351,"uence":19352,"OR":19353,"combin":19354,"destination":19355,"Selecting":19356,"father":19357,"12627":19358,"Reid":19359,"Shuster":19360,"IID":19361,"1802":19362,"initial":19363,"TransformerEncoderBlock":19364,"consultant":19365,"amortization":19366,"解析":19367,"harvested":19368,"介绍性":19369,"Numerous":19370,"Satisfying":19371,"preds":19372,"Gulati":19373,"699":19374,"adapter":19375,"augmen":19376,"sigmoid":19377,"came":19378,"neuron":19379,"747496":19380,"sanctions":19381,"rounded":19382,"4724884":19383,"Extracting":19384,"8949":19385,"reopen":19386,"deem":19387,"summarized":19388,"stems":19389,"harder":19390,"ates":19391,"3028":19392,"suffered":19393,"731":19394,"Perplexity":19395,"sound":19396,"isolate":19397,"1707":19398,"Mao":19399,"5882":19400,"filt":19401,"Truong":19402,"cow":19403,"Award":19404,"gence":19405,"thumbnails":19406,"newsgroups":19407,"untuned":19408,"tations":19409,"2.0148":19410,"ops":19411,"ably":19412,"insufficiently":19413,"1245":19414,"SAIC":19415,"1073":19416,"harmful":19417,"working":19418,"9803":19419,"removing":19420,"excess":19421,"FOR":19422,"toward":19423,"Appeals":19424,"megapixel":19425,"isolating":19426,"cameras":19427,"0.05":19428,"2980":19429,"Shrimad":19430,"prevailing":19431,"believed":19432,"greedy":19433,"cover":19434,"empowers":19435,"reverses":19436,"whatever":19437,"retired":19438,"autonomously":19439,"dismiss":19440,"Pushing":19441,"optimally":19442,"Freebase":19443,"999746":19444,"3588":19445,"Indexing":19446,"Possessing":19447,"restarts":19448,"Lerer":19449,"inactive":19450,"IMDb":19451,"sec":19452,"04304":19453,"hundred":19454,"Attuari":19455,"hereof":19456,"fre":19457,"collateral":19458,"insurmountable":19459,"ConvED":19460,"skipped":19461,"9.2":19462,"indicators":19463,"7802":19464,"correspond":19465,"qual":19466,"portfolio":19467,"Speculative":19468,"2324":19469,"advise":19470,"Koley":19471,"designers":19472,"内容":19473,"export":19474,"eter":19475,"suffers":19476,"filler":19477,"coincident":19478,"1994":19479,"these":19480,"MXNET":19481,"accessed":19482,"lessons":19483,"⊤":19484,"encapsulate":19485,"necessitates":19486,"subse":19487,"obtains":19488,"percent":19489,"Today":19490,"infamous":19491,"nmt":19492,"He":19493,"gans":19494,"Validated":19495,"MultiHeadAttention":19496,"bo":19497,"Schilling":19498,"D5":19499,"voracious":19500,"length":19501,"issuance":19502,"fas":19503,"jurisdictional":19504,"dialogues":19505,"health":19506,"non":19507,"5701":19508,"eyeball":19509,"configu":19510,"bert":19511,"Manager":19512,"261":19513,"lions":19514,"n0":19515,"Arithmetic":19516,"Douze":19517,"tender":19518,"1.7773":19519,"Henri":19520,"PowerTransform":19521,"Stack":19522,"JUNE":19523,"GELU":19524,"Compressing":19525,"observation":19526,"07669":19527,"3159":19528,"catch":19529,"57e":19530,"cer":19531,"inches":19532,"088129":19533,"reranks":19534,"legacy":19535,"fer":19536,"diagnosed":19537,"19.3":19538,"kernel2matrix":19539,"Vetrov":19540,"Private":19541,"coefficients":19542,"released":19543,"RAS":19544,"Organizations":19545,"Omnitab":19546,"amazing":19547,"Bruss":19548,"Persis":19549,"caveat":19550,"decreased":19551,"attendance":19552,"Accessing":19553,"kcal":19554,"businesses":19555,"4979":19556,"L40S":19557,"of":19558,"reluctant":19559,"displayed":19560,"aptitude":19561," ":19562,"917":19563,"distilled":19564,"adolescents":19565,"auxiliary":19566,"lineup":19567,"caffeinated":19568,"195":19569,"2nd":19570,"net":19571,"targeted":19572,"AA":19573,"memorable":19574,"Refreshment":19575,"positives":19576,"3269":19577,"focused":19578,"rooms":19579,"sional":19580,"Miotto":19581,"modify":19582,"GDPR":19583,"3454":19584,"007":19585,"Disclosures":19586,"seen":19587,"SGI":19588,"6300":19589,"Qualified":19590,"aided":19591,"style":19592,"stocking":19593,"eternal":19594,"Waste":19595,"521":19596,"DeiT":19597,"Lessons":19598,"6294":19599,"ap":19600,"61.917364":19601,"Es":19602,"Pilchin":19603,"Jang":19604,"automotive":19605,"2207":19606,"megabytes":19607,"acted":19608,"perpetual":19609,"8172":19610,"mol":19611,"Salesforce":19612,"diligence":19613,"parties":19614,"liable":19615,"3781":19616,"1308":19617,"conscious":19618,"normalized":19619,"deference":19620,"plicates":19621,"laborative":19622,"distrust":19623,"captioning":19624,"chatbot":19625,"inflation":19626,"nempirical":19627,"mp":19628,"838":19629,"dogs":19630,"marketing":19631,"disasters":19632,"Diskann":19633,"Apply":19634,"44639554136672527":19635,"Biesial":19636,"massive":19637,"revealed":19638,"notebooks":19639,"myserver":19640,"gauges":19641,"Zeiler":19642,"BIG":19643,"1708":19644,"amplifying":19645,"Work":19646,"digit":19647,"constrains":19648,"exhibiting":19649,"heterogeneous":19650,"，":19651,"configspace":19652,"Bioengineering":19653,"07285":19654,"boundary":19655,"epidemics":19656,"utze":19657,"P1":19658,"compressed":19659,"669":19660,"trastive":19661,"MTFraEng":19662,"technol":19663,"expose":19664,"formulae":19665,"Upad":19666,"1435":19667,"RetDream":19668,"Gitman":19669,"Ho":19670,"charge":19671,"invoking":19672,"snapshots":19673,"imation":19674,"IJCNN":19675,"hint":19676,"Bulletin":19677,"reap":19678,"subjectivity":19679,"Richardson":19680,"emissions":19681,"云端":19682,"8026":19683,"fee":19684,"faltering":19685,"sophisticated":19686,"Kong":19687,"oper":19688,"menu":19689,"Cadence":19690,"dict":19691,"Indebtedness":19692,"Manufacturing":19693,"Medicine":19694,"docu":19695,"注册":19696,"states":19697,"Incorporating":19698,"Remove":19699,"16568":19700,"1008":19701,"681":19702,"retrain":19703,"{":19704,"Mx":19705,"plenty":19706,"GPTCache":19707,"7195":19708,"syntax":19709,"wasn":19710,"cumulating":19711,"menace":19712,"documentation":19713,"0.75":19714,"Moczulski":19715,"increased":19716,"Entropy":19717,"trebeljahr":19718,"deemed":19719,"about":19720,"dently":19721,"decompose":19722,"criticism":19723,"young":19724,"culus":19725,"rescales":19726,"life":19727,"phenom":19728,"Captioning":19729,"Filed":19730,"recursive":19731,"notable":19732,"𝑠":19733,"variants":19734,"Chervonenkis":19735,"Aligns":19736,"verbs":19737,"growth":19738,"exchanging":19739,"612":19740,"roi":19741,"accumulates":19742,"cousin":19743,"fra":19744,"Spatio":19745,"\u001b":19746,"transferred":19747,"193776":19748,"H3":19749,"Fuse":19750,"specifications":19751,"Standardization":19752,"01738":19753,"402":19754,"300000":19755,"fitted":19756,"labs":19757,"financial":19758,"447":19759,"Cohen":19760,"0.085":19761,"Owned":19762,"17081":19763,"coe":19764,"localhost":19765,"sight":19766,"encoder":19767,"Evidence":19768,"outsize":19769,"waiting":19770,"executive":19771,"replace":19772,"prospective":19773,"4300":19774,"generalizations":19775,"inserted":19776,"Beyer":19777,"recurrent":19778,"Coordinates":19779,"Toutanova":19780,"Min":19781,"localized":19782,"sake":19783,"0.406":19784,"exactly":19785,"0.000000":19786,"len":19787,"identification":19788,"inherently":19789,"3.0":19790,"stepsize":19791,"informatics":19792,"sink":19793,"joint":19794,"nomination":19795,"postprocessing":19796,"roof":19797,"aleatoric":19798,"Wolf":19799,"Sciences":19800,"biopharmaceuticals":19801,"THE":19802,"Quadrana":19803,"Func":19804,"dy":19805,"photograph":19806,"lob":19807,"speeded":19808,"vars":19809,"Aspects":19810,"browsing":19811,"requesting":19812,"conference":19813,"Aly":19814,"1800012997":19815,"tariffs":19816,"meta":19817,"7969":19818,"orderly":19819,"2010s":19820,"resort":19821,"code":19822,"KIF":19823,"discretization":19824,"immigration":19825,"lawsuit":19826,"1937":19827,"0.129":19828,"6580":19829,"§":19830,"Warranty":19831,"Jagerman":19832,"1057":19833,"supported":19834,"descrip":19835,"Eck":19836,"029":19837,"downgrade":19838,"prescribe":19839,"reordering":19840,"市场":19841,"Rachel":19842,"10533":19843,"Series":19844,"41":19845,"dizzying":19846,"staffed":19847,"marization":19848,"qualifies":19849,"faithful":19850,"1929":19851,"apparel":19852,"Œ":19853,"executing":19854,"administering":19855,"Rae":19856,"200":19857,"elevate":19858,"rings":19859,"hunches":19860,"9131":19861,"quaternions":19862,"273":19863,"butions":19864,"D1":19865,"manufacture":19866,"interdependency":19867,"km":19868,"nuanced":19869,"Emerging":19870,"follow":19871,"wall":19872,"clich":19873,"going":19874,"terminates":19875,"immune":19876,"事项":19877,"Elsken":19878,"denoting":19879,"AdaGrad":19880,"chmod":19881,"cide":19882,"Pioneering":19883,"B.7":19884,"smoothly":19885,"vqa":19886,"g2":19887,"Macready":19888,"subfield":19889,"delivering":19890,"imposing":19891,"provider":19892,"Fundamentals":19893,"002":19894,"4060":19895,"Prize":19896,"pcm":19897,"0.010599":19898,"payout":19899,"simulating":19900,"Lynn":19901,"Breaches":19902,"419":19903,"7539":19904,"Seeger":19905,"Alterna":19906,"maximization":19907,"matical":19908,"accounts":19909,"variations":19910,"amplifiers":19911,"Assumption":19912,"areas1":19913,"至":19914,"0.485":19915,"USPS":19916,"example":19917,"Alayrac":19918,"huddling":19919,"callable":19920,"freely":19921,"wiggliness":19922,"attribute":19923,"Experimental":19924,"Guestrin":19925,"Palo":19926,"sudo":19927,"Amd":19928,"overcome":19929,"transla":19930,"157":19931,"Turbo":19932,"storage":19933,"qbaza":19934,"Uc":19935,"08377":19936,"disproportionately":19937,"ahead":19938,"BasicBlock":19939,"ReTraCk":19940,"taxonomy":19941,"plugging":19942,"propose":19943,"pronouncements":19944,"Hussien":19945,"Leon":19946,"unk":19947,"Parthe":19948,"discrep":19949,"augmenting":19950,"Pharmaceuticals":19951,"spread":19952,"Kung":19953,"AIS":19954,"init":19955,"but":19956,"Xiao":19957,"664848":19958,"pioneer":19959,"ushered":19960,"ition":19961,"citation":19962,"chains":19963,"mention":19964,"haustive":19965,"mal":19966,"statutory":19967,"secret":19968,"ative":19969,"agenda":19970,"reading":19971,"impaired":19972,"consolidated":19973,"727":19974,"asking":19975,"Rodol":19976,"Bentley":19977,"dated":19978,"Du":19979,"Discussions284":19980,"909":19981,"051":19982,"factory":19983,"Eshelman204":19984,"truncation":19985,"interim":19986,"Markovitz":19987,"cepting":19988,"Perceptron":19989,"repetitively":19990,"二季":19991,"Automatic":19992,"nums":19993,"occurrence":19994,"aligned":19995,"Antonoglou":19996,"600W":19997,"Eratta":19998,"requested":19999,"T4":20000,"747":20001,"Fair":20002,"eight":20003,"nA":20004,"phrases":20005,"being":20006,"cocktail":20007,"rem":20008,"chance":20009,"ChatGPT":20010,"suppose":20011,"Searcher":20012,"Generating":20013,"practice":20014,"Name":20015,"startup":20016,"tics":20017,"physical":20018,"Classifier":20019,"24202494130424274":20020,"spurred":20021,"directories":20022,"forum":20023,"recurse":20024,"Integrals":20025,"10.5":20026,"emerge":20027,"Pro":20028,"prizes":20029,"investigate":20030,"vertically":20031,"decomposed":20032,"150%":20033,"Lisa":20034,"factorizes":20035,"RAP":20036,"objectivity":20037,"Granholm":20038,"autocom":20039,"BLOOM":20040,"Rombach":20041,"Neighborhoods":20042,"Randomly":20043,"Configuration":20044,"harmless":20045,"augmentation":20046,"tivation":20047,"commissioning":20048,"Raman":20049,"happens":20050,"beta":20051,"capable":20052,"Imagine":20053,"critical":20054,"reweigh":20055,"remiss":20056,"venture":20057,"nears":20058,"Ventures":20059,"overlaps":20060,"14198":20061,"Maas":20062,"filtering":20063,"tipping":20064,"Bol":20065,"analyzing":20066,"识别":20067,"cancellations":20068,"architecture":20069,"happened":20070,"minimizes":20071,"reporting":20072,"Availability":20073,"exert":20074,"spacing":20075,"weighs":20076,"kg":20077,"Ample":20078,"viation":20079,"adversarial":20080,"MixtureSameFamily":20081,"deadline":20082,"MLP":20083,"Epanechikov":20084,"happen":20085,"looked":20086,"xx":20087,"perturb":20088,"Huang":20089,"stationary":20090,"𝑐":20091,"advertising":20092,"𝜔":20093,"imitations":20094,"diamond":20095,"weighting":20096,"Z":20097,"Belongie":20098,"14403":20099,"uncertainties":20100,"Convex":20101,"Sennrich":20102,"ducing":20103,"minima":20104,"PositionWiseFFN":20105,"Dawn":20106,"Big":20107,"Innovation":20108,"Zhuang":20109,"est":20110,"Rahimi":20111,"Representations":20112,"unnecessary":20113,"codes":20114,"Deletion":20115,"restatements":20116,"foods":20117,"Internet":20118,"hypotheses":20119,"Jayaram":20120,"divergence":20121,"exempt":20122,"CSCO":20123,"launched":20124,"covar":20125,"Informatics":20126,"84":20127,"exciting":20128,"Resize":20129,"addresses":20130,"warnings":20131,"Wainwright":20132,"Partial":20133,"flowing":20134,"541":20135,"vo":20136,"dubious":20137,"workstation":20138,"ples":20139,"entrenching":20140,"minimizers":20141,"interchangeable":20142,"977":20143,"operands":20144,"squashing":20145,"standpoint":20146,"Discussions237":20147,"foundry":20148,"Quinlan":20149,"415":20150,"contrived":20151,"elle":20152,"0.8":20153,"Hendrycks":20154,"Tracking":20155,"coming":20156,"collection":20157,"Wiener":20158,"unwilling":20159,"Santos":20160,"148":20161,"11692":20162,"Batch":20163,"00e":20164,"𝑗":20165,"Dealer":20166,"diagnostics":20167,"Dense":20168,"trustworthy":20169,"Abdel":20170,"come":20171,"invent":20172,"Kwak":20173,"Guiding":20174,"Pitassi":20175,"hyperspectral":20176,"NLLLoss":20177,"Economics":20178,"¯":20179,"Sarto":20180,"ACE":20181,"alpha":20182,"ESAIM":20183,"flexibility":20184,"breaches":20185,"greenhouse":20186,"Chunked":20187,"Markowitz":20188,"robustly":20189,"gpg":20190,"Lewkowycz":20191,"zipfile":20192,"war":20193,"specific":20194,"furnished":20195,"Listen":20196,"13.5":20197,"Legendre":20198,"Generalization":20199,"CAL":20200,"unexpected":20201,"distinctive":20202,"head":20203,"assumes":20204,"RELATIONS":20205,"fmt":20206,"Chellappa":20207,"ScaleKernel":20208,"pedagogical":20209,"Relationships":20210,"happiness":20211,"be":20212,"139":20213,"FashionMNIST":20214,"最终":20215,"busy":20216,"tioning":20217,"Accountability":20218,"High":20219,"motivation":20220,"Multidimensional":20221,"Turk":20222,"256245":20223,"1894":20224,"shortcut":20225,"panel":20226,"Kasai":20227,"Victorri":20228,"Fiete":20229,"accounting":20230,"tilling":20231,"externally":20232,"amazonaws":20233,"izontally":20234,"HPC":20235,"Kullback":20236,"acknowledged":20237,"Ph":20238,"Estimate":20239,"suitable":20240,"concrete":20241,"chunking":20242,"logarithms":20243,"embrace":20244,"Î":20245,"tasks":20246,"35th":20247,"Selection":20248,"Partly":20249,"mistake":20250,"signifi":20251,"ABD":20252,"Classes":20253,"derived":20254,"42":20255,"beddings":20256,"surpassed":20257,"fabless":20258,"interviews":20259,"Sepp":20260,"sentations":20261,"principals":20262,"utilities":20263,"avenue":20264,"minimizer":20265,"plausibility":20266,"545":20267,"submission":20268,"8.8":20269,"Core":20270,"Estimates":20271,"gritty":20272,"dam":20273,"Haddow":20274,"Mean":20275,"Usually":20276,"footwear":20277,"2621":20278,"parentage":20279,"Adams":20280,"920":20281,"Rq":20282,"mary":20283,"delegated":20284,"entrepreneurs":20285,"NMT":20286,"matures":20287,"Britton":20288,"XWxh":20289,"AnyNetB":20290,"academic":20291,"num":20292,"apoints":20293,"1983":20294,"revolutionary":20295,"878":20296,"Inclusion":20297,"2.4018":20298,"732":20299,"parameterization":20300,"xr":20301,"param":20302,"readable":20303,"meat":20304,"deliberation":20305,"gathers":20306,"adapters":20307,"Hi":20308,"ural":20309,"ASHA":20310,"Lawsuits":20311,"evaluator":20312,"Fairness":20313,"Denker":20314,"from":20315,"240":20316,"ො":20317,"nextstate":20318,"security":20319,"Evgeniy":20320,"519":20321,"Embeddings":20322,"ken":20323,"engi":20324,"Publicly":20325,"Larochelle":20326,"difficulties":20327,"Flows":20328,"Bench":20329,"diversity":20330,"1th":20331,"2430":20332,"MDPs":20333,"VideoQA":20334,"10466":20335,"Recommendations":20336,"1007":20337,"shazbot":20338,"wikitext":20339,"Evaluating":20340,"Zeming":20341,"geomet":20342,"17070001363754272":20343,"Stopped":20344,"BERTModel":20345,"Incentive":20346,"Crandall":20347,"hoc":20348,"supplements":20349,"RandomColorJitter":20350,"Placeholder":20351,"Retrievegan":20352,"mental":20353,"soup":20354,"PURSUANT":20355,"ping":20356,"Customers":20357,"Xbox":20358,"Denote":20359,"simu":20360,"Presumably":20361,"Dover":20362,"Perez":20363,"5010":20364,"„":20365,"usefully":20366,"1495":20367,"SEP":20368,"imag":20369,"navigation":20370,"Discussions273":20371,"lawsuits":20372,"circle":20373,"BananasDataset":20374,"Oriented":20375,"piecewise":20376,"vastava":20377,"Discussions140":20378,"Discussions253":20379,"forfeitures":20380,"preparation":20381,"sigmoids":20382,"tained":20383,"Lilly":20384,"Using":20385,"+.":20386,"0.5253":20387,"volution":20388,"creditworthiness":20389,"418":20390,"hallucinations":20391,"unavailable":20392,"10347":20393,"AliPay":20394,"educator":20395,"outlined":20396,"advocate":20397,"keqing":20398,"spatio":20399,"sorted":20400,"canceling":20401,"lambd":20402,"libraries":20403,"studentT":20404,"Pe":20405,"commonplace":20406,"honest":20407,"certification":20408,"Included":20409,"resentations":20410,"Beutel":20411,"BERTEncoder":20412,"Certain":20413,"451":20414,"diagnose":20415,"gated":20416,"Python":20417,"pora":20418,"trustee":20419,"unapproved":20420,"100359":20421,"Remainder":20422,"Talwalkar":20423,"019823425532533637":20424,"Start":20425,"experienced":20426,"find":20427,"redesigned":20428,"dominated":20429,"00%":20430,"Iris":20431,"socket":20432,"tossed":20433,"Interactive":20434,"accomplishing":20435,"subscriptions":20436,"visualized":20437,"garbage":20438,"H":20439,"tion":20440,"Rainier":20441,"icient":20442,"reimburse":20443,"Kwasny":20444,"Hamilton":20445,"rejects":20446,"inbuilt":20447,"Oxford":20448,"changing":20449,"9.5":20450,"versatility":20451,"lockdowns":20452,"1Whz":20453,"Alyafeai":20454,"rigor":20455,"0.8218":20456,"cos":20457,"Guo":20458,"preferably":20459,"1960":20460,"engaging":20461,"recommending":20462,"Journal":20463,"0058":20464,"periods":20465,"8047":20466,"hashtag":20467,"enacted":20468,"post57":20469,"uphold":20470,"disaggregation":20471,"pretend":20472,"protecting":20473,"heytitle":20474,"hugging":20475,"2524":20476,"2951":20477,"2021":20478,"entirety":20479,"2025":20480,"Bach":20481,"Billions":20482,"y":20483,"consis":20484,"paral":20485,"stringent":20486,"Experience":20487,"baked":20488,"Reviews":20489,"profiler":20490,"340":20491,"1940":20492,"chat":20493,"metaverse":20494,"incorpo":20495,"deriving":20496,"currency":20497,"W":20498,"forum2":20499,"2322":20500,"Fisher":20501,"Yang":20502,"1e6":20503,"786":20504,"9099":20505,"indemnifications":20506,"Casper":20507,"Automatically":20508,"1037":20509,"brevity":20510,"𝜼":20511,"458":20512,"clip":20513,"∇":20514,"quo":20515,"coefficient":20516,"长以":20517,"triplet":20518,"iterative":20519,"1980":20520,"consoles":20521,"funding":20522,"protections":20523,"prob":20524,"geopolitical":20525,"supreme":20526,"eponymously":20527,"indirectly":20528,"maximizes":20529,"airplanes":20530,"Unless":20531,"incredible":20532,"4151":20533,"sults":20534,"Los":20535,"rst":20536,"Are":20537,"Reported":20538,"inforcement":20539,"prototypes":20540,"experiment":20541,"competitors":20542,"simplest":20543,"indemnity":20544,"2109":20545,"SIBAS":20546,"1512":20547,"Patterson":20548,"bone":20549,"Gradient":20550,"2003":20551,"WikiTextDataset":20552,"incorporates":20553,"Subsidiaries":20554,"prepa":20555,"prepares":20556,"Stability":20557,"icsdelivery":20558,"enviroment":20559,"returns":20560,"1459":20561,"SHA":20562,"shorter":20563,"Infomatique":20564,"Ranges":20565,"Cortex":20566,"attractive":20567,"monetize":20568,"1e4":20569,"tangent":20570,"blocks":20571,"connoisseur":20572,"Small":20573,"SN":20574,"extrapolate":20575,"Beethoven":20576,"Forward":20577,"synthesizes":20578,"longest":20579,"delimited":20580,"Pinto":20581,"tradition":20582,"affect":20583,"ending":20584,"Entailment":20585,"ijk":20586,"Gaussian":20587,"perplexingly":20588,"count":20589,"possessive":20590,"Gaosheng":20591,"Federal":20592,"898":20593,"suis":20594,"60":20595,"Flora":20596,"ornithology":20597,"Alleva":20598,"BY":20599,"intention":20600,"sha1":20601,"lo":20602,"falling":20603,"Dai":20604,"ISCA":20605,"decod":20606,"dual":20607,"Semi":20608,"Continuity":20609,"excluding":20610,"Reshape":20611,"PRESENTS":20612,"异常":20613,"039":20614,"ref":20615,"restructuring":20616,"disruptions":20617,"abstraction":20618,"compliance":20619,"slope":20620,"n":20621,"Ilya":20622,"asynchronously":20623,"defaultdict":20624,"invariant":20625,"spin":20626,"introduce":20627,"xc":20628,"minimum":20629,"for":20630,"significantly":20631,"NVLINK":20632,"conv1":20633,"sitting":20634,"structions":20635,"k1":20636,"additionally":20637,"initializer":20638,"xix":20639,"924182":20640,"within":20641,"pair":20642,"79%":20643,"merit":20644,"Rajpurkar":20645,"13461":20646,"parallelizing":20647,"1000W":20648,"ularization":20649,"IEE":20650,"scarcity":20651,"Fundamentally":20652,"Nsight186":20653,"Tangarajan":20654,"task":20655,"Principal":20656,"car":20657,"certifications":20658,"exponentials":20659,"1430":20660,"Peking":20661,"phenomena":20662,"lkevinzc":20663,"Gaming":20664,"strength":20665,"Wxo":20666,"relatively":20667,"SPARQL":20668,"0.000066":20669,"putes":20670,"ASCII":20671,"edited":20672,"held":20673,"adapted":20674,"uptime":20675,"Ethereum":20676,"up":20677,"percentile":20678,"Procedures":20679,"Nes":20680,"economists":20681,"database":20682,"&&":20683,"displays":20684,"pretended":20685,"00001":20686,"lazy":20687,"North":20688,"Humans":20689,"Wen":20690,"tracked":20691,"archaic":20692,"NA":20693,"realize":20694,"":20695,"misconception":20696,"Raptor":20697,"顺序":20698,"9734":20699,"Multiplying":20700,"1003":20701,"heavy":20702,"companies":20703,"3f":20704,"Discussions282":20705,"strong":20706,"⪅":20707,"unambiguously":20708,"eigensystem":20709,"Bioinformatics":20710,"official":20711,"Ex":20712,"ng":20713,"partly":20714,"am":20715,"transpired":20716,"8287":20717,"Parameters":20718,"Distill1":20719,"competing":20720,"Lapata":20721,"lie":20722,"164":20723,"depreciated":20724,"Discussions173":20725,"debate":20726,"⪰":20727,"specially":20728,"template":20729,"dimensions":20730,"Bayesian":20731,"explicitly":20732,"Very":20733,"SH":20734,"Discussions144":20735,"approximations":20736,"Í":20737,"typified":20738,"103":20739,"defers":20740,"champagne":20741,"determines":20742,"vN":20743,"amend":20744,"Curious":20745,"FURNISHED":20746,"worthwhile":20747,"104831":20748,"assem":20749,"emulation":20750,"mips":20751,"Files":20752,"Keys":20753,"diversifying":20754,"useful":20755,"concatenating":20756,"Subbiah":20757,"alternatives":20758,"pairings":20759,"EMB":20760,"intersect":20761,"simplifying":20762,"versa":20763,"23":20764,"012271":20765,"Output":20766,"promoting":20767,"110":20768,"Confidence":20769,"FirstEnergy":20770,"chairpersons":20771,"plaguing":20772,"fication":20773,"73%":20774,"SMOLA":20775,"Scalable":20776,"culprit":20777,"Goh":20778,"25X":20779,"Jordan":20780,"2110":20781,"feasible":20782,"eral":20783,"impossibility":20784,"parts":20785,"kits":20786,"valued":20787,"10022":20788,"deci":20789,"Filtering":20790,"bathrooms":20791,"cryptocurrency":20792,"Cosine":20793,"fiduciary":20794,"ternary":20795,"approximate":20796,"611":20797,"ementwise":20798,"Exploding":20799,"Diffusion":20800,"Keep":20801,"perparameter":20802,"kinks":20803,"astute":20804,"Such":20805,"Evaluation":20806,"substituting":20807,"alternate":20808,"armed":20809,"condense":20810,"outset":20811,"measurements":20812,"nbextensions":20813,"6b":20814,"588":20815,"subtraction":20816,"underneath":20817,"reforms":20818,"Fash":20819,"ransomware":20820,"ndim":20821,"1c":20822,"Geopolitical":20823,"surge":20824,"advised":20825,"LogNormal":20826,"mirrored":20827,"elements":20828,"alleviates":20829,"decomposing":20830,"catalyst":20831,"pioneering":20832,"Trier":20833,"A.4":20834,"Discussions80":20835,"Rafael":20836,"impacting":20837,"Parzen":20838,"associated":20839,"mountains":20840,"Situations":20841,"Weld":20842,"ecosystems":20843,"Indyk":20844,"internally":20845,"dollar":20846,"predictable":20847,"added":20848,"deliberate":20849,"4510":20850,"Arts":20851,"dataset":20852,"remove":20853,"cates":20854,"arange":20855,"thir":20856,"wzr":20857,"resists":20858,"slowly":20859,"comfortable":20860,"Coins":20861,"03184":20862,"McConchie":20863,"assistant":20864,"index":20865,"Birch":20866,"≡":20867,"years":20868,"Efficient":20869,"infoNCE":20870,"Retrievers":20871,"sustaining":20872,"2406":20873,"Dif":20874,"guesses":20875,"was":20876,"earliest":20877,"tag":20878,"228":20879,"clusters":20880,"插入":20881,"able":20882,"Hartley":20883,"973":20884,"Interpublic":20885,"181":20886,"jjangga0214":20887,"lengthscale":20888,"Basic":20889,"25300":20890,"Deshmukh":20891,"torch":20892,"stunning":20893,"milestones":20894,"ValueError":20895,"Weibull":20896,"returnable":20897,"did":20898,"East":20899,"designing":20900,"3232":20901,"Floating":20902,"iStock":20903,"entiation":20904,"easy":20905,"contemplate":20906,"Stanford":20907,"reliably":20908,"noring":20909,"Issuer":20910,"is":20911,"prehensive":20912,"webcasts":20913,"1503420":20914,"2106":20915,"notions":20916,"2042040":20917,"Apache":20918,"results":20919,"operator":20920,"512":20921,"会":20922,"Marsel":20923,"kaggle":20924,"201":20925,"go":20926,"596":20927,"changer":20928,"Decreasing":20929,"Tieleman":20930,"Wxz":20931,"pa":20932,"RLRC":20933,"consists":20934,"RMSprop":20935,"univariate":20936,"SVG":20937,"Riverside":20938,"Connectivity":20939,"judgement":20940,"winning":20941,"124003":20942,"augmenta":20943,"dinosaur":20944,"sensors":20945,"Matrices":20946,"complaints":20947,"web":20948,"fulfillment":20949,"terrorism":20950,"practitioner":20951,"01ada507287d82875905620988597833ad4e0903":20952,"Su":20953,"IGX":20954,"行":20955,"customize":20956,"503":20957,"allegedly":20958,"they":20959,"centerpiece":20960,"tlenecks":20961,"reliance":20962,"cockpit":20963,"Washington":20964,"beyond":20965,"yaxis":20966,"A.37":20967,"outline":20968,"Eight":20969,"decidedly":20970,"houses":20971,"Provisions":20972,"triggered":20973,"mouill":20974,"Tri":20975,"Rastogi":20976,"Hawaiian":20977,"delivers":20978,"Special":20979,"parser":20980,"chief":20981,"Modern":20982,"diagonal":20983,"plau":20984,"outermost":20985,"appointed":20986,"natu":20987,"team":20988,"occasion":20989,"condition":20990,"Urtasun":20991,"enhancing":20992,"GILTI":20993,"crashing":20994,"72":20995,"subnet":20996,"Heess":20997,"telecom":20998,"titions":20999,"overflow":21000,"strip":21001,"consecutive":21002,"cause":21003,"inability":21004,"StickBreakingTransform":21005,"Almost":21006,"ARKS":21007,"retrievals":21008,"9249":21009,"posing":21010,"predict":21011,"drastically":21012,"12.7":21013,"ideling":21014,"spent":21015,"RealSoftMax":21016,"Simulation":21017,"crucially":21018,"cifar10":21019,"undone":21020,"Hoos":21021,"needles":21022,"0277":21023,"yields":21024,"Hagstr":21025,"spatiotemporal":21026,"€":21027,"5785":21028,"88":21029,"0":21030,"Discussions277":21031,"1034":21032,"098":21033,"Send":21034,"makes":21035,"670":21036,"modern":21037,"fiscal":21038,"ow":21039,"CAP":21040,"improv":21041,"图表":21042,"ological":21043,"Rowland":21044,"forfeiture":21045,"slightly":21046,"Druzhinin":21047,"inexpensive":21048,"bench":21049,"preconfig":21050,"Discussions292":21051,"occur":21052,"graphics":21053,"Discussions105":21054,"ruled":21055,"gemini":21056,"earlier":21057,"direc":21058,"933":21059,"样式":21060,"chess":21061,"DenseNet":21062,"Shampoo":21063,"wavy":21064,"Operations":21065,"Neutral":21066,"optimizers":21067,"implications":21068,"annotated":21069,"politics":21070,"0.4651":21071,"encryption":21072,"constructing":21073,"Supreme":21074,"chitecture":21075,"UP":21076,"1.2275":21077,"prediction":21078,"interview":21079,"gurations":21080,"obtainable":21081,"officer":21082,"magic":21083,"为":21084,"A.17":21085,"elected":21086,"borrowing":21087,"HLT":21088,"lent":21089,"prevent":21090,"edit":21091,"Mount":21092,"08402":21093,"www":21094,"015":21095,"610":21096,"those":21097,"shop":21098,"smaller":21099,"1988":21100,"Strang":21101,"文档":21102,"timeframe":21103,"Or":21104,"historical":21105,"constructed":21106,"shuffling":21107,"cat1":21108,"couple":21109,"TKEGEN":21110,"SPECIFICALLY":21111,"generally":21112,"beauty":21113,"overfill":21114,"4783":21115,"Koh":21116,"contributes":21117,"twenty":21118,"Applications":21119,"Windows":21120,"cheaply":21121,"295":21122,"cific":21123,"confidences":21124,"Fumagalli":21125,"didactic":21126,"bn4":21127,"Nimes":21128,"thank":21129,"Visin":21130,"sification":21131,"calc":21132,"Discussions85":21133,"tioners":21134,"Chiao":21135,"prefilter":21136,"Year":21137,"eng":21138,"philosophies":21139,"preter":21140,"7870":21141,"disclosure":21142,"contracted":21143,"Pittsburgh":21144,"attempt":21145,"Vapnik":21146,"APICoder":21147,"Cornell":21148,"风景图":21149,"Didot":21150,"horse":21151,"Buchatskaya":21152,"mentioning":21153,"aircraft":21154,"PROCESSING":21155,"spective":21156,"Quanshangze":21157,"Schmidhuber":21158,"Greek":21159,"Mechanisms":21160,"covs":21161,"Ronald":21162,"nents":21163,"Andrei":21164,"standardize":21165,"ceive":21166,"411":21167,"ndez":21168,"Jobs":21169,"XPENG":21170,"gous":21171,"tiply":21172,"3TG":21173,"persisted":21174,"Ward":21175,"Operator":21176,"Wqh":21177,"DATACENTERS":21178,"call":21179,"ply":21180,"办公椅":21181,"evidence":21182,"activities":21183,"中":21184,"Insights":21185,"savings":21186,"2794":21187,"nonparametric":21188,"Characterizing":21189,"Conv2D":21190,"790":21191,"Neumann":21192,"laws":21193,"052":21194,"sci":21195,"TanhTransform":21196,"1070":21197,"subvert":21198,"nadaraya":21199,"motivating":21200,"Construct":21201,"UgurKap":21202,"Denoising":21203,"weights":21204,"chez":21205,"notebook":21206,"steepest":21207,"Wojna":21208,"conferring":21209,"exponentiated":21210,"CCPA":21211,"resemblance":21212,"hole":21213,"nition":21214,"conceptually":21215,"Hubbard":21216,"determiner":21217,"mimicking":21218,"5193e":21219,"Precisely":21220,"Sheets":21221,"astype":21222,"caring":21223,"often":21224,"xlabel":21225,"08073":21226,"Rich":21227,"drives":21228,"Build":21229,"improve":21230,"legislation":21231,"07883":21232,"Uelwer":21233,"ConvTranspose2d":21234,"human":21235,"Parikh":21236,"2440":21237,"DRELL":21238,"adadelta":21239,"1977":21240,"zlim":21241,"Licenses":21242,"opera":21243,"Discussions286":21244,"rea":21245,"Rajeswaran":21246,"ell":21247,"neurophysiology":21248,"tribution":21249,"simonwardjones":21250,"393":21251,"Payouts":21252,"contents":21253,"ingest":21254,"obviating":21255,"Restart":21256,"fortunes":21257,"ing":21258,"hooks":21259,"noses":21260,"workable":21261,"pronounced":21262,"game252":21263,"allocat":21264,"residuals":21265,"Process":21266,"nms":21267,"heck":21268,"Graphs":21269,"第二节":21270,"ular":21271,"0740":21272,"annotation":21273,"nest":21274,"Just":21275,"epanechikov":21276,"tributed":21277,"270000":21278,"1.3":21279,"suffer":21280,"Server":21281,"POS":21282,"Topic":21283,"foundations":21284,"1024":21285,"319d85e578af0cdc590547f26231e4e31cdf1e42":21286,"lifted":21287,"Default":21288,"competitions":21289,"yellow":21290,"arXiv":21291,"3%":21292,"definite":21293,"9135":21294,"Hyperion":21295,"cannot":21296,"276":21297,"generically":21298,"duce":21299,"glass":21300,"orthogonal":21301,"unchanged":21302,"04487":21303,"00019":21304,"mouth":21305,"rewritten":21306,"occluded":21307,"425":21308,"incurred":21309,"mlm":21310,"reuse":21311,"Competencies":21312,"4070":21313,"Pre":21314,"≤":21315,"hour":21316,"2.5":21317,"controllable":21318,"15604":21319,"799":21320,"05377":21321,"M60":21322,"resubstitution":21323,"receive":21324,"outsides":21325,"Siri":21326,"Paliwal":21327,"Curve":21328,"Activerag":21329,"heuristic":21330,"1C":21331,"Easy":21332,"Oversees":21333,"Division":21334,"sigma":21335,"obj":21336,"Football":21337,"commence":21338,"2265":21339,"indispensable":21340,"airfoil":21341,"Miglani":21342,"core":21343,"positionwise":21344,"economical":21345,"Architecture":21346,"999":21347,"1963":21348,"idling":21349,"869":21350,"Paulus":21351,"schema":21352,"try":21353,"lays":21354,"GENOMICS":21355,"823":21356,"13971":21357,"amplify":21358,"hindsight":21359,"Minimizing":21360,"0.007188":21361,"gaining":21362,"critically":21363,"Tintri":21364,"899983":21365,"job":21366,"ASC":21367,"undemanding":21368,"denominator":21369,"ultra":21370,"Stochastic":21371,"About":21372,"immaterial":21373,"impediment":21374,"Optics":21375,"COLING":21376,"auditing":21377,"pass":21378,"mylaptop":21379,"worry":21380,"40th":21381,"Determine":21382,"SuperNIC":21383,"Re2Com":21384,"codet5":21385,"cisco":21386,"Repository":21387,"02966":21388,"dilemmas":21389,"Comput":21390,"Proceeds":21391,"Discussions229":21392,"Imagen":21393,"growing":21394,"quarterly":21395,"Sequen":21396,"numer":21397,"encompassing":21398,"Rerun":21399,"draw":21400,"activa":21401,"opt":21402,"pleasing":21403,"transact":21404,"ExactGPModel":21405,"lab":21406,"1079":21407,"Discussions167":21408,"einsum":21409,"Retrack":21410,"html":21411,"portion":21412,"hishek":21413,"OmniTab":21414,"265":21415,"grow":21416,"Booz":21417,"mark":21418,"overcoming":21419,"knock":21420,"698":21421,"trading":21422,"symbolically":21423,"dwarfed":21424,"tutorial269":21425,"11.9":21426,"Preprocessing":21427,"classifier":21428,"QOS":21429,"068":21430,"Reblitz":21431,"0.3537":21432,"numerical":21433,"highlighting":21434,"笔记":21435,"liberating":21436,"Intervals":21437,"definitions":21438,"broadcasters":21439,"Problematically":21440,"tting":21441,"nAI":21442,"swapaxes":21443,"logarithmically":21444,"resolve":21445,"[":21446,"Yorkshire":21447,"library45":21448,"loss":21449,"xxxi":21450,"Backgammon":21451,"leftward":21452,"terested":21453,"equa":21454,"9204":21455,"Transformer":21456,"resellers":21457,"host":21458,"114":21459,"xAI":21460,"mathematics":21461,"integrator":21462,"plaintiffs":21463,"lying":21464,"seq2seq":21465,"Halving":21466,"𝝓":21467,"brief":21468,"0.2353":21469,"hinges":21470,"accurately":21471,"option":21472,"GWM":21473,"yield":21474,"truncates":21475,"invok":21476,"recognizes":21477,"Conventionally":21478,"tences":21479,"ALBERT":21480,"persons":21481,"Hamid":21482,"Envy":21483,"secondary":21484,"Certificates":21485,"forced":21486,"901730":21487,"Thai":21488,"corr":21489,"lobbying":21490,"给":21491,"deferred":21492,"rameters":21493,"parallelization":21494,"sped":21495,"sandal":21496,"%%":21497,"uninterpretable":21498,"trig":21499,"contact":21500,"584%":21501,"581":21502,"investigations":21503,"Drain":21504,"9352":21505,"992":21506,"unla":21507,"Urbana":21508,"calculating":21509,"encountered":21510,"defaulting":21511,"ho":21512,"583":21513,"上":21514,"98%":21515,"avinashingit":21516,"Discussions121":21517,"Concrete":21518,"X":21519,"Troubling":21520,"generic":21521,"Developments":21522,"é":21523,"846":21524,"2.8314":21525,"misestimated":21526,"These":21527,"doctorcolossus":21528,"603":21529,"Overlooking":21530,"toronto":21531,"encouraged":21532,"dimensional":21533,"toolkit":21534,"Rover":21535,"纯":21536,"13G":21537,"Amount":21538,"115":21539,"^":21540,"enjoys":21541,"adopted":21542,"SelectBackward0":21543,"objective":21544,"Luong":21545,"nutshell":21546,"Corp":21547,"Long":21548,"reactively":21549,"caojilin":21550,"Askell":21551,"neces":21552,"prepared":21553,"Methodologies":21554,"relegated":21555,"Goldman":21556,"127":21557,"rnn":21558,"inds":21559,"minibatch":21560,"1066":21561,"exponent":21562,"spinning":21563,"Josiah":21564,"Volume":21565,"3.7":21566,"machine":21567,"inconsistency":21568,"Deduct":21569,"pushed":21570,"likes":21571,"activated":21572,"Repocoder":21573,"STOCKHOLDERS":21574,"Nonstationary":21575,"behaving":21576,"survive":21577,"INFO":21578,"unimaginable":21579,"stranger":21580,"1865e":21581,"Recognizing":21582,"research":21583,"coauthors":21584,"social":21585,"discretionary":21586,"pitfall":21587,"Option":21588,"governs":21589,"Micro":21590,"408":21591,"Macromedia":21592,"correspon":21593,"Nick":21594,"filling":21595,"Teh":21596,"supercomputing":21597,"requirements":21598,"uniform":21599,"Automata":21600,"charleybeller":21601,"union":21602,"W2":21603,"begun":21604,"embark":21605,"described":21606,"Aggregating":21607,"dancing":21608,"defer":21609,"2394":21610,"knowledge":21611,"gz":21612,"Blattmann":21613,"2798":21614,"ConceptFlow":21615,"产品名":21616,"516":21617,"pipes":21618,"PERSONS":21619,"Brands":21620,"Goldberg":21621,"1231e":21622,"Õ":21623,"ceedings":21624,"ball":21625,"disappears":21626,"shifted":21627,"amounted":21628,"intends":21629,"half":21630,"production":21631,"leaked":21632,"provements":21633,"Cher":21634,"Commission":21635,"prevented":21636,"Compilers":21637,"configurators":21638,"suc":21639,"inal":21640,"lifecycle":21641,"taxes":21642,"necessity":21643,"Experiment":21644,"creased":21645,"整个":21646,"218":21647,"Doctoral":21648,"disturbing":21649,"approx":21650,"violence":21651,"World":21652,"Plugging":21653,"randomization":21654,"安全":21655,"LogisticNormal":21656,"synchronizing":21657,"compositionality":21658,"inscribe":21659,"Experi":21660,"formulated":21661,"flow":21662,"05941":21663,"pioneers":21664,"gpu2":21665,"torized":21666,"649":21667,"Owners":21668,"three":21669,"Optimal":21670,"composes":21671,"instructs":21672,"compiled":21673,"tried":21674,"are":21675,"deactivate":21676,"Δ":21677,"497":21678,"Death":21679,"SENets":21680,"Prove":21681,"bester":21682,"Blended":21683,"giving":21684,"Ramos":21685,"retrieve":21686,"street":21687,"queued":21688,"1051":21689,"Clean":21690,"593":21691,"sentiment":21692,"Parallelization":21693,"characteristics":21694,"Hashimoto":21695,"faulty":21696,"1500000":21697,"Unif":21698,"A.47":21699,"Asia":21700,"Driessche":21701,"productivity":21702,"mapped":21703,"wrangle":21704,"TransformerEncoder":21705,"following":21706,"Sticking":21707,"09":21708,"probab":21709,"3922":21710,"692":21711,"sneaker":21712,"equiv":21713,"1673":21714,"withholding":21715,"RAPTOR":21716,"smartest":21717,"small":21718,"Structgpt":21719,"blocked":21720,"commercially":21721,"Intell":21722,"iteratively":21723,"hat":21724,"Imaging":21725,"Schmidt":21726,"Tangent":21727,"Stakeholders":21728,"Vectorization":21729,"Counsel":21730,"compressing":21731,"avail":21732,"bool":21733,"edgarro":21734,"biologists":21735,"GB200":21736,"026036":21737,"participant":21738,"additional":21739,"1610":21740,"Baby":21741,"Natural":21742,"merically":21743,"minimization":21744,"120":21745,"Discussions146":21746,"SEC":21747,"age":21748,"slid":21749,"approximator":21750,"told":21751,"Elkan":21752,"charitable":21753,"Discussions18":21754,"relate":21755,"𝜏":21756,"grammatical":21757,"laptops":21758,"Head":21759,"dations":21760,"Francisco":21761,"Conse":21762,"Statistics":21763,"Summarization":21764,"christabella":21765,"Inability":21766,"Grover":21767,"depicts":21768,"tradi":21769,"nontrivial":21770,"hiding":21771,"简单":21772,"shift":21773,"0.00036":21774,"possibly":21775,"ness":21776,"...":21777,"decoded":21778,"mushroom":21779,"ö":21780,"Consistent":21781,"Deductions":21782,"Martinet":21783,"AveragePooling":21784,"140000":21785,"4695":21786,"portfolios":21787,"Pooling":21788,"Gluon":21789,"workforce":21790,"trajecto":21791,"statistically":21792,"Quantenna":21793,"named":21794,"negation":21795,"prepara":21796,"distort":21797,"charter":21798,"nonstationary":21799,"fabricated":21800,"Complicating":21801,"Values":21802,"preferences":21803,"923":21804,"statements":21805,"trace":21806,"groundbreaking":21807,"Abstentions":21808,"Time":21809,"checkpoints":21810,"𝐺":21811,"Adjusting":21812,"binom":21813,"TIARA":21814,"obvious":21815,"Lian":21816,"SPARCStation":21817,"Init":21818,"perturbed":21819,"958":21820,"cen":21821,"compute":21822,"drove":21823,"TXN":21824,"sharp":21825,"Akiki":21826,"firm":21827,"Means":21828,"Advancements":21829,"pullover":21830,"steinsag":21831,"mild":21832,"Fern":21833,"trulens":21834,"physically":21835,"gives":21836,"Tiep":21837,"416":21838,"03888":21839,"pal":21840,"excellent":21841,"breed":21842,"newer":21843,"Benton":21844,"infringe":21845,"08207":21846,"Wallace":21847,"point":21848,"maybe":21849,"paradigm":21850,"purges":21851,"PPL":21852,"31%":21853,"fleet":21854,"tightly":21855,"doc1":21856,"generate":21857,"let":21858,"anticipate":21859,"Directors":21860,"actions":21861,"vested":21862,"4830":21863,"ë":21864,"Letting":21865,"sian":21866,"exceptions":21867,"rolling":21868,"facto":21869,"0709":21870,"lucky":21871,"bandits":21872,"perdu":21873,"affairs":21874,"Omnivore":21875,"barber":21876,"Shutterstock":21877,"holistic":21878,"Release":21879,"beta2":21880,"tuner":21881,"eligible":21882,"λ":21883,"Anthony":21884,"595":21885,"xscale":21886,"Vgnmn":21887,"unsupervised":21888,"openai":21889,"idles":21890,"Kingdom":21891,"nlp":21892,"warranties":21893,"Verilog":21894,"此行":21895,"ern":21896,"CED":21897,"winter":21898,"q1":21899,"categorizing":21900,"Whang":21901,"409A":21902,"757":21903,"Hayati":21904,"con":21905,"Counterfactual":21906,"𝜕":21907,"Konstan":21908,"1x1":21909,"encourage":21910,"synthesis":21911,"biject":21912,"tied":21913,"prog":21914,"inter":21915,"Strategic":21916,"recalibrate":21917,"288":21918,"avatar":21919,"responsibilities":21920,"emerging":21921,"CorrDiff":21922,"Dropbox":21923,"excludes":21924,"like":21925,"restarting":21926,"prod":21927,"590407":21928,"paper":21929,"Discrepancies":21930,"Nikravesh":21931,"Interest":21932,"100GbE":21933,"powered":21934,"February":21935,"np":21936,"histogram":21937,"subtensor":21938,"0.012":21939,"suffice":21940,"forgoes":21941,"ssurvey":21942,"explosive":21943,"toy":21944,"20383":21945,"Inspired":21946,"Master":21947,"enters":21948,"honor":21949,"Oliver":21950,"Discussions120":21951,"Radial":21952,"superpositions":21953,"400":21954,"GenTKGQA":21955,"Create":21956,"Uniform":21957,"suggesting":21958,"restated":21959,"Representa":21960,"executes":21961,"cent":21962,"employs":21963,"Asadi":21964,"621":21965,"signature":21966,"\b":21967,"pu":21968,"causally":21969,"significant":21970,"Markdown":21971,"outlines":21972,"tempting":21973,"various":21974,"ZACHARY":21975,"localities":21976,"elaborate":21977,"distinctions":21978,"Manufacturer":21979,"evry":21980,"define":21981,"when":21982,"governed":21983,"701":21984,"unfair":21985,"𝑟":21986,"yann":21987,"coreference":21988,"991":21989,"assessments":21990,"Agent":21991,"leans":21992,"Laplace":21993,"mat":21994,"945":21995,"we":21996,"Gupta":21997,"Survey":21998,"arriving":21999,"stuck":22000,"15217":22001,"iterate":22002,"rnns":22003,"FTIR":22004,"CDFs":22005,"shut":22006,"convnet127":22007,"Agrawal":22008,"exposition":22009,"MSZoning":22010,"2993874715754653":22011,"committed":22012,"coordinating":22013,"PIL":22014,"136":22015,"pursue":22016,"Input":22017,"Bluetooth":22018,"prevention":22019,"Plaintiffs":22020,"nels":22021,"filepath":22022,"qualifications":22023,"unsolvable":22024,"1765":22025,"special":22026,"pretty":22027,"clipped":22028,"Kaddour":22029,"cord":22030,"supercomputer":22031,"ligands":22032,"invoiced":22033,"constrained":22034,"similarity":22035,"formatted":22036,"1925":22037,"Plan":22038,"BMM":22039,"privacy":22040,"disribution":22041,"evolves":22042,"com":22043,"magazine":22044,"Object":22045,"EXPRESSWAY":22046,"ble":22047,"364757":22048,"Stolcke":22049,"Correctly":22050,"burgeoning":22051,"pretrain":22052,"11942":22053,"lease":22054,"slight":22055,"Skylake":22056,"minutes":22057,"increase":22058,"counsel":22059,"Xcode":22060,"consisted":22061,"mathe":22062,"eyeballed":22063,"synchronously":22064,"Vanguard":22065,"universe":22066,"step":22067,"GRAPE":22068,"afford":22069,"model90":22070,"0.9713101437890875":22071,"fillna":22072,"Care":22073,"era":22074,"colorbar":22075,"natively":22076,"processing":22077,"133":22078,"Mikolov":22079,"A.46":22080,"Plankalk":22081,"renaming":22082,"id":22083,"equals":22084,"trustees":22085,"shall":22086,"conversations":22087,"Trans":22088,"outpaced":22089,"carded":22090,"用户":22091,"goods":22092,"precondi":22093,"packages":22094,"memory":22095,"Devin":22096,"06940":22097,"Combination":22098,"travels":22099,"vs":22100,"zero":22101,"Scialom":22102,"Over":22103,"regional":22104,"Fold":22105,"Yuanxiang":22106,"unable":22107,"4013":22108,"DecomposableAttention":22109,"cors":22110,"Nishihara":22111,"0.4472":22112,"Gerson":22113,"deficient":22114,"Arabic":22115,"erally":22116,"8TB":22117,"suspect":22118,"initiates":22119,"Davis":22120,"inline":22121,"brain":22122,"2.4724":22123,"Simonyan":22124,"Representation":22125,"𝜋":22126,"historically":22127,"Lavril":22128,"Dayan":22129,"_%":22130,"Peter":22131,"Likely":22132,"Levonian":22133,"graphs":22134,"Partner":22135,"investor":22136,"leaking":22137,"LESS":22138,"perceptions":22139,"validate":22140,"Professional":22141,"1403":22142,"hurt":22143,"keyrings":22144,"implemented":22145,"\u0010":22146,"Connect":22147,"RAGAS":22148,"Satheesh":22149,"speeds":22150,"SVM":22151,"accordingly":22152,"Relations":22153,"strided":22154,"acquired":22155,"invaluable":22156,"Lakshya":22157,"routes":22158,"\u0011":22159,"FC":22160,"mathematician":22161,"Alto":22162,"Achilles":22163,"TSRs":22164,"strat":22165,"adjustments":22166,"realized":22167,"differentiating":22168,"dependent":22169,"wafers":22170,"important":22171,"0.1456":22172,"consultation":22173,"Tomas":22174,"movies":22175,"IEEE":22176,"met":22177,"desktop":22178,"promise":22179,"hires":22180,"Paper":22181,"hyperbolic":22182,"mathematical":22183,"law":22184,"60s":22185,"segmented":22186,"harmed":22187,"Mind":22188,"identifies":22189,"Utilizing":22190,"Approach":22191,"Wxf":22192,"forgo":22193,"name":22194,"calibrated":22195,"necessities":22196,"extremes":22197,"augmentations":22198,"Split":22199,"stabilize":22200,"𝜽":22201,"1996":22202,"ments":22203,"Investors":22204,"wa":22205,"redress":22206,"breakthrough":22207,"Selective":22208,"forming":22209,"cache":22210,"rewriting":22211,"data":22212,"penalizes":22213,"derlying":22214,"11916":22215,"Broadly":22216,"Estimation":22217,"Differ":22218,"":22219,"758829":22220,"NVDA2024":22221,"5846051207380589":22222,"Q2":22223,"Unearned":22224,"Discussions247":22225,"Brent":22226,"patrols":22227,"no":22228,"animal":22229,"predictive":22230,"narrower":22231,"observes":22232,"interpretations":22233,"Man":22234,"velocity":22235,"governmental":22236,"Rieck":22237,"downside":22238,"tunnel":22239,"dimen":22240,"5":22241,"generalizing":22242,"Saffari":22243,"0.107":22244,"pseudo":22245,"inheriting":22246,"recession":22247,"terconnects":22248,"atomic":22249,"theses":22250,"041":22251,"credits":22252,"tutorial7":22253,"commanded":22254,"profilers":22255,"hv2":22256,"Marcel":22257,"Siriwardhana":22258,"20170":22259,"secrets":22260,"Atari":22261,"inits":22262,"containers":22263,"llama":22264,"nitty":22265,"odd":22266,"tity":22267,"incorporation":22268,"Phoneme":22269,"scope":22270,"Keyboard":22271,"finances":22272,"spaces":22273,"Houlsby":22274,"Discourse":22275,"liquidity":22276,"18.1":22277,"962":22278,"File":22279,"79":22280,"red":22281,"conferences":22282,"possible":22283,"Inclusive":22284,"Nie":22285,"284":22286,"ascendence":22287,"bells":22288,"Rosenblatt":22289,"Soares":22290,"tax":22291,"differen":22292,"Prevent":22293,"Responsibilities":22294,"DataLoader":22295,"9793":22296,"terminate":22297,"symptoms":22298,"MBA":22299,"seamlessly":22300,"residents":22301,"logits":22302,"Robot":22303,"appending":22304,"Hinton":22305,"A.26":22306,"LlamaIndex":22307,"servers":22308,"Barak":22309,"scenes":22310,"Zhong":22311,"XW":22312,"0013":22313,"collectability":22314,"krahets":22315,"questionable":22316,"NetApp":22317,"PAYOUTS":22318,"05":22319,"663":22320,"1611.01578":22321,"remaining":22322,"AT&T":22323,"jour":22324,"coded":22325,"tackling":22326,"cial":22327,"va":22328,"0144":22329,"LowerCholeskyTransform":22330,"equipment":22331,"semantical":22332,"Differential":22333,"agation":22334,"mode":22335,"Al":22336,"gameplay":22337,"swim":22338,"statisticians":22339,"impact":22340,"premise":22341,"vices":22342,"3313":22343,"480":22344,"Betty":22345,"𝑓":22346,"enforc":22347,"environ":22348,"layer":22349,"recalling":22350,"resale":22351,"bilizes":22352,"功能":22353,"numpy":22354,"sofa":22355,"birds":22356,"objects":22357,"offsets":22358,"distinguish":22359,"ef":22360,"experimental":22361,"Guez":22362,"":22363,"R210":22364,"prior":22365,"door":22366,"smoother":22367,"flushed":22368,"Implications":22369,"144887":22370,"attainment":22371,"ü":22372,"multibox":22373,"xxxix":22374,"illustrating":22375,"LaySum":22376,"Restructuring":22377,"canyon":22378,"faster":22379,"generalist":22380,"ppl":22381,"body":22382,"1400":22383,"TOG":22384,"6":22385,"subgradient":22386,"recurrently":22387,"Schapire":22388,"decoupled":22389,"appearance":22390,"Type":22391,"quadratic":22392,"conversation":22393,"Discussions122":22394,"neutrality":22395,"programmable":22396,"outputting":22397,"­":22398,"Lyu":22399,"091":22400,"…":22401,"Furthermore":22402,"newest":22403,"049":22404,"Scribner":22405,"这里":22406,"Leg":22407,"Privacy":22408,"how":22409,"prune":22410,"Sandoz":22411,"flavor":22412,"Animate":22413,"ran":22414,"quota":22415,"mixer":22416,"Malkov":22417,"golden":22418,"usually":22419,"Articles":22420,"80%":22421,"dictatorial":22422,"susceptible":22423,"Santhanam":22424,"Lastly":22425,"articulated":22426,"salary":22427,"potential":22428,"SIGKDDg":22429,"readers307":22430,"result":22431,"200%":22432,"trieves":22433,"咖啡":22434,"marker":22435,"Elec":22436,"mattered":22437,"818":22438,"L1":22439,"york":22440,"3.91":22441,"capability":22442,"RBA":22443,"Binomial":22444,"Company":22445,"fairy":22446,"genetics":22447,"classic":22448,"149558":22449,"attracting":22450,"Critical":22451,"influence":22452,"classifica":22453,"separation":22454,"P3":22455,"3305":22456,"Horovod":22457,"underperforming":22458,"plentiful":22459,"correspondingly":22460,"allow":22461,"500":22462,"leverag":22463,"Contents":22464,"7.359":22465,"expenses":22466,"indicating":22467,"extractions":22468,"facilitate":22469,"lr":22470,"Go":22471,"Garipov":22472,"手机":22473,"gpyotrch":22474,"uneven":22475,"leverage":22476,"OCR":22477,"订单":22478,"471":22479,"Leviathan":22480,"0.160":22481,"60mm":22482,"calendar":22483," ":22484,"embodies":22485,"deciding":22486,"inquiry":22487,"dis":22488,"korean":22489,"49":22490,"529":22491,"Lockheed":22492,"智能":22493,"rotate":22494,"refines":22495,"GOALS":22496,"designer":22497,"sectors":22498,"Medal":22499,"5cm":22500,"lifecycles":22501,"cropping":22502,"guiding":22503,"penalty":22504,"noising":22505,"streaming":22506,"enter":22507,"achievement":22508,"orig":22509,"occurence":22510,"Cun":22511,"Zadeh":22512,"Cohan":22513,"1814":22514,"idiopathic":22515,"famil":22516,"geography":22517,"Relative":22518,"GPT":22519,"cholesterol":22520,"总结":22521,"17043":22522,"signed":22523,"fold":22524,"technique":22525,"SpanBERT":22526,"covering":22527,"rithm":22528,"Bottou":22529,"249":22530,"Sutawika":22531,"2035":22532,"hang":22533,"Toolcoder":22534,"Insertion":22535,"Neyman":22536,"970":22537,"batch":22538,"865":22539,"Champaign":22540,"ize":22541,"78":22542,"Getty":22543,"determinism":22544,"nient":22545,"forecast":22546,"numerically":22547,"eyes":22548,"Sablayrolles":22549,"zip":22550,"byte":22551,"Result":22552,"why":22553,"*":22554,"herent":22555,"TruLens":22556,"Paszke":22557,"2679":22558,"–":22559,"文字":22560,"Juang":22561,"ences":22562,"store":22563,"sign":22564,"McMaster":22565,"vfdev":22566,"multiplexer209":22567,"Inst":22568,"LLMLingua":22569,"victories":22570,"LLM":22571,"meth":22572,"964":22573,"generous":22574,"229":22575,"mixtures":22576,"slowed":22577,"areas":22578,"gnawing":22579,"classifi":22580,"contradicts":22581,"instan":22582,"scratch":22583,"elevations":22584,"FP64":22585,"deserve":22586,"visible":22587,"erly":22588,"readings":22589,"Penedo":22590,"8951":22591,"ements":22592,"Gatys":22593,"Exhibits":22594,"rectangular":22595,"Zaheer":22596,"van":22597,"7446":22598,"ensuing":22599,"0.64":22600,"Minnesota":22601,"antecedents":22602,"Issues":22603,"40":22604,"likelihoods":22605,"Volta":22606,"mixture":22607,"finetuning":22608,"studying":22609,"acos":22610,"v":22611,"11019":22612,"range":22613,"2068874e4b9a9f0fb07ebe0ad2b29754449ccacd":22614,"whom":22615,"07843":22616,"12950":22617,"punt":22618,"15391":22619,"Bengio":22620,"continuously":22621,"epoch":22622,"Cocomic":22623,"query":22624,"second":22625,"learner":22626,"majors":22627,"Christmas":22628,"49th":22629,"sgn":22630,"00387":22631,"92":22632,"variational":22633,"du":22634,"Historical":22635,"47986":22636,"uncontroversial":22637,"trigram":22638,"managed":22639,"others":22640,"float":22641,"189":22642,"HWhq":22643,"color":22644,"guessing":22645,"rele":22646,"899955":22647,"conducted":22648,"proponent":22649,"iv":22650,"expressions":22651,"behaved":22652,"aeroplane":22653,"Morris":22654,"subconscious":22655,"autocorrelation":22656,"80486":22657,"3104":22658,"drugs":22659,"Intersections":22660,"metric":22661,"Remote":22662,"Xia":22663,"curate":22664,"tightened":22665,"carried":22666,"handwritten":22667,"Tokyo":22668,"reimagine":22669,"01701":22670,"unfolding":22671,"would":22672,"24%":22673,"posium":22674,"Complications":22675,"propagations":22676,"restating":22677,"1.5":22678,"sys":22679,"589":22680,"labeled":22681,"2y":22682,"Kavukcuoglu":22683,"4822":22684,"originally":22685,"Disc":22686,"Masked":22687,"Recommends":22688,"round":22689,"575":22690,"encoded":22691,"adam":22692,"NIC":22693,"Prompting":22694,"Asset":22695,"Chan":22696,"packaging":22697,"customers":22698,"158":22699,"BlenderBot3":22700,"02907":22701,"conv2d":22702,"893":22703,"attended":22704,"analysis":22705,"Answer":22706,"argu":22707,"contradict":22708,"matplotlib":22709,"baby":22710,"Smooth":22711,"25th":22712,"comparison":22713,"superiority":22714,"frequencies":22715,"Determinant":22716,"Faster":22717,"Synchronous":22718,"entry":22719,"established":22720,"correlates":22721,"contingent":22722,"diverge":22723,"df":22724,"Kaggle":22725,"sets":22726,"Beware":22727,"Businesses":22728,"derivate":22729,"engaged":22730,"expiring":22731,"de":22732,"Normal":22733,"Fernando":22734,"lenders":22735,"misplaced":22736,"tpdi":22737,"tungsten":22738,"Correlation":22739,"2311":22740,"doubled":22741,"Street":22742,"preliminaries":22743,"assigned":22744,"consider":22745,"48801815412811467":22746,"represent":22747,"verse":22748,"warehoused":22749,"Davidson":22750,"By":22751,"unsurprisingly":22752,"MXNet":22753,"addition":22754,"Florian":22755,"greatly":22756,"Kini":22757,"applicant":22758,"basis":22759,"Centennial":22760,"Incrementally":22761,"010":22762,"quently":22763,"storm":22764,"dividing":22765,"Stock":22766,"1935":22767,"Switching":22768,"NaN":22769,"Schlessinger":22770,"prioritize":22771,"Beltagy":22772,"scripted":22773,"tgt":22774,"1029":22775,"recoverability":22776,"owner":22777,"Point":22778,"05772":22779,"streams":22780,"object":22781,"austinmw":22782,"pillars":22783,"extrac":22784,"conceivable":22785,"14858":22786,"lemma":22787,"narrative":22788,"lint":22789,"chose":22790,"shatter":22791,"revive":22792,"1Who":22793,"Commerce":22794,"erroneously":22795,"0.22":22796,"1649":22797,"Sachs":22798,"freezes":22799,"D":22800,"thread":22801,"found":22802,"Maximilian":22803,"A.33":22804,"vidually":22805,"term":22806,"careers":22807,"obligation":22808,"Daisy":22809,"Oper":22810,"existed":22811,"exams":22812,"RandomVerticalFlip":22813,"scoring":22814,"violations":22815,"4190":22816,"argued":22817,"png":22818,"relief":22819,"fight":22820,"Targeted":22821,"442":22822,"0b8703943ccdb6eb788e6f091b8946e82231bc4d":22823,"01991":22824,"Enhancements":22825,"tell":22826,"Welling":22827,"040":22828,"equally":22829,"convolu":22830,"R216":22831,"flatten":22832,"Practitioners":22833,"Makena":22834,"Ao":22835,"0.78":22836,"fatter":22837,"reincorporated":22838,"4279":22839,"tron":22840,"Pavlov":22841,"Simpler":22842,"UNITED":22843,"workflow":22844,"revenues":22845,"boolean":22846,"apt":22847,"justification":22848,"seasoned":22849,"NumPy":22850,"descending":22851,"xstar":22852,"activation":22853,"Maclaurin":22854,"dividends":22855,"Recogni":22856,"minds":22857,"traditionally":22858,"complications":22859,"Barbaros":22860,"Decoder":22861,"Cedric":22862,"Frostig":22863,"Feb":22864,"324":22865,"Orin":22866,"Richard":22867,"fruitful":22868,"expects":22869,"idx":22870,"integrators":22871,"adjourn":22872,"1231":22873,"population":22874,"BROOKE":22875,"minimizing":22876,"Search":22877,"bulky":22878,"REFERENCES":22879,"3333":22880,"augment":22881,"motivated":22882,"Neuristique":22883,"prevalent":22884,"enrich":22885,"Forum":22886,"starts":22887,"4.4":22888,"publication":22889,"addnorm1":22890,"tokenization":22891,"Sign":22892,"reductions":22893,"pure":22894,"12253":22895,"choreographed":22896,"1502":22897,"oversee":22898,"CLOUD":22899,"excluded":22900,"Malladi":22901,"universal":22902,"Random":22903,"graduate":22904,"concern":22905,"insurance":22906,"been":22907,"comprehensively":22908,"Sponsoring":22909,"本":22910,"Advancement":22911,"applying":22912,"artificially":22913,"RQ":22914,"LGBTQ":22915,"C1":22916,"Normally":22917,"Path":22918,"Initial":22919,"produces":22920,"unrelated":22921,"mend":22922,"officers":22923,"Available":22924,"discretion":22925,"clerical":22926,"iciently":22927,"Grant":22928,"Preparation":22929,"2414":22930,"molecules":22931,"anatomical":22932,"remained":22933,"intersegment":22934,"curse":22935,"computershare":22936,"1840":22937,"Notice":22938,"standards":22939,"54":22940,"Limkonchotiwat":22941,"RegNetX":22942,"Options":22943,"Installed":22944,"contexts":22945,"wafer":22946,"longer":22947,"Equivalent":22948,"if":22949,"RRGCode":22950,"drawn":22951,"COURSERA":22952,"artifact":22953,"371":22954,"bail":22955,"civil":22956,"displace":22957,"equivalence":22958,"trolVAE":22959,"Fractional":22960,"surveys":22961,"country":22962,"0687":22963,"g3":22964,"4700":22965,"Rag":22966,"foun":22967,"1808":22968,"Watkins":22969,"drawbacks":22970,"GoogLeNet":22971,"fancy":22972,"fifth":22973,"0803":22974,"leftChild":22975,"inherits":22976,"hiccup":22977,"cum":22978,"demonstrations":22979,"anomalous":22980,"mv":22981,"adaptation":22982,"0.0003":22983,"qualification":22984,"lasso":22985,"lost":22986,"instantaneous":22987,"FMR":22988,"differences":22989,"expertise":22990,"seldom":22991,"Remaining":22992,"deck":22993,"accumulated":22994,"vided":22995,"under":22996,"459":22997,"286":22998,"NLG":22999,"ma":23000,"833":23001,"wd":23002,"lecture":23003,"Tensors":23004,"restrict":23005,"Visualize":23006,"need":23007,"Lenovo":23008,"inextricably":23009,"money":23010,"drawing":23011,"Excellence":23012,"3609":23013,"timent":23014,"strikingly":23015,"Endowment":23016,"regressor":23017,"advisory":23018,"722":23019,"speculation":23020,"TOMAS":23021,"favor":23022,"Playing":23023,"skill":23024,"6ms":23025,"5265":23026,"SaleCondition":23027,"956":23028,"drunk":23029,"operates":23030,"painful":23031,"zticks":23032,"ON":23033,"2000":23034,"thereunder":23035,"Jackel":23036,"ichi":23037,"ResNet":23038,"Undeterred":23039,"Later":23040,"ton":23041,"591":23042,"narrowly":23043,"continuum":23044,"triples":23045,"projecting":23046,"sharpening":23047,"higher":23048,"integral":23049,"Revocable":23050,"Vinyals":23051,"broader":23052,"1510":23053,"089688":23054,"chaining":23055,"Shivam":23056,"mediocre":23057,"Meeting":23058,"writ":23059,"guidelines":23060,"Political":23061,"Rules":23062,"Islander":23063,"1014":23064,"property":23065,"together":23066,"legal":23067,"YEAR":23068,"00449":23069,"1.08":23070,"TOSEM":23071,"89":23072,"173":23073,"Acceptability":23074,"five":23075,"Selected":23076,"investment":23077,"smoothness":23078,"crisis":23079,"prove":23080,"第三":23081,"728":23082,"咖啡豆":23083,"TWINS":23084,"again":23085,"fa19780a7b011d9b009e8bff8e99922a8ee2eb90":23086,"foreign":23087,"755":23088,"12b":23089,"commencement":23090,"Loss":23091,"•":23092,"Exist":23093,"Bresson":23094,"ch6":23095,"accelerate":23096,"munication":23097,"H100":23098,"freeze":23099,"SIAM":23100,"disadvantages":23101,"digital":23102,"moni":23103,"pets":23104,"risk":23105,"eagerly":23106,"decrease":23107,"883":23108,"504":23109,"vi":23110,"1.9":23111,"estimated":23112,"tunable":23113,"1314":23114,"675":23115,"padded":23116,"Motor":23117,"tutorial":23118,"mlls":23119,"mentations":23120,"部分":23121,"achieves":23122,"demic":23123,"Consult":23124,"spelled":23125,"timestamps":23126,"assigning":23127,"calculat":23128,"arguably":23129,"celebrated":23130,"sad":23131,"consistent":23132,"re":23133,"enriching":23134,"5032":23135,"460":23136,"Device":23137,"Metz":23138,"advantageous":23139,"preinstalled":23140,"9725":23141,"evolutionary":23142,"Excitation":23143,"2223e":23144,"resilience":23145,"successor":23146,"Laine":23147,"malization":23148,"processors":23149,"Aquarium":23150,"sales":23151,"heights":23152,"Sessions":23153,"survival":23154,"Werke":23155,"Lumentum":23156,"013":23157,"feline":23158,"titioners":23159,"2z":23160,"collected":23161,"lived":23162,"adapt":23163,"04032":23164,"conv4":23165,"Predicted":23166,"food":23167,"mini1":23168,"Evaluates":23169,"automatic":23170,"widen":23171,"involves":23172,"Augmented":23173,"Speeded":23174,"benchmarking":23175,"214":23176,"8707":23177,"shutil":23178,"markdown":23179,"folds":23180,"conciseness":23181,"Role":23182,"Burgess":23183,"Levenshtein":23184,"representatives":23185,"Pepsi":23186,"narrow":23187,"703":23188,"interpreters":23189,"Colossal":23190,"TinyImages":23191,"isolation":23192,"oversight":23193,"nucleus":23194,"decreases":23195,"recom":23196,"relates":23197,"corner":23198,"contracts":23199,"atter":23200,"tensions":23201,"Empirically":23202,"bol":23203,"NCCL":23204,"Schein":23205,"12000":23206,"sanity":23207,"Nations":23208,"telescopes":23209,"Stranger":23210,"518":23211,"8877":23212,"Graduate":23213,"Larsen":23214,"A.2":23215,"Borgeaud":23216,"ModuleList":23217,"10559888854748693":23218,"maintain":23219,"Zip":23220,"11446":23221,"Aksitov":23222,"article174":23223,"biased":23224,"begins":23225,"rm":23226,"Colab302":23227,"Soricut":23228,"Features":23229,"Hispanic":23230,"prioritizing":23231,"disambiguate":23232,"Architectures":23233,"Roukos":23234,"expansions":23235,"illness":23236,"Limits":23237,"Parser":23238,"firmly":23239,"hereto":23240,"inseparable":23241,"fees":23242,"patches":23243,"594":23244,"rightmost":23245,"20235201406823256":23246,"geographical":23247,"webentwicklung":23248,"Ent":23249,"meme":23250,"discriminators":23251,"51.633":23252,"530%":23253,"C2050":23254,"Court":23255,"pressed":23256,"Trust":23257,"6114":23258,"Gumbel":23259,"printing":23260,"5569":23261,"Forty":23262,"worth":23263,"outer":23264,"free":23265,"Toy":23266,"CRSR":23267,"crosslingual":23268,"nrows":23269,"027":23270,"ago":23271,"Sharma":23272,"cisions":23273,"Stride":23274,"Transferring":23275,"6772":23276,"inventors":23277,"workers":23278,"modification":23279,"awesome":23280,"bent":23281,"SKP":23282,"Sample":23283,"CSPs":23284,"739":23285,"evolving":23286,"Freeman":23287,"precedented":23288,"Nonconvex":23289,"Hu":23290,"inspecting":23291,"Parthenon":23292,"Zeshan":23293,"919740":23294,"attached":23295,"tar":23296,"Rerank":23297,"1974":23298,"dieses":23299,"6667":23300,"033363":23301,"proud":23302,"494":23303,"illuminating":23304,"govern":23305,"Months":23306,"tailored":23307,"Madaan":23308,"incident":23309,"overestimated":23310,"succeeding":23311,"Finetuning":23312,"752":23313,"APIs":23314,"discounted":23315,"dateset":23316,"runaway":23317,"caches":23318,"NIM":23319,"ture":23320,"memorized":23321,"cal":23322,"080567":23323,"nately":23324,"Fast":23325,"TensorDataset":23326,"mplot3d":23327,"electronically":23328,"Benefits":23329,"Look":23330,"Lang":23331,"hearing":23332,"2014":23333,"pursuing":23334,"631":23335,"Save":23336,"correlation":23337,"Discussions161":23338,"aptly":23339,"00000":23340,"AMI":23341,"Pulfer":23342,"TinySSD":23343,"uncontrollably":23344,"并":23345,"Saxena":23346,"进展":23347,"Maheswaranathan":23348,"distribu":23349,"prerequisite":23350,"seq":23351,"LSTMScratch":23352,"358":23353,"BA":23354,"correlated":23355,"exist":23356,"Ha":23357,"Merity":23358,"Chanan":23359,"sleep":23360,"◦":23361,"credible":23362,"probabilistic":23363,"Mallen":23364,"censored":23365,"LSTMs":23366,"language":23367,"stalling":23368,"ship":23369,"cents":23370,"Macy":23371,"col":23372,"corporate":23373,"0.95":23374,"55":23375,"duty":23376,"0.846":23377,"leaders":23378,"2278":23379,"traditional":23380,"planned":23381,"Luc":23382,"Worlds":23383,"6400":23384,"全面完成":23385,"1KB":23386,"lez":23387,"RECODE":23388,"Minerals":23389,"xxxv":23390,"47":23391,"chan":23392,"intra":23393,"unamortized":23394,"Latin":23395,"misappropriation":23396,"m3":23397,"sur":23398,"crisply":23399,"Inspiration":23400,"neously":23401,"Clara":23402,"TRIME":23403,"Metzler":23404,"1560":23405,"systems":23406,"这":23407,"开发":23408,"invested":23409,"Code":23410,"temptation":23411,"Amin":23412,"recognize":23413,"′":23414,"iPhone":23415,"microprocessor":23416,"257":23417,"textures":23418,"1122":23419,"materially":23420,"gramming":23421,"outdoors":23422,"Smirnov":23423,"interactively":23424,"misclassified":23425,"461":23426,"below":23427,"attracts":23428,"FTSE":23429,"HBM2":23430,"---------":23431,"challenge":23432,"interleaved":23433,"succinct":23434,"Amazon":23435,"plying":23436,"Implementation":23437,"对于":23438,"826":23439,"transition":23440,"applica":23441,"shortens":23442,"ncols":23443,"takeaways":23444,"copyright":23445,"Rasool":23446,"fractionally":23447,"plagued":23448,"United":23449,"ns":23450,"p1":23451,"Adeli":23452,"bold":23453,"Logarithm":23454,"56":23455,"2303":23456,"090":23457,"Unbiasing":23458,"likening":23459,"refrains":23460,"horrible":23461,"Focusing":23462,"Mark":23463,"VOC":23464,"Ghrzuzudu":23465,"bodies":23466,"vocabulary":23467,"determine":23468,"ZeroMean":23469,"Empirical":23470,"Provides":23471,"630":23472,"facebook":23473,"Blunsom":23474,"体验":23475,"databases":23476,"announcements":23477,"SKI":23478,"TensorRT":23479,"folk":23480,"PSU":23481,"299387":23482,"Adequately":23483,"Reset":23484,"Fan":23485,"duties":23486,"motherboard":23487,"1950s":23488,"caution":23489,"Equivalents":23490,"LotFrontage":23491,"23rd":23492,"tie":23493,"Nasdaq100":23494,"vgg":23495,"Monitoring":23496,"class":23497,"targeting":23498,"Tied":23499,"11903":23500,"nice":23501,"Leandojo":23502,"primitives":23503,"designed":23504,"multidimen":23505,"Stopping":23506,"19.4":23507,"regularized":23508,"providers":23509,"proceeds":23510,"340198":23511,"cumbersome":23512,"recognizing":23513,"Loan":23514,"7944":23515,"":23516}
```

    |-- test_datasets/
    |-- __init__.py

``` py

```

    |-- analyze_answer.py

``` py
# zhz_rag/evaluation/analyze_answer.py
import json
import os
import pandas as pd
from typing import List, Dict, Any, Optional
from collections import Counter
from datetime import datetime
import glob 

# --- 从项目中导入必要的模块 ---
try:
    from zhz_rag.utils.common_utils import (
        load_jsonl_file, # <--- 使用新的通用函数
        EVALUATION_RESULTS_LOGS_DIR # 导入评估日志目录常量
    )
except ImportError as e:
    print(f"ERROR: Could not import necessary modules in analyze_answer.py: {e}")
    print("Make sure this script is run in an environment where 'zhz_rag' package is accessible.")
    exit(1)

import logging

# --- 配置此脚本的logger ---
analyze_answer_logger = logging.getLogger("AnalyzeAnswerLogger")
analyze_answer_logger.setLevel(logging.INFO)
if not analyze_answer_logger.hasHandlers():
    _console_handler = logging.StreamHandler()
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _console_handler.setFormatter(_formatter)
    analyze_answer_logger.addHandler(_console_handler)
    analyze_answer_logger.propagate = False
analyze_answer_logger.info("--- AnalyzeAnswerLogger configured ---")

# --- 核心功能函数 ---

def extract_answer_evaluation_details(log_entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    从单条已解析的答案评估日志条目中提取关键信息。
    这个函数与您之前在 analyze_answer.py 中的版本基本一致，稍作调整。
    """
    details = {}
    eval_data = log_entry.get("eval_llm_processed_output_json")

    if not eval_data or not isinstance(eval_data, dict):
        analyze_answer_logger.warning(f"Skipping log entry due to missing or invalid 'eval_llm_processed_output_json'. Interaction ID ref: {log_entry.get('original_interaction_id_ref')}")
        return None

    details["interaction_id_ref"] = log_entry.get("original_interaction_id_ref")
    details["user_question"] = log_entry.get("user_question_for_eval")
    details["generated_answer"] = log_entry.get("generated_answer_for_eval")
    
    summary = eval_data.get("evaluation_summary", {})
    dimensions = eval_data.get("dimensions", {})
    
    details["overall_answer_quality_score"] = summary.get("overall_answer_quality_score")
    details["main_strengths_answer"] = summary.get("main_strengths_answer")
    details["main_weaknesses_answer"] = summary.get("main_weaknesses_answer")
    
    faithfulness = dimensions.get("faithfulness", {})
    details["faithfulness_score"] = faithfulness.get("score")
    details["faithfulness_reasoning"] = faithfulness.get("reasoning")
    # 确保 problematic_answer_segments_faithfulness 是列表，然后 join
    problematic_segments = faithfulness.get("problematic_answer_segments_faithfulness", [])
    if isinstance(problematic_segments, list):
        details["faithfulness_problematic_segments"] = "; ".join(problematic_segments)
    else:
        details["faithfulness_problematic_segments"] = str(problematic_segments) # 以防万一不是列表

    relevance = dimensions.get("relevance", {})
    details["relevance_score"] = relevance.get("score")
    details["relevance_reasoning"] = relevance.get("reasoning")
    
    completeness = dimensions.get("completeness", {})
    details["completeness_context_sufficiency"] = completeness.get("context_sufficiency_assessment")
    details["completeness_context_reasoning"] = completeness.get("context_sufficiency_reasoning")
    details["completeness_score"] = completeness.get("score")
    details["completeness_reasoning"] = completeness.get("reasoning")
    
    coherence = dimensions.get("coherence_fluency", {}) # 键名可能与prompt中的一致
    details["coherence_score"] = coherence.get("score")
    details["coherence_reasoning"] = coherence.get("reasoning")

    actionability = dimensions.get("actionability_usability", {}) # 键名可能与prompt中的一致
    details["actionability_score"] = actionability.get("score")
    details["actionability_reasoning"] = actionability.get("reasoning")
    
    details["gemini_suggestion_answer"] = eval_data.get("suggestion_for_answer_improvement")

    return details

def perform_answer_evaluation_analysis(
    evaluation_log_filepath: str,
    output_csv_filepath: str
) -> bool:
    """
    加载答案评估日志，进行分析，并保存结果到CSV。

    Args:
        evaluation_log_filepath (str): 答案评估结果日志文件的路径。
        output_csv_filepath (str): 分析结果CSV文件的保存路径。

    Returns:
        bool: 如果分析和保存成功则返回True，否则返回False。
    """
    analyze_answer_logger.info(f"Starting Answer evaluation analysis for log file: {evaluation_log_filepath}")
    analyze_answer_logger.info(f"Analysis results will be saved to: {output_csv_filepath}")

    evaluation_logs = load_jsonl_file(evaluation_log_filepath)

    if not evaluation_logs:
        analyze_answer_logger.warning(f"No evaluation logs found or loaded from {evaluation_log_filepath}. Analysis aborted.")
        return False

    extracted_details_list = []
    for log_entry in evaluation_logs:
        if log_entry.get("task_type") == "answer_evaluation_result": # 确保是答案评估日志
            details = extract_answer_evaluation_details(log_entry)
            if details:
                extracted_details_list.append(details)
        else:
            analyze_answer_logger.debug(f"Skipping log entry with task_type '{log_entry.get('task_type')}' as it's not 'answer_evaluation_result'.")


    if not extracted_details_list:
        analyze_answer_logger.info("No valid Answer evaluation details extracted from the logs. No CSV will be generated.")
        return False

    df = pd.DataFrame(extracted_details_list)
    
    score_columns = [
        "overall_answer_quality_score", "faithfulness_score", "relevance_score",
        "completeness_score", "coherence_score", "actionability_score"
    ]
    for col in score_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

    analyze_answer_logger.info(f"\n--- Preliminary Answer Evaluation Analysis (from {len(extracted_details_list)} entries) ---")
    analyze_answer_logger.info(f"Total evaluation entries processed: {len(df)}")

    for col_name in score_columns:
        if col_name in df.columns and not df[col_name].isnull().all():
            analyze_answer_logger.info(f"\nDimension: {col_name}")
            analyze_answer_logger.info(f"{df[col_name].describe()}")
            analyze_answer_logger.info("Score Distribution:")
            analyze_answer_logger.info(f"{df[col_name].value_counts(dropna=False).sort_index()}")
        else:
            analyze_answer_logger.info(f"\nDimension: {col_name} - No data or all NaN.")
            
    if "completeness_context_sufficiency" in df.columns and not df["completeness_context_sufficiency"].isnull().all():
        analyze_answer_logger.info("\nContext Sufficiency Assessment Distribution:")
        analyze_answer_logger.info(f"{df['completeness_context_sufficiency'].value_counts(dropna=False)}")
    else:
        analyze_answer_logger.info("\nContext Sufficiency Assessment Distribution: No data.")

    try:
        os.makedirs(os.path.dirname(output_csv_filepath), exist_ok=True)
        df.to_csv(output_csv_filepath, index=False, encoding='utf-8-sig')
        analyze_answer_logger.info(f"\nAnalysis results saved to: {output_csv_filepath}")
        return True
    except Exception as e:
        analyze_answer_logger.error(f"\nFailed to save CSV file: {e}", exc_info=True)
        return False

if __name__ == "__main__":
    EVALUATION_NAME_FOR_ANSWER = "answer_gemini_flash" 
    
    # --- 动态查找最新的评估结果日志文件 ---
    eval_logs_pattern = os.path.join(EVALUATION_RESULTS_LOGS_DIR, f"eval_results_{EVALUATION_NAME_FOR_ANSWER}_*.jsonl")
    all_eval_logs = sorted(glob.glob(eval_logs_pattern), key=os.path.getmtime, reverse=True)
    
    log_file_path_answer: Optional[str] = None
    output_csv_path_answer: Optional[str] = None

    if all_eval_logs:
        log_file_path_answer = all_eval_logs[0] # 获取最新的一个
        analyze_answer_logger.info(f"Found latest Answer evaluation log for analysis: {log_file_path_answer}")
        
        # 根据找到的日志文件名构造输出的 CSV 文件名
        base_log_name = os.path.basename(log_file_path_answer)
        # 从 "eval_results_answer_gemini_flash_YYYYMMDD.jsonl" 生成 "analysis_answer_gemini_flash_YYYYMMDD.csv"
        if base_log_name.startswith(f"eval_results_{EVALUATION_NAME_FOR_ANSWER}_") and base_log_name.endswith(".jsonl"):
            date_part_from_filename = base_log_name[len(f"eval_results_{EVALUATION_NAME_FOR_ANSWER}_"):-len(".jsonl")]
            output_csv_name_answer = f"analysis_{EVALUATION_NAME_FOR_ANSWER}_{date_part_from_filename}.csv"
            output_csv_path_answer = os.path.join(EVALUATION_RESULTS_LOGS_DIR, output_csv_name_answer)
        else: # Fallback naming for CSV
            today_str = datetime.now().strftime("%Y%m%d")
            output_csv_name_answer = f"analysis_{EVALUATION_NAME_FOR_ANSWER}_{today_str}_fallback.csv"
            output_csv_path_answer = os.path.join(EVALUATION_RESULTS_LOGS_DIR, output_csv_name_answer)
        analyze_answer_logger.info(f"Analysis CSV report will be saved to: {output_csv_path_answer}")
    else:
        analyze_answer_logger.error(f"No Answer evaluation log files found matching pattern: {eval_logs_pattern}")

    if log_file_path_answer and output_csv_path_answer and os.path.exists(log_file_path_answer):
        perform_answer_evaluation_analysis(
            evaluation_log_filepath=log_file_path_answer,
            output_csv_filepath=output_csv_path_answer
        )
    else:
        analyze_answer_logger.info("Answer evaluation analysis will not run as no suitable log file was identified or output path could not be determined.")
```

    |-- analyze_cypher.py

``` py
# zhz_rag/evaluation/analyze_cypher.py
import json
import os
import pandas as pd
from typing import List, Dict, Any, Optional
from collections import Counter
from datetime import datetime
import glob 

# --- 从项目中导入必要的模块 ---
try:
    from zhz_rag.utils.common_utils import (
        load_jsonl_file, # <--- 使用新的通用函数
        EVALUATION_RESULTS_LOGS_DIR # 导入评估日志目录常量
    )
except ImportError as e:
    print(f"ERROR: Could not import necessary modules in analyze_cypher.py: {e}")
    print("Make sure this script is run in an environment where 'zhz_rag' package is accessible.")
    exit(1)

import logging

# --- 配置此脚本的logger ---
analyze_cypher_logger = logging.getLogger("AnalyzeCypherLogger")
analyze_cypher_logger.setLevel(logging.INFO)
if not analyze_cypher_logger.hasHandlers():
    _console_handler = logging.StreamHandler()
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _console_handler.setFormatter(_formatter)
    analyze_cypher_logger.addHandler(_console_handler)
    analyze_cypher_logger.propagate = False
analyze_cypher_logger.info("--- AnalyzeCypherLogger configured ---")

# --- 核心功能函数 ---

def extract_cypher_evaluation_details(log_entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    从单条已解析的Cypher评估日志条目中提取关键信息。
    这个函数与您之前在 analyze_cypher.py 中的版本基本一致，稍作调整以适应通用加载。
    """
    details = {}
    # eval_llm_processed_output_json 字段包含了Gemini评估的JSON输出
    eval_data = log_entry.get("eval_llm_processed_output_json")

    if not eval_data or not isinstance(eval_data, dict):
        analyze_cypher_logger.warning(f"Skipping log entry due to missing or invalid 'eval_llm_processed_output_json'. Interaction ID ref: {log_entry.get('original_interaction_id_ref')}")
        return None # 如果核心评估数据缺失，则跳过此条目

    details["interaction_id_ref"] = log_entry.get("original_interaction_id_ref")
    details["user_question"] = log_entry.get("user_question_for_eval")
    details["generated_cypher"] = log_entry.get("generated_cypher_for_eval")
    
    summary = eval_data.get("evaluation_summary", {})
    dimensions = eval_data.get("dimensions", {})
    
    details["overall_quality_score"] = summary.get("overall_quality_score_cypher")
    details["main_strength"] = summary.get("main_strength_cypher")
    details["main_weakness"] = summary.get("main_weakness_cypher")
    
    syntax = dimensions.get("syntactic_correctness", {})
    details["syntax_score"] = syntax.get("score")
    details["syntax_reasoning"] = syntax.get("reasoning")
    
    schema = dimensions.get("schema_adherence", {})
    details["schema_overall_score"] = schema.get("overall_score")
    details["schema_node_label_correct"] = schema.get("node_label_correctness", {}).get("check_result")
    details["schema_entity_type_correct"] = schema.get("entity_type_property_correctness", {}).get("check_result")
    details["schema_rel_type_correct"] = schema.get("relationship_type_correctness", {}).get("check_result")
    details["schema_prop_name_correct"] = schema.get("property_name_correctness", {}).get("check_result")
    details["schema_hallucinated_present"] = schema.get("hallucinated_schema_elements", {}).get("check_result_hallucination_present")
    details["schema_hallucinated_elements"] = ", ".join(schema.get("hallucinated_schema_elements", {}).get("elements_found", []))
    details["schema_reasoning"] = schema.get("reasoning")
    
    intent = dimensions.get("intent_accuracy", {})
    details["intent_score"] = intent.get("score")
    details["intent_explanation_cypher"] = intent.get("explanation_of_cypher_retrieval")
    details["intent_alignment_notes"] = intent.get("semantic_alignment_with_question")
    details["intent_key_elements_notes"] = intent.get("key_element_coverage_notes")
    details["intent_reasoning"] = intent.get("reasoning")
    
    details["qwen_error_patterns"] = ", ".join(eval_data.get("qwen_error_patterns_identified", []))
    details["gemini_suggestion"] = eval_data.get("suggestion_for_improvement_cypher")

    return details

def perform_cypher_evaluation_analysis(
    evaluation_log_filepath: str,
    output_csv_filepath: str
) -> bool:
    """
    加载Cypher评估日志，进行分析，并保存结果到CSV。

    Args:
        evaluation_log_filepath (str): Cypher评估结果日志文件的路径。
        output_csv_filepath (str): 分析结果CSV文件的保存路径。

    Returns:
        bool: 如果分析和保存成功则返回True，否则返回False。
    """
    analyze_cypher_logger.info(f"Starting Cypher evaluation analysis for log file: {evaluation_log_filepath}")
    analyze_cypher_logger.info(f"Analysis results will be saved to: {output_csv_filepath}")

    # 使用通用函数加载评估日志
    # 注意：evaluate_cypher_with_gemini 保存的日志中 task_type 是 "cypher_evaluation_by_gemini"
    # load_jsonl_file 不关心 task_type，它会加载所有行
    evaluation_logs = load_jsonl_file(evaluation_log_filepath)

    if not evaluation_logs:
        analyze_cypher_logger.warning(f"No evaluation logs found or loaded from {evaluation_log_filepath}. Analysis aborted.")
        return False

    extracted_details_list = []
    for log_entry in evaluation_logs:
        # 确保只处理Cypher评估结果
        if log_entry.get("task_type") == "cypher_evaluation_by_gemini":
            details = extract_cypher_evaluation_details(log_entry)
            if details: # extract_cypher_evaluation_details 可能会返回 None
                extracted_details_list.append(details)
        else:
            analyze_cypher_logger.debug(f"Skipping log entry with task_type '{log_entry.get('task_type')}' as it's not 'cypher_evaluation_by_gemini'.")


    if not extracted_details_list:
        analyze_cypher_logger.info("No valid Cypher evaluation details extracted from the logs. No CSV will be generated.")
        return False

    df = pd.DataFrame(extracted_details_list)
    
    score_columns = ["overall_quality_score", "syntax_score", "schema_overall_score", "intent_score"]
    for col in score_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

    analyze_cypher_logger.info(f"\n--- Preliminary Cypher Evaluation Analysis (from {len(extracted_details_list)} entries) ---")
    analyze_cypher_logger.info(f"Total evaluation entries processed: {len(df)}")

    if "overall_quality_score" in df.columns and not df["overall_quality_score"].isnull().all():
        analyze_cypher_logger.info("\n1. Overall Quality Score:")
        analyze_cypher_logger.info(f"{df['overall_quality_score'].describe()}")
        analyze_cypher_logger.info("\nScore Distribution:")
        analyze_cypher_logger.info(f"{df['overall_quality_score'].value_counts(dropna=False).sort_index()}")
    else:
        analyze_cypher_logger.info("\n1. Overall Quality Score: No data or all NaN.")


    if "schema_overall_score" in df.columns and not df["schema_overall_score"].isnull().all():
        analyze_cypher_logger.info("\n2. Schema Adherence Overall Score:")
        analyze_cypher_logger.info(f"{df['schema_overall_score'].describe()}")
        analyze_cypher_logger.info("\nScore Distribution:")
        analyze_cypher_logger.info(f"{df['schema_overall_score'].value_counts(dropna=False).sort_index()}")
        
        schema_sub_checks = [
            "schema_node_label_correct", "schema_entity_type_correct", 
            "schema_rel_type_correct", "schema_prop_name_correct", 
            "schema_hallucinated_present"
        ]
        analyze_cypher_logger.info("\nSchema Adherence Sub-item Issues (False means issue, Hallucinated True means issue):")
        for check in schema_sub_checks:
            if check in df.columns:
                if check == "schema_hallucinated_present":
                    issue_count = df[df[check] == True].shape[0]
                    analyze_cypher_logger.info(f"  - {check} (Hallucination Present): {issue_count} entries")
                else:
                    issue_count = df[df[check] == False].shape[0]
                    analyze_cypher_logger.info(f"  - {check} (Incorrect): {issue_count} entries")
    else:
        analyze_cypher_logger.info("\n2. Schema Adherence Overall Score: No data or all NaN.")


    if "intent_score" in df.columns and not df["intent_score"].isnull().all():
        analyze_cypher_logger.info("\n3. Intent Accuracy Score:")
        analyze_cypher_logger.info(f"{df['intent_score'].describe()}")
        analyze_cypher_logger.info("\nScore Distribution:")
        analyze_cypher_logger.info(f"{df['intent_score'].value_counts(dropna=False).sort_index()}")
    else:
        analyze_cypher_logger.info("\n3. Intent Accuracy Score: No data or all NaN.")


    if "qwen_error_patterns" in df.columns and not df["qwen_error_patterns"].isnull().all():
        analyze_cypher_logger.info("\n4. Identified Qwen Error Patterns (Top 5):")
        all_patterns = []
        for pattern_list_str in df["qwen_error_patterns"].dropna():
            if pattern_list_str and isinstance(pattern_list_str, str):
                all_patterns.extend([p.strip() for p in pattern_list_str.split(",") if p.strip()])
        pattern_counts = Counter(all_patterns)
        analyze_cypher_logger.info(f"{pattern_counts.most_common(5)}")
    else:
        analyze_cypher_logger.info("\n4. Identified Qwen Error Patterns: No data.")
        
    try:
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output_csv_filepath), exist_ok=True)
        df.to_csv(output_csv_filepath, index=False, encoding='utf-8-sig')
        analyze_cypher_logger.info(f"\nAnalysis results saved to: {output_csv_filepath}")
        return True
    except Exception as e:
        analyze_cypher_logger.error(f"\nFailed to save CSV file: {e}", exc_info=True)
        return False

if __name__ == "__main__":
    EVALUATION_NAME_FOR_CYPHER = "cypher_gemini_flash" 

    eval_logs_pattern = os.path.join(EVALUATION_RESULTS_LOGS_DIR, f"eval_results_{EVALUATION_NAME_FOR_CYPHER}_*.jsonl")
    all_eval_logs = sorted(glob.glob(eval_logs_pattern), key=os.path.getmtime, reverse=True)
    
    log_file_path_cypher: Optional[str] = None
    output_csv_path_cypher: Optional[str] = None

    if all_eval_logs:
        log_file_path_cypher = all_eval_logs[0]
        analyze_cypher_logger.info(f"Found latest Cypher evaluation log for analysis: {log_file_path_cypher}")
        
        base_log_name = os.path.basename(log_file_path_cypher)
        if base_log_name.startswith(f"eval_results_{EVALUATION_NAME_FOR_CYPHER}_") and base_log_name.endswith(".jsonl"):
            date_part_from_filename = base_log_name[len(f"eval_results_{EVALUATION_NAME_FOR_CYPHER}_"):-len(".jsonl")]
            output_csv_name_cypher = f"analysis_{EVALUATION_NAME_FOR_CYPHER}_{date_part_from_filename}.csv"
            output_csv_path_cypher = os.path.join(EVALUATION_RESULTS_LOGS_DIR, output_csv_name_cypher)
        else:
            today_str = datetime.now().strftime("%Y%m%d")
            output_csv_name_cypher = f"analysis_{EVALUATION_NAME_FOR_CYPHER}_{today_str}_fallback.csv"
            output_csv_path_cypher = os.path.join(EVALUATION_RESULTS_LOGS_DIR, output_csv_name_cypher)
        analyze_cypher_logger.info(f"Analysis CSV report will be saved to: {output_csv_path_cypher}")
    else:
        analyze_cypher_logger.error(f"No Cypher evaluation log files found matching pattern: {eval_logs_pattern}")

    if log_file_path_cypher and output_csv_path_cypher and os.path.exists(log_file_path_cypher):
        perform_cypher_evaluation_analysis(
            evaluation_log_filepath=log_file_path_cypher,
            output_csv_filepath=output_csv_path_cypher
        )
    else:
        analyze_cypher_logger.info("Cypher evaluation analysis will not run as no suitable log file was identified or output path could not be determined.")
```

    |-- batch_eval_answer.py

``` py
# 文件: zhz_rag/evaluation/batch_eval_answer.py
import os
import asyncio
import json
import logging
from typing import List, Dict, Any, Optional
from pathlib import Path
import argparse
import httpx # 使用httpx进行异步HTTP请求

# 确保项目根目录在sys.path中，以便正确导入
# 这部分可能需要根据你的项目结构调整
try:
    from zhz_rag.llm.llm_interface import NO_ANSWER_PHRASE_ANSWER_CLEAN
    from zhz_rag.config.pydantic_models import RetrievedDocument
    from zhz_rag.utils.gemini_api_utils import GeminiAPIClient # <--- 修改
    from zhz_rag.evaluation.evaluator import evaluate_answer_with_gemini
except ImportError:
    import sys
    # A more robust way to add the project root to the path
    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    from zhz_rag.llm.llm_interface import NO_ANSWER_PHRASE_ANSWER_CLEAN
    from zhz_rag.config.pydantic_models import RetrievedDocument
    from zhz_rag.utils.gemini_api_utils import GeminiAPIClient # <--- 修正这一行
    from zhz_rag.evaluation.evaluator import evaluate_answer_with_gemini

# --- 配置日志 ---
batch_answer_eval_logger = logging.getLogger("BatchAnswerEvaluationLogger")
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# --- 定义常量 ---
RAG_API_URL = "http://localhost:8081/api/v1/rag/query"
DEFAULT_TEST_DATASET_PATH = Path(__file__).parent / "test_datasets" / "evaluation_questions_v1.txt"
REQUEST_TIMEOUT = 120.0  # API请求的超时时间，单位秒
DELAY_BETWEEN_REQUESTS = 5 # 每个评估请求之间的延迟，避免API过载

async def call_rag_api(client: httpx.AsyncClient, question: str) -> Optional[Dict[str, Any]]:
    """
    异步调用RAG API服务并返回结果。
    """
    payload = {
        "query": question,
        "top_k_vector": 3,
        "top_k_bm25": 3,
        "top_k_kg": 3,
        "top_k_final": 5  # 召回更多上下文给评估器
    }
    try:
        batch_answer_eval_logger.info(f"Sending request to RAG API for question: '{question}'")
        response = await client.post(RAG_API_URL, json=payload, timeout=REQUEST_TIMEOUT)
        
        if response.status_code == 200:
            batch_answer_eval_logger.info("RAG API returned a successful response.")
            return response.json()
        else:
            batch_answer_eval_logger.error(
                f"RAG API returned an error. Status: {response.status_code}, "
                f"Response: {response.text[:200]}"
            )
            return None
    except httpx.RequestError as e:
        batch_answer_eval_logger.error(f"Error calling RAG API for question '{question}': {e}", exc_info=True)
        return None

async def main_evaluation_runner(
    questions_file: Path, 
    gemini_resource: GeminiAPIClient, 
    app_version_tag: str,
    use_simulated_api: bool,
    api_call_delay: int
):
    """
    读取问题文件，调用RAG API，然后使用Gemini评估答案。
    """
    if not questions_file.exists():
        batch_answer_eval_logger.error(f"Test questions file not found at: {questions_file}")
        return

    with open(questions_file, 'r', encoding='utf-8') as f:
        # --- 优化：跳过注释行 (#) 和空行 ---
        questions = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]
    
    batch_answer_eval_logger.info(f"Loaded {len(questions)} questions from '{questions_file.name}'. Starting evaluation...")
    
    successful_evals = 0
    failed_evals = 0
    
    async with httpx.AsyncClient() as client:
        for i, question in enumerate(questions, 1):
            batch_answer_eval_logger.info(f"--- Processing question {i}/{len(questions)}: '{question}' ---")
            
            # 1. 调用RAG API获取答案
            rag_response = await call_rag_api(client, question)
            
            if rag_response is None:
                batch_answer_eval_logger.warning(f"Skipping evaluation for '{question}' due to RAG API failure.")
                failed_evals += 1
                await asyncio.sleep(api_call_delay) # 使用传入的延迟参数
                continue

            # 2. 从RAG API响应中提取评估所需的信息
            answer_text = rag_response.get("answer")
            retrieved_sources_raw = rag_response.get("retrieved_sources", [])
            
            # 即使有答案，如果没有上下文来源，对于研究型问题也认为是失败
            if not answer_text or not retrieved_sources_raw:
                batch_answer_eval_logger.warning(
                    f"RAG API response for '{question}' is incomplete. "
                    f"Answer: '{answer_text}', Sources: {len(retrieved_sources_raw)}. Skipping evaluation."
                )
                failed_evals += 1
                await asyncio.sleep(api_call_delay) # 使用传入的延迟参数
                continue

            # 3. 准备评估函数的输入
            retrieved_docs_for_eval = [RetrievedDocument(**doc) for doc in retrieved_sources_raw]
            
            # 4. 调用Gemini进行评估
            await evaluate_answer_with_gemini(
                gemini_resource_for_evaluator=gemini_resource,
                user_question=question,
                retrieved_contexts=retrieved_docs_for_eval,
                generated_answer=answer_text,
                app_version=app_version_tag,
                use_simulated_api=use_simulated_api,
                api_call_delay=api_call_delay
            )
            successful_evals += 1
            
            batch_answer_eval_logger.info(f"Successfully evaluated question {i}. Sleeping for {api_call_delay} seconds...")
            await asyncio.sleep(api_call_delay) # 使用传入的延迟参数

    batch_answer_eval_logger.info("--- Batch Answer Evaluation Finished ---")
    batch_answer_eval_logger.info(f"Summary: Successfully evaluated {successful_evals} questions, Failed/Skipped {failed_evals} questions.")

    
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run batch evaluation of RAG answers using a questions file.")
    
    parser.add_argument(
        "--questions-file",
        type=Path,
        default=DEFAULT_TEST_DATASET_PATH,
        help=f"Path to the .txt file containing evaluation questions. Defaults to {DEFAULT_TEST_DATASET_PATH}"
    )
    parser.add_argument(
        "--app-version",
        type=str,
        default="0.2.0_eval_run",
        help="A version tag for this evaluation run."
    )
    parser.add_argument(
        "--simulate",
        action="store_true",
        help="Use simulated Gemini API responses for testing the evaluation script itself."
    )
    parser.add_argument(
        "--delay",
        type=int,
        default=DELAY_BETWEEN_REQUESTS,
        help=f"Delay in seconds between evaluation calls to avoid rate limiting. Defaults to {DELAY_BETWEEN_REQUESTS}."
    )
    
    args = parser.parse_args()
    
# 初始化Gemini客户端
    try:
        gemini_client = GeminiAPIClient.from_env() # <--- 修改
        batch_answer_eval_logger.info("GeminiAPIClient for Answer evaluation initialized successfully.")
    except Exception as e:
        batch_answer_eval_logger.error(f"Failed to initialize GeminiAPIClient: {e}", exc_info=True)
        gemini_client = None

    if not gemini_client:
        batch_answer_eval_logger.error("Cannot proceed with evaluation as GeminiAPIClient is not available.")
    else:
        asyncio.run(main_evaluation_runner(
            questions_file=args.questions_file,
            gemini_resource=gemini_client, # <--- 修改
            app_version_tag=args.app_version,
            use_simulated_api=args.simulate,
            api_call_delay=args.delay
        ))
```

    |-- batch_eval_cypher.py

``` py
# zhz_rag/evaluation/batch_eval_cypher.py
import asyncio
import json
import os
from typing import List, Dict, Any, Optional, TYPE_CHECKING, Union
import glob
from datetime import datetime

try:
    from zhz_rag.evaluation.evaluator import evaluate_cypher_with_gemini
    from zhz_rag.utils.common_utils import (
        find_latest_rag_interaction_log,
        load_jsonl_file,
        RAG_INTERACTION_LOGS_DIR
    )
except ImportError as e:
    print(f"ERROR: Could not import necessary modules in batch_eval_cypher.py: {e}")
    print("Make sure this script is run in an environment where 'zhz_rag' package is accessible.")
    exit(1)

if TYPE_CHECKING:
    from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import GeminiAPIResource

import logging

batch_cypher_eval_logger = logging.getLogger("BatchCypherEvaluationLogger")
batch_cypher_eval_logger.setLevel(logging.DEBUG) # 设置为 DEBUG 以便查看详细日志
if not batch_cypher_eval_logger.hasHandlers():
    _console_handler = logging.StreamHandler()
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _console_handler.setFormatter(_formatter)
    batch_cypher_eval_logger.addHandler(_console_handler)
    batch_cypher_eval_logger.propagate = False
batch_cypher_eval_logger.info("--- BatchCypherEvaluationLogger configured (Level: DEBUG) ---")


async def run_cypher_batch_evaluation(
    gemini_resource_for_evaluator: 'GeminiAPIResource',
    rag_interaction_log_filepath: str,
    app_version: str = "0.1.0",
    use_simulated_api: bool = False,
    api_call_delay: float = 4.1,
    target_task_types: Union[str, List[str]] = "cypher_generation_final_attempt_local_service",
    field_mapping: Optional[Dict[str, Union[str, List[str]]]] = None
) -> Dict[str, int]:
    batch_cypher_eval_logger.info(f"Starting batch Cypher evaluation for log file: {rag_interaction_log_filepath}")
    batch_cypher_eval_logger.info(f"Parameters: app_version='{app_version}', use_simulated_api={use_simulated_api}, api_call_delay={api_call_delay}s")
    batch_cypher_eval_logger.info(f"Target task types: {target_task_types}")
    batch_cypher_eval_logger.info(f"Field mapping: {field_mapping}")

    processed_count = 0
    evaluated_count = 0
    skipped_no_cypher_count = 0
    failed_to_extract_count = 0
    skipped_task_type_mismatch = 0

    if use_simulated_api:
        batch_cypher_eval_logger.warning("Batch Cypher evaluation is USING SIMULATED Gemini responses.")
    else:
        batch_cypher_eval_logger.info("Batch Cypher evaluation is using REAL Gemini API calls.")

    interaction_logs = load_jsonl_file(rag_interaction_log_filepath)

    if not interaction_logs:
        batch_cypher_eval_logger.error(f"No data loaded from RAG interaction log file: {rag_interaction_log_filepath}. Exiting.")
        return {"processed": 0, "evaluated": 0, "skipped_no_cypher":0, "failed_extract": 0, "skipped_task_type_mismatch":0, "file_not_found_or_empty": 1}

    if isinstance(target_task_types, str):
        target_task_types_list = [target_task_types]
    else:
        target_task_types_list = target_task_types

    default_field_map = {
        "user_query": ["user_query_for_task", "user_query", "original_user_query"],
        "generated_cypher": ["raw_llm_output", "processed_llm_output"], # raw_llm_output for cypher_generation_final_attempt_local_service
        "interaction_id": ["interaction_id", "original_interaction_id"]
    }
    current_field_map = default_field_map.copy()
    if field_mapping:
        for key, value in field_mapping.items():
            if isinstance(value, str):
                current_field_map[key] = [value]
            else:
                current_field_map[key] = value

    def get_field_value(log_entry: Dict[str, Any], field_key: str) -> Any:
        for actual_field_name in current_field_map.get(field_key, []):
            if actual_field_name in log_entry:
                return log_entry[actual_field_name]
        return None

    for line_number, interaction_log in enumerate(interaction_logs, 1):
        processed_count += 1
        current_task_type = interaction_log.get("task_type")

        if current_task_type not in target_task_types_list:
            skipped_task_type_mismatch +=1
            continue
            
        batch_cypher_eval_logger.debug(f"DEBUG_CYPHER_EVAL: Processing log entry {line_number} with task_type '{current_task_type}'")

        user_question = get_field_value(interaction_log, "user_query")
        generated_cypher_raw = get_field_value(interaction_log, "generated_cypher")
        original_id = get_field_value(interaction_log, "interaction_id")

        if user_question and original_id:
            generated_cypher_to_eval = None # 初始化
            if isinstance(generated_cypher_raw, str) and generated_cypher_raw.strip():
                # 对于 "kg_executed_query_for_eval" 类型的日志，"generated_query" 字段直接包含SQL语句
                # 我们假设字段映射已将 "generated_query" 映射到 generated_cypher_raw
                generated_cypher_to_eval = generated_cypher_raw.strip()
                batch_cypher_eval_logger.debug(f"Extracted query for eval (ID: {original_id}): '{generated_cypher_to_eval[:100]}...'")
            else:
                batch_cypher_eval_logger.warning(f"Log entry for ID {original_id} (task_type: {current_task_type}) has empty or non-string 'generated_query' (mapped to generated_cypher_raw). Value: {generated_cypher_raw}")

            if not generated_cypher_to_eval: # 再次检查，确保 generated_cypher_to_eval 有有效值
                batch_cypher_eval_logger.info(f"Skipping evaluation for interaction_id '{original_id}' as extracted Cypher is empty.")
                skipped_no_cypher_count += 1
                continue
            
            # We will evaluate "无法生成Cypher查询." as well, Gemini should score it appropriately.
            batch_cypher_eval_logger.info(f"Evaluating Cypher for interaction_id: {original_id} - User Question: {str(user_question)[:50]}... - Cypher: {str(generated_cypher_to_eval)[:100]}...")
            
            evaluation_result = await evaluate_cypher_with_gemini(
                gemini_resource=gemini_resource_for_evaluator,
                user_question=str(user_question),
                generated_cypher=str(generated_cypher_to_eval),
                original_interaction_id=str(original_id),
                app_version=app_version
            )

            if evaluation_result:
                evaluated_count += 1
                summary = evaluation_result.get("evaluation_summary", {})
                overall_score = summary.get("overall_quality_score_cypher", "N/A")
                batch_cypher_eval_logger.info(f"Successfully evaluated Cypher for interaction_id: {original_id}. Overall Score: {overall_score}")
            else:
                batch_cypher_eval_logger.warning(f"Cypher evaluation returned None or failed for interaction_id: {original_id}")
            
            if not use_simulated_api and evaluated_count > 0:
                batch_cypher_eval_logger.info(f"Waiting for {api_call_delay} seconds before next API call...")
                await asyncio.sleep(api_call_delay)
        else:
            failed_to_extract_count += 1
            batch_cypher_eval_logger.warning(f"Skipping cypher_generation log entry {line_number} due to missing user_query or interaction_id. Log content: {str(interaction_log)[:200]}...")
        
        if processed_count > 0 and processed_count % 10 == 0:
            batch_cypher_eval_logger.info(f"Progress: Processed {processed_count} log entries. Evaluated {evaluated_count} Cypher queries. Skipped (no cypher): {skipped_no_cypher_count}. Failed extract: {failed_to_extract_count}. Type mismatch: {skipped_task_type_mismatch}")

    summary = {
        "total_log_entries_read": processed_count,
        "target_task_type_entries_found": processed_count - skipped_task_type_mismatch,
        "cypher_queries_evaluated_successfully": evaluated_count,
        "skipped_empty_or_no_cypher": skipped_no_cypher_count,
        "failed_to_extract_fields_for_eval": failed_to_extract_count
    }
    batch_cypher_eval_logger.info(f"Batch Cypher evaluation finished. Summary: {summary}")
    return summary


if __name__ == "__main__":
    try:
        from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import GeminiAPIResource, GeminiAPIResourceConfig
        
        gemini_model_name_env = os.getenv("GEMINI_MODEL_FOR_EVAL", "gemini/gemini-1.5-flash-latest")
        gemini_proxy_url_env = os.getenv("LITELLM_PROXY_URL") 

        gemini_resource_config = GeminiAPIResourceConfig(
            model_name=gemini_model_name_env,
            proxy_url=gemini_proxy_url_env
        )
        gemini_eval_resource = GeminiAPIResource(
            model_name=gemini_resource_config.model_name,
            proxy_url=gemini_resource_config.proxy_url,
            default_temperature=gemini_resource_config.default_temperature,
            default_max_tokens=gemini_resource_config.default_max_tokens
        )
        class MockContext: 
            def __init__(self):
                self.log = batch_cypher_eval_logger
        
        if hasattr(gemini_eval_resource, 'setup_for_execution'):
             gemini_eval_resource.setup_for_execution(MockContext())
        batch_cypher_eval_logger.info(f"GeminiAPIResource for Cypher evaluation initialized successfully.")

    except ImportError:
        batch_cypher_eval_logger.critical("CRITICAL: Could not import GeminiAPIResource. Ensure Dagster modules are in PYTHONPATH or installed.")
        gemini_eval_resource = None
    except Exception as e_res_init:
        batch_cypher_eval_logger.critical(f"CRITICAL: Error initializing GeminiAPIResource: {e_res_init}", exc_info=True)
        gemini_eval_resource = None

    log_file_to_evaluate = find_latest_rag_interaction_log(RAG_INTERACTION_LOGS_DIR)
    use_simulated_env = os.getenv("USE_SIMULATED_GEMINI_CYPHER_EVAL", "false").lower() == "true"
    api_delay_env = float(os.getenv("GEMINI_API_CALL_DELAY_SECONDS", "4.1"))
    app_version_tag_env = os.getenv("APP_VERSION_TAG", "0.1.4_batch_cypher_flexible")
    if use_simulated_env:
        app_version_tag_env += "_simulated"

    # --- 配置目标 task_type 和字段映射 ---
    cypher_gen_task_types = ["kg_executed_query_for_eval"] # <--- 查找新的 task_type
    cypher_gen_field_map = {
        "user_query": "user_query_for_task",      # 这个字段名在新的日志条目中是存在的
        "generated_cypher": "generated_query",    # 新的日志条目中，查询语句存储在 "generated_query" 字段
        "interaction_id": "interaction_id"        # interaction_id 仍然是主键
    }

    if not gemini_eval_resource:
        batch_cypher_eval_logger.error("Cannot proceed with Cypher evaluation as GeminiAPIResource is not available.")
    elif log_file_to_evaluate:
        batch_cypher_eval_logger.info(f"Found RAG interaction log to process for Cypher evaluation: {log_file_to_evaluate}")
        asyncio.run(run_cypher_batch_evaluation(
            gemini_resource_for_evaluator=gemini_eval_resource,
            rag_interaction_log_filepath=log_file_to_evaluate,
            app_version=app_version_tag_env,
            use_simulated_api=use_simulated_env,
            api_call_delay=api_delay_env,
            target_task_types=cypher_gen_task_types, # <--- 使用修改后的 task_types
            field_mapping=cypher_gen_field_map
        ))

    elif use_simulated_env:
        batch_cypher_eval_logger.warning(f"RAG interaction log file not found, but USE_SIMULATED_GEMINI_CYPHER_EVAL is true. Running with a dummy path.")
        if gemini_eval_resource:
            asyncio.run(run_cypher_batch_evaluation(
                gemini_resource_for_evaluator=gemini_eval_resource,
                rag_interaction_log_filepath="dummy_non_existent_file.jsonl", 
                app_version=app_version_tag_env + "_no_file",
                use_simulated_api=use_simulated_env,
                api_call_delay=api_delay_env,
                target_task_types=cypher_gen_task_types,
                field_mapping=cypher_gen_field_map
            ))
        else:
            batch_cypher_eval_logger.error("GeminiAPIResource for Cypher evaluation could not be initialized (even for simulated run). Aborting.")
    else:
        batch_cypher_eval_logger.warning(f"No suitable RAG interaction log file found in '{RAG_INTERACTION_LOGS_DIR}' and not using simulated responses. Batch Cypher evaluation will not run.")
```

    |-- evaluator.py

``` py
# 文件: zhz_rag/evaluation/evaluator.py
import os
import json
import traceback
import google.generativeai as genai
from typing import Dict, Any, Optional, TYPE_CHECKING, List

from zhz_rag.config.constants import NEW_KG_SCHEMA_DESCRIPTION as KG_SCHEMA_FOR_EVALUATION
from ..utils.interaction_logger import log_interaction_data

if TYPE_CHECKING:
    from ..config.pydantic_models import RetrievedDocument
    from ..utils.gemini_api_utils import GeminiAPIClient

import logging

eval_logger = logging.getLogger("EvaluationLogger")
if not eval_logger.hasHandlers():
    _eval_console_handler = logging.StreamHandler()
    _eval_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _eval_console_handler.setFormatter(_eval_formatter)
    eval_logger.addHandler(_eval_console_handler)
    eval_logger.propagate = False
eval_logger.info("--- EvaluationLogger configured ---")

# (此处省略两个非常长的Prompt字符串 CYPHER_EVALUATION_PROMPT_V1 和 ANSWER_EVALUATION_PROMPT_V1，请保留您文件中的原样)
CYPHER_EVALUATION_PROMPT_V1 = """You are an expert Neo4j Cypher query evaluator and debugging assistant. Your primary task is to meticulously analyze a Cypher query that was generated by another AI model (Qwen2.5-3B, a 3 billion parameter model) in response to a user's natural language question. Your evaluation must be based on the provided knowledge graph schema and the specific evaluation criteria outlined below.

**IMPORTANT SCHEMA CONTEXT (KG_SCHEMA_DESCRIPTION):**
Use code with caution.
Python
{{KG_SCHEMA_DESCRIPTION}}
**USER'S NATURAL LANGUAGE QUESTION:**
Use code with caution.
{{USER_QUESTION}}
**GENERATED CYPHER QUERY TO EVALUATE:**
Use code with caution.
{{GENERATED_CYPHER}}
**EVALUATION TASK:**

Please evaluate the "GENERATED CYPHER QUERY" based on the following criteria. Provide your evaluation in a **valid JSON format** strictly adhering to the structure specified at the end.

**EVALUATION CRITERIA:**

1.  **Syntactic Correctness:**
    *   Is the Cypher query syntactically valid and parsable by Neo4j?
    *   Score (1-5): 1 = Major syntax errors, unparsable; 3 = Minor issues, likely parsable with warnings; 5 = Syntactically perfect.
    *   Reasoning: Explain your score. If errors exist, briefly describe them.

2.  **Schema Adherence (Strictly based on the provided KG_SCHEMA_DESCRIPTION):**
    *   **Node Label Correctness:**
        *   Check: Does the query exclusively use ':ExtractedEntity' for all node patterns? (True/False)
        *   Detail: Briefly explain.
    *   **Entity Type via `label` Property Correctness:**
        *   Check: Are entity types (e.g., 'PERSON', 'ORGANIZATION', 'TASK') correctly queried using the `label` property of ':ExtractedEntity' nodes (e.g., `WHERE n.label = 'PERSON'`)? (True/False)
        *   Detail: Briefly explain.
    *   **Relationship Type and Direction Correctness:**
        *   Check: Does the query use only defined relationship types (e.g., `:WORKS_AT`, `:ASSIGNED_TO`) and their correct directions as specified in the schema? (True/False)
        *   Detail: Briefly explain.
    *   **Property Name Correctness:**
        *   Check: Does the query use only valid property names for nodes and relationships (e.g., `text`, `label` for nodes)? (True/False)
        *   Detail: Briefly explain.
    *   **Hallucinated Schema Elements:**
        *   Check: Does the query reference any labels, relationship types, or properties NOT defined in the schema? (True/False - True if hallucination is present)
        *   Detail: List any hallucinated elements.
    *   **Overall Schema Adherence Score (1-5):** Based on the sub-checks above, provide an overall schema adherence score. Explain your reasoning, considering the severity and number of any deviations. Perfect adherence means all sub-checks are True and no hallucinations are present. 1 = Gross violations; 3 = Some minor deviations; 5 = Perfectly adheres to schema.
    *   Reasoning for Overall Schema Adherence Score: Provide the explanation here.

3.  **Intent Accuracy (Semantic Correctness):**
    *   Score (1-5): 1 = Completely misses user intent; 3 = Partially addresses intent but has significant gaps or inaccuracies; 5 = Accurately and fully captures user intent.
    *   Explanation of Cypher Retrieval: In simple natural language that an average office worker could understand, what information would this Cypher query retrieve from a graph that matches the schema?
    *   Alignment with User Question: How well does this retrieved information align with what the user was asking in their "USER'S NATURAL LANGUAGE QUESTION"?
    *   Key Element Coverage: Does the Cypher query attempt to address all key entities, relationships, and conditions mentioned in the user's question? If not, what specific parts of the question seem to be missing or misinterpreted in the Cypher query?
    *   Reasoning: Explain your intent accuracy score, considering the explanation, alignment, and key element coverage.

4.  **Identification of Potential Qwen2.5-3B Error Patterns (Optional but helpful):**
    *   Based on your knowledge of smaller LLMs, does this query exhibit any common error patterns such as:
        *   Over-simplification of complex conditions?
        *   Incorrect handling of the ':ExtractedEntity' and 'label' property convention?
        *   Ignoring multiple constraints from the user question?
        *   Other (please specify)?
    *   Observed Patterns: List any observed patterns from the predefined list, or provide an empty list [] if none of the predefined patterns are clearly observed.

**OUTPUT JSON STRUCTURE (Strictly follow this format):**
```json
{
  "evaluation_summary": {
    "overall_quality_score_cypher": "<Integer score 1-5, your overall judgment of the Cypher query's quality. **Crucially, assign higher weight to 'Schema Adherence' and 'Intent Accuracy'.** A query with perfect syntax but critical flaws in schema adherence or intent accuracy should NOT receive a high overall score.>",
    "main_strength_cypher": "<Briefly describe the main strength of this Cypher query, if any>",
    "main_weakness_cypher": "<Briefly describe the main weakness or most critical issue>"
  },
  "dimensions": {
    "syntactic_correctness": {
      "score": "<Integer score 1-5>",
      "parsable_prediction": "<Boolean: true/false>",
      "reasoning": "<Text explanation>"
    },
    "schema_adherence": {
      "overall_score": "<Integer score 1-5>",
      "node_label_correctness": { "check_result": "<Boolean>", "detail": "<Text>" },
      "entity_type_property_correctness": { "check_result": "<Boolean>", "detail": "<Text>" },
      "relationship_type_correctness": { "check_result": "<Boolean>", "detail": "<Text>" },
      "property_name_correctness": { "check_result": "<Boolean>", "detail": "<Text>" },
      "hallucinated_schema_elements": { "check_result_hallucination_present": "<Boolean>", "elements_found": ["<List of strings or empty list>"] },
      "reasoning": "<Text explanation for overall schema adherence score>"
    },
    "intent_accuracy": {
      "score": "<Integer score 1-5>",
      "explanation_of_cypher_retrieval": "<Text>",
      "semantic_alignment_with_question": "<Text>",
      "key_element_coverage_notes": "<Text describing coverage of key elements, and what's missing/misinterpreted, if any>",
      "reasoning": "<Text explanation for intent accuracy score>"
    }
  },
  "qwen_error_patterns_identified": ["<List of strings describing observed patterns, or empty list>"],
  "suggestion_for_improvement_cypher": "<Actionable suggestions to improve this specific Cypher query, if applicable>"
}
```"""

ANSWER_EVALUATION_PROMPT_V1 = """
You are an expert AI Answer Evaluator, specializing in assessing the quality of responses from a Retrieval Augmented Generation (RAG) system designed as an "Office Worker Assistant". Your evaluation must be objective, strictly based on the provided user question, the context the RAG system used, and the generated answer.

**USER'S NATURAL LANGUAGE QUESTION:**
Use code with caution.
Python
{{USER_QUESTION}}
**CONTEXT PROVIDED TO THE RAG SYSTEM'S GENERATION MODEL (this is the information the AI had to base its answer on):**
Use code with caution.
{{RETRIEVED_CONTEXTS}}
**AI-GENERATED ANSWER TO EVALUATE:**
Use code with caution.
{{GENERATED_ANSWER}}
**EVALUATION TASK:**

Please evaluate the "AI-GENERATED ANSWER" based on the following criteria. For each dimension, provide a score from 1 to 5 (where 5 is best) and a brief reasoning for your score. Also, if applicable, identify specific phrases or sentences in the answer that exemplify an issue.

**EVALUATION DIMENSIONS & SCORING GUIDELINES:**

1.  **Faithfulness/Traceability (Score 1-5):**
    *   Is all factual information in the answer directly supported by the "CONTEXT PROVIDED"?
    *   Does the answer avoid making up information (hallucinations) or contradicting the context?
    *   **5 (Completely Faithful):** All key factual claims in the answer are directly and accurately supported by the context. No external information introduced.
    *   **4 (Mostly Faithful):** The vast majority of factual claims are supported. May contain very minor, reasonable inferences closely tied to the context, but no direct contradictions.
    *   **3 (Partially Faithful):** Some key claims are supported, but there are noticeable unsupported claims, slight misinterpretations of the context, or minor, non-critical hallucinations.
    *   **2 (Minimally Faithful):** Significant portions of the answer are not supported by the context, or there are clear contradictions or misleading hallucinations.
    *   **1 (Not Faithful):** The answer is largely based on information 외부 from the context, contains severe hallucinations, or directly contradicts the context.

2.  **Relevance to User Query (Score 1-5):**
    *   Does the answer directly and precisely address the "USER'S NATURAL LANGUAGE QUESTION"?
    *   **5 (Perfectly Relevant):** Directly and fully answers the user's core question(s).
    *   **4 (Highly Relevant):** Accurately answers the main aspects of the question; minor aspects might be less directly addressed.
    *   **3 (Moderately Relevant):** Addresses parts of the question but may miss key aspects or include some less relevant information.
    *   **2 (Slightly Relevant):** Touches upon the topic of the question but largely misses the core intent.
    *   **1 (Not Relevant):** Does not answer the user's question at all.

3.  **Completeness (Score 1-5):**
    *   **First, assess Context Sufficiency:** Based *only* on the "CONTEXT PROVIDED", does it seem to contain enough information to fully answer the "USER'S NATURAL LANGUAGE QUESTION"? (Answer: "Sufficient", "Partially Sufficient", or "Insufficient"). Provide a brief reason for your assessment of context sufficiency.
    *   **Then, score Completeness based on the answer's performance given the context:**
        *   Does the answer address all aspects of the user's query, making good use of the relevant information available in the context?
        *   If the context was insufficient, does the answer appropriately acknowledge this or focus on what can be answered?
        *   **5 (Very Complete):** (If context sufficient) Fully addresses all aspects of the query using all relevant context. (If context insufficient) Makes the best use of available context and clearly indicates limitations.
        *   **4 (Mostly Complete):** (If context sufficient) Addresses main aspects, minor details from context might be missed. (If context insufficient) Good use of available context, fair indication of limitations.
        *   **3 (Partially Complete):** (If context sufficient) Misses some important aspects or underutilizes relevant context. (If context insufficient) Poor use of available context or unclear about limitations.
        *   **2 (Slightly Complete):** (If context sufficient) Addresses only a small part, much relevant context ignored. (If context insufficient) Very poor use of limited context.
        *   **1 (Not Complete):** Fails to address the query meaningfully, even if relevant context was available.

4.  **Coherence/Fluency (Score 1-5):**
    *   Is the answer well-written, grammatically correct, logically structured, and easy to understand?
    *   **5 (Very Fluent):** Perfectly written, clear, natural, and easy to understand. No grammatical errors.
    *   **4 (Fluent):** Well-written, mostly clear, minor or no grammatical errors.
    *   **3 (Moderately Fluent):** Understandable, but may have some awkward phrasing or minor grammatical errors that don't impede core understanding.
    *   **2 (Slightly Fluent):** Difficult to understand due to grammatical errors, awkward phrasing, or poor logical flow.
    *   **1 (Not Fluent):** Largely incomprehensible.

5.  **Actionability & Usability (for an Office Worker Assistant) (Score 1-5):**
    *   Does the answer provide clear, practical, and easy-to-understand steps, information, or suggestions that would directly help an office worker achieve their task or make a decision?
    *   **5 (Highly Actionable & Usable):** Provides clear, specific, and immediately applicable steps/information. Language is professional and easy for an office worker to understand. Format facilitates quick information retrieval.
    *   **4 (Mostly Actionable & Usable):** Provides generally clear guidance or useful information. Might require minor clarification for full actionability, or presentation could be slightly improved, but core content is helpful.
    *   **3 (Partially Actionable & Usable):** Offers some relevant information or suggestions, but lacks specific steps, is too vague for direct action, or requires significant effort to understand/apply.
    *   **2 (Minimally Actionable & Usable):** Contains some related information but no clear action plan, is impractical, or very difficult to understand/use. Offers little practical help.
    *   **1 (Not Actionable & Unusable):** Provides no actionable information, is irrelevant to practical office tasks, or is misleading/confusing.

**OUTPUT JSON STRUCTURE (Strictly follow this format):**
```json
{
  "evaluation_summary": {
    "overall_answer_quality_score": "<Integer score 1-5, your overall judgment of the answer's quality, considering all dimensions. Faithfulness and Relevance are most critical.>",
    "main_strengths_answer": "<Briefly describe the main strength(s) of this answer, if any. Be specific.>",
    "main_weaknesses_answer": "<Briefly describe the main weakness(es) or most critical issue(s) with this answer. Be specific.>"
  },
  "dimensions": {
    "faithfulness": {
      "score": "<Integer score 1-5>",
      "reasoning": "<Text explanation for faithfulness score. If not fully faithful, specify which parts are unsupported or hallucinated, referencing the answer text.>",
      "problematic_answer_segments_faithfulness": ["<List of specific phrases/sentences from the answer that are not faithful, or empty list if none>"]
    },
    "relevance": {
      "score": "<Integer score 1-5>",
      "reasoning": "<Text explanation for relevance score. Explain how well it addresses the user's core question.>"
    },
    "completeness": {
      "context_sufficiency_assessment": "<String: 'Sufficient', 'Partially Sufficient', or 'Insufficient'>",
      "context_sufficiency_reasoning": "<Brief reason for the context sufficiency assessment. If not sufficient, what key information is missing from the context?>",
      "score": "<Integer score 1-5, based on how well the answer uses the available context to address the query>",
      "reasoning": "<Text explanation for completeness score. If not fully complete, what aspects of the query were missed, or what relevant context was underutilized? If context was insufficient, how well did the answer handle this?>"
    },
    "coherence_fluency": {
      "score": "<Integer score 1-5>",
      "reasoning": "<Text explanation for coherence/fluency score. Note any grammatical issues or awkward phrasing.>"
    },
    "actionability_usability": {
      "score": "<Integer score 1-5>",
      "reasoning": "<Text explanation for actionability/usability score, considering an office worker context.>"
    }
  },
  "suggestion_for_answer_improvement": "<Provide specific, actionable suggestions on how this AI-generated answer could be improved, if applicable. If excellent, state 'No improvement needed'.>"
}
Use code with caution.
FEW-SHOT EXAMPLES:
Example 1: Good Answer
USER'S NATURAL LANGUAGE QUESTION:
如何申请本年度的带薪年假，并确保符合公司规定？
Use code with caution.
CONTEXT PROVIDED TO THE RAG SYSTEM'S GENERATION MODEL:
上下文片段1 (来源: 公司政策文档):
员工每年享有15天带薪年假。申请年假需通过公司内部HRM系统提交，并至少提前两周提出。所有年假申请必须得到直属经理的批准。未经批准的休假将按事假处理。

上下文片段2 (来源: HRM系统操作指南):
HRM系统年假申请流程：1. 登录HRM门户 (hrm.example-company.com)。 2. 导航至“我的假期”->“假期申请”。 3. 选择“年假”类型，填写休假起止日期和休假天数。 4. 在备注中简要说明休假事由（可选）。 5. 提交申请，等待经理审批。审批状态可在系统中实时查看。

上下文片段3 (来源: 知识图谱精确信息):
事实: 年假政策规定 -> 提前申请周期: 2周。
事实: 年假政策规定 -> 审批人: 直属经理。
事实: 年假政策规定 -> 年假天数上限: 15天/年。
Use code with caution.
AI-GENERATED ANSWER TO EVALUATE:
您可以按照以下步骤申请本年度的带薪年假并确保符合公司规定：

1.  **提前规划与提交：** 根据公司政策，您需要至少提前两周提交年假申请。
2.  **通过HRM系统申请：**
    *   登录公司HRM门户网站：hrm.example-company.com
    *   进入“我的假期”模块，然后选择“假期申请”。
    *   选择“年假”类型，并准确填写您希望休假的起止日期和天数。
3.  **获取经理批准：** 所有年假申请都必须得到您直属经理的批准。提交申请后，请留意系统中的审批状态。
4.  **年假额度：** 请注意，公司规定员工每年享有15天带薪年假。

请确保您的申请符合以上规定，以顺利安排您的休假。
Use code with caution.
EXPECTED EVALUATION JSON OUTPUT:
{
  "evaluation_summary": {
    "overall_answer_quality_score": 5,
    "main_strengths_answer": "答案准确、完整、步骤清晰，非常实用。",
    "main_weaknesses_answer": "无明显缺点。"
  },
  "dimensions": {
    "faithfulness": {
      "score": 5,
      "reasoning": "答案中的所有信息点（提前两周、HRM系统操作、经理批准、15天年假）均能在提供的上下文中找到明确依据，无任何捏造。",
      "problematic_answer_segments_faithfulness": []
    },
    "relevance": {
      "score": 5,
      "reasoning": "答案完美地回应了用户关于年假申请流程和合规性的问题。"
    },
    "completeness": {
      "context_sufficiency_assessment": "Sufficient",
      "context_sufficiency_reasoning": "上下文提供了申请年假所需的所有核心信息（流程、提前时间、审批人、额度）。",
      "score": 5,
      "reasoning": "答案全面覆盖了用户问题的各个方面，并充分利用了上下文中的所有关键信息，包括操作步骤和政策规定。"
    },
    "coherence_fluency": {
      "score": 5,
      "reasoning": "答案语言表达清晰、专业，逻辑步骤明确，易于理解。"
    },
    "actionability_usability": {
      "score": 5,
      "reasoning": "答案提供了非常清晰、可直接执行的申请步骤，并点明了关键的合规性要求，对办公室员工非常实用且易于操作。"
    }
  },
  "suggestion_for_answer_improvement": "No improvement needed."
}
Use code with caution.
Json
Example 2: Answer with Hallucination
USER'S NATURAL LANGUAGE QUESTION:
我们公司最新的季度IT安全演练是什么时候举行的，主要发现了哪些问题？
Use code with caution.
CONTEXT PROVIDED TO THE RAG SYSTEM'S GENERATION MODEL:
上下文片段1 (来源: 内部邮件):
主题：关于第三季度IT安全意识培训的通知
内容：各位同事，为提升全员信息安全意识，公司计划于8月15日举行第三季度IT安全意识培训，主要内容包括密码安全、钓鱼邮件识别等。请大家准时参加。

上下文片段2 (来源: IT部门公告):
IT服务台提醒：近期发现多起针对财务部门的仿冒邮件，请大家提高警惕，不要点击不明链接。如有疑问，请及时联系IT支持。演练活动将在下月进行。
Use code with caution.
AI-GENERATED ANSWER TO EVALUATE:
公司最新的季度IT安全演练已于上个月（7月）成功举行。演练主要发现了两个问题：一是部分员工的办公电脑未及时更新防病毒软件，二是演练中模拟的钓鱼邮件成功欺骗了约15%的员工。后续将加强相关培训。
Use code with caution.
EXPECTED EVALUATION JSON OUTPUT:
{
  "evaluation_summary": {
    "overall_answer_quality_score": 1,
    "main_strengths_answer": "答案结构尚可。",
    "main_weaknesses_answer": "答案内容完全是编造的（幻觉），与提供的上下文信息完全不符，具有严重误导性。"
  },
  "dimensions": {
    "faithfulness": {
      "score": 1,
      "reasoning": "答案中关于演练已于7月举行、发现的两个具体问题（未更新防病毒软件、15%员工被钓鱼邮件欺骗）在上下文中完全找不到任何依据，是严重的幻觉。",
      "problematic_answer_segments_faithfulness": ["演练已于上个月（7月）成功举行。", "演练主要发现了两个问题：一是部分员工的办公电脑未及时更新防病毒软件，二是演练中模拟的钓鱼邮件成功欺骗了约15%的员工。"]
    },
    "relevance": {
      "score": 2,
      "reasoning": "答案表面上回应了问题（演练时间和问题），但由于内容是虚假的，其实际相关性很低。"
    },
    "completeness": {
      "context_sufficiency_assessment": "Partially Sufficient",
      "context_sufficiency_reasoning": "上下文提到了计划中的培训和演练（下月进行），以及一些安全问题（仿冒邮件），但没有给出已完成演练的具体时间和发现的问题。",
      "score": 1,
      "reasoning": "答案完全没有利用上下文中的有效信息（如计划中的培训和演练），而是编造了内容。"
    },
    "coherence_fluency": {
      "score": 4,
      "reasoning": "答案的语言表达本身是通顺的，语法基本正确。"
    },
    "actionability_usability": {
      "score": 1,
      "reasoning": "虚假的信息完全不可用，且具有误导性，对办公室工作有害无益。"
    }
  },
  "suggestion_for_answer_improvement": "AI模型必须严格基于提供的上下文生成答案，严禁编造任何上下文中未提及的事实。如果上下文信息不足，应明确指出。"
}
Use code with caution.
Json
Example 3: Incomplete Answer
USER'S NATURAL LANGUAGE QUESTION:
请总结一下我们和ABC公司最近一次会议的主要议题和达成的三项关键共识。
Use code with caution.
CONTEXT PROVIDED TO THE RAG SYSTEM'S GENERATION MODEL:
上下文片段1 (来源: 会议纪要 - ABC公司会议_20250515.docx):
会议日期：2025年5月15日
与会方：我方（李明、王芳），ABC公司（张总、赵经理）
主要议题：
1.  回顾Q1合作项目进展。
2.  讨论Q2新产品联合推广计划。
3.  探讨长期战略合作框架。
关键共识：
1.  双方同意Q1项目按计划完成，成果符合预期。
2.  Q2新产品联合推广预算初定为50万，具体方案下周讨论。
3.  双方均表达了加强长期战略合作的意愿，将成立联合工作组进一步商议。
4.  下次会议暂定于6月初。
Use code with caution.
AI-GENERATED ANSWER TO EVALUATE:
我们和ABC公司最近一次会议（2025年5月15日）的主要议题包括回顾Q1项目进展和讨论Q2新产品联合推广计划。会议达成的一项关键共识是双方同意Q1项目按计划完成。
Use code with caution.
EXPECTED EVALUATION JSON OUTPUT:
{
  "evaluation_summary": {
    "overall_answer_quality_score": 3,
    "main_strengths_answer": "答案忠实于上下文，相关性较好，语言通顺。",
    "main_weaknesses_answer": "答案在完整性方面有明显不足，遗漏了多个重要议题和关键共识。"
  },
  "dimensions": {
    "faithfulness": {
      "score": 5,
      "reasoning": "答案中提到的信息点（会议日期、部分议题、一项共识）均能在上下文中找到准确依据。",
      "problematic_answer_segments_faithfulness": []
    },
    "relevance": {
      "score": 4,
      "reasoning": "答案回应了用户关于会议议题和共识的问题，但不够全面。"
    },
    "completeness": {
      "context_sufficiency_assessment": "Sufficient",
      "context_sufficiency_reasoning": "上下文详细列出了3个主要议题和4项关键共识，足以完整回答用户问题。",
      "score": 2,
      "reasoning": "答案严重不完整。议题方面遗漏了“探讨长期战略合作框架”。关键共识方面，用户要求三项，但答案只给出了一项，遗漏了“Q2推广预算初定”、“加强长期战略合作意愿将成立工作组”这两项重要共识（甚至还有第四项共识也未提及）。"
    },
    "coherence_fluency": {
      "score": 5,
      "reasoning": "答案语言表达清晰、语法正确。"
    },
    "actionability_usability": {
      "score": 3,
      "reasoning": "答案提供了一些信息，但由于信息不完整，其实用性打了折扣。用户可能需要再次查找才能获得全部关键信息。"
    }
  },
  "suggestion_for_answer_improvement": "答案应更全面地从上下文中提取信息。应完整列出所有主要议题，并至少满足用户要求的三个关键共识。例如，可以补充：'其他主要议题还包括探讨长期战略合作框架。达成的其他关键共识有：Q2新产品联合推广预算初定为50万；双方将成立联合工作组进一步商议加强长期战略合作的意愿。'"
}
Use code with caution.
Json
NOW, EVALUATE THE FOLLOWING:
USER'S NATURAL LANGUAGE QUESTION:
{{USER_QUESTION}}
Use code with caution.
CONTEXT PROVIDED TO THE RAG SYSTEM'S GENERATION MODEL (this is the information the AI had to base its answer on):
{{RETRIEVED_CONTEXTS}}
Use code with caution.
AI-GENERATED ANSWER TO EVALUATE:
{{GENERATED_ANSWER}}
Use code with caution.
YOUR EVALUATION (Strictly in the JSON format defined above):
// Your JSON output here
Use code with caution.
Json
"""



async def evaluate_cypher_with_gemini(
    gemini_resource_for_evaluator: "GeminiAPIClient",
    user_question: str,
    generated_cypher: str,
    original_interaction_id: Optional[str] = None,
    app_version: str = "0.1.0"
) -> Optional[Dict[str, Any]]:
    eval_logger.info(f"Starting Cypher evaluation. User question: '{user_question[:50]}...', Cypher: '{generated_cypher[:100]}...'")

    prompt_to_gemini = CYPHER_EVALUATION_PROMPT_V1.replace(
        "{{KG_SCHEMA_DESCRIPTION}}", KG_SCHEMA_FOR_EVALUATION
    ).replace(
        "{{USER_QUESTION}}", user_question
    ).replace(
        "{{GENERATED_CYPHER}}", generated_cypher
    )
    evaluation_result_json: Optional[Dict[str, Any]] = None
    raw_gemini_output: Optional[str] = None
    error_info: Optional[str] = None
    model_name_for_log = "gemini-1.5-flash-latest"

    try:
        eval_logger.info(f"Calling Gemini for Cypher evaluation. Model: {model_name_for_log}. Prompt length: {len(prompt_to_gemini)}")
        gemini_model = gemini_resource_for_evaluator.get_model(model_name_for_log)
        if not gemini_model:
            raise ValueError("Failed to get Gemini model from the client for Cypher eval.")

        response = await gemini_model.generate_content_async(
            contents=prompt_to_gemini,
            generation_config=genai.types.GenerationConfig(temperature=0.1)
        )
        raw_gemini_output = response.text

        if raw_gemini_output:
            cleaned_output = raw_gemini_output.strip()
            if cleaned_output.startswith("```json"):
                cleaned_output = cleaned_output[len("```json"):].strip()
            if cleaned_output.endswith("```"):
                cleaned_output = cleaned_output[:-len("```")].strip()
            evaluation_result_json = json.loads(cleaned_output)
            eval_logger.info("Successfully parsed Gemini evaluation result for Cypher.")
        else:
            error_info = "Gemini call returned None/empty"
    except Exception as e:
        error_info = f"Error during Gemini call or parsing: {str(e)}"
        raw_gemini_output = raw_gemini_output or str(e)
        eval_logger.error(f"Error in evaluate_cypher_with_gemini: {e}", exc_info=True)
        
    eval_log_data = {
        "task_type": "cypher_evaluation_by_gemini",
        "original_interaction_id_ref": original_interaction_id,
        "user_question_for_eval": user_question,
        "generated_cypher_for_eval": generated_cypher,
        "eval_llm_input_prompt_char_count": len(prompt_to_gemini),
        "eval_llm_model": model_name_for_log,
        "eval_llm_raw_output": raw_gemini_output,
        "eval_llm_processed_output_json": evaluation_result_json,
        "eval_error_info": error_info,
        "application_version": app_version
    }
    await log_interaction_data(
        eval_log_data,
        is_evaluation_result=True,
        evaluation_name_for_file="cypher_gemini_flash"
    )
    return evaluation_result_json

async def evaluate_answer_with_gemini(
    gemini_resource_for_evaluator: "GeminiAPIClient",
    user_question: str,
    retrieved_contexts: List["RetrievedDocument"],
    generated_answer: str,
    original_interaction_id: Optional[str] = None,
    app_version: str = "0.1.0",
    use_simulated_api: bool = False,
    api_call_delay: int = 0
) -> Optional[Dict[str, Any]]:
    context_strings = [
        f"Source Type: {doc.source_type}, Score: {f'{doc.score:.4f}' if isinstance(doc.score, float) else doc.score}\nContent: {doc.content}"
        for doc in retrieved_contexts
    ]
    fused_context_for_prompt = "\n\n---\n\n".join(context_strings)
    eval_logger.info(f"Starting Answer evaluation. User question: '{user_question[:50]}...', Answer: '{generated_answer[:50]}...'")

    prompt_to_gemini = ANSWER_EVALUATION_PROMPT_V1.replace(
        "{{USER_QUESTION}}", user_question
    ).replace(
        "{{RETRIEVED_CONTEXTS}}", fused_context_for_prompt
    ).replace(
        "{{GENERATED_ANSWER}}", generated_answer
    )
    evaluation_result_json: Optional[Dict[str, Any]] = None
    raw_gemini_output: Optional[str] = None
    error_info: Optional[str] = None
    model_name_for_log = "gemini-1.5-flash-latest"

    if use_simulated_api:
        eval_logger.warning("USING SIMULATED GEMINI RESPONSE FOR ANSWER EVALUATION")
        # ... (simulated response logic)
    else:
        try:
            eval_logger.info(f"Calling Gemini for Answer evaluation. Model: {model_name_for_log}. Prompt length: {len(prompt_to_gemini)}")
            gemini_model = gemini_resource_for_evaluator.get_model(model_name_for_log)
            if not gemini_model:
                raise ValueError("Failed to get Gemini model from the client for Answer eval.")

            response = await gemini_model.generate_content_async(
                contents=prompt_to_gemini,
                generation_config=genai.types.GenerationConfig(temperature=0.1)
            )
            raw_gemini_output = response.text

            if raw_gemini_output:
                eval_logger.info(f"Raw Gemini output for Answer eval (first 300 chars): {raw_gemini_output[:300]}...")
                cleaned_output = raw_gemini_output.strip()
                if cleaned_output.startswith("```json"):
                    cleaned_output = cleaned_output[len("```json"):].strip()
                if cleaned_output.endswith("```"):
                    cleaned_output = cleaned_output[:-len("```")].strip()
                evaluation_result_json = json.loads(cleaned_output)
                eval_logger.info("Successfully parsed Gemini evaluation result for Answer.")
            else:
                error_info = "Gemini call returned None/empty for answer"
        except Exception as e:
            error_info = f"Error during Gemini call or parsing: {str(e)}"
            raw_gemini_output = raw_gemini_output or str(e)
            eval_logger.error(f"Error in evaluate_answer_with_gemini: {e}", exc_info=True)

    eval_log_data = {
        "task_type": "answer_evaluation_result",
        "original_interaction_id_ref": original_interaction_id,
        "user_question_for_eval": user_question,
        "retrieved_contexts_for_eval_char_count": len(fused_context_for_prompt),
        "generated_answer_for_eval": generated_answer,
        "eval_llm_input_prompt_char_count": len(prompt_to_gemini),
        "eval_llm_model": model_name_for_log,
        "eval_llm_raw_output": raw_gemini_output,
        "eval_llm_processed_output_json": evaluation_result_json,
        "eval_error_info": error_info,
        "application_version": app_version
    }
    await log_interaction_data(
        log_data=eval_log_data,
        is_evaluation_result=True,
        evaluation_name_for_file="answer_gemini_flash"
    )

    if evaluation_result_json:
        eval_logger.info(f"Answer evaluation completed. Overall score: {evaluation_result_json.get('evaluation_summary', {}).get('overall_answer_quality_score')}")
    else:
        eval_logger.warning("Answer evaluation did not produce a valid JSON result.")
        
    return evaluation_result_json
```

        |-- evaluation_questions_v1.txt
        |-- evaluation_questions_v2.txt
    |-- __init__.py

``` py

```

    |-- embedding_api_service.py

``` py
# zhz_rag/api/embedding_api_service.py

import os
import sys
import logging
from typing import List, Optional
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
import uvicorn
from contextlib import asynccontextmanager
from dotenv import load_dotenv # <--- 确保导入

# --- START: 覆盖这部分代码 ---
# 无论从哪里运行，都确保能找到项目根目录的 .env 文件
# __file__ -> /home/zhz/zhz_agent/zhz_rag/api/embedding_api_service.py
# .parents[0] -> .../api
# .parents[1] -> .../zhz_rag
# .parents[2] -> /home/zhz/zhz_agent
try:
    from pathlib import Path
    project_root = Path(__file__).resolve().parents[2]
    dotenv_path = project_root / '.env'
    if dotenv_path.exists():
        load_dotenv(dotenv_path=dotenv_path)
        print(f"EmbeddingApiService: Successfully loaded .env from absolute path: {dotenv_path}")
    else:
        print(f"EmbeddingApiService: .env file not found at {dotenv_path}. Relying on system environment variables.")
except Exception as e:
    print(f"EmbeddingApiService: Error loading .env file: {e}")
# --- END: 覆盖结束 ---
# --- 配置路径以导入 llama_cpp ---
# 确保 llama_cpp 可被找到
try:
    from llama_cpp import Llama
except ImportError:
    print("FATAL: llama-cpp-python is not installed. Please run 'pip install llama-cpp-python'")
    sys.exit(1)

# --- 日志配置 ---
api_logger = logging.getLogger("EmbeddingApiServiceLogger")
api_logger.setLevel(logging.INFO)
if not api_logger.hasHandlers():
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    api_logger.addHandler(handler)
    api_logger.propagate = False

# --- Pydantic 模型定义 ---
class EmbeddingRequest(BaseModel):
    texts: List[str] = Field(..., description="A list of texts to be embedded.")

class EmbeddingResponse(BaseModel):
    embeddings: List[List[float]] = Field(description="A list of embedding vectors.")
    dimensions: int = Field(description="The dimension of the embedding vectors.")

# --- 全局变量用于缓存模型 ---
embedding_model: Optional[Llama] = None
model_dimension: Optional[int] = None

# --- FastAPI 生命周期管理 ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    global embedding_model, model_dimension
    api_logger.info("--- Embedding API Service: Initializing... ---")
    
    model_path = os.getenv("EMBEDDING_MODEL_PATH")
    n_ctx = int(os.getenv("EMBEDDING_N_CTX", "2048"))
    n_gpu_layers = int(os.getenv("EMBEDDING_N_GPU_LAYERS", "0"))

    if not model_path or not os.path.exists(model_path):
        api_logger.error(f"FATAL: Embedding model path not found or not set in .env: {model_path}")
        raise FileNotFoundError(f"Embedding model not found at {model_path}")

    try:
        api_logger.info(f"Loading embedding model from: {model_path}")
        embedding_model = Llama(
            model_path=model_path,
            embedding=True,
            n_ctx=n_ctx,
            n_gpu_layers=n_gpu_layers,
            verbose=False
        )
        model_dimension = embedding_model.n_embd()
        api_logger.info(f"Embedding model loaded successfully. Dimension: {model_dimension}")
    except Exception as e:
        api_logger.error(f"Failed to load embedding model: {e}", exc_info=True)
        embedding_model = None
        model_dimension = None

    yield

    api_logger.info("--- Embedding API Service: Shutting down. ---")
    # 清理模型（如果需要）
    if embedding_model:
        del embedding_model
        embedding_model = None

# --- FastAPI 应用实例 ---
app = FastAPI(
    title="Standalone Embedding API Service",
    description="A dedicated API service for generating text embeddings using a GGUF model.",
    version="1.0.0",
    lifespan=lifespan
)

# --- API 端点 ---
@app.post("/embed", response_model=EmbeddingResponse)
async def create_embeddings(request: EmbeddingRequest):
    if not embedding_model or not model_dimension:
        raise HTTPException(status_code=503, detail="Embedding model is not available.")
    
    if not request.texts:
        return EmbeddingResponse(embeddings=[], dimensions=model_dimension)
    
    try:
        api_logger.info(f"Received request to embed {len(request.texts)} texts.")
        response = embedding_model.create_embedding(request.texts)
        
        embeddings_raw = response.get('data', [])
        final_embeddings: List[List[float]] = []
        for item in embeddings_raw:
            embedding_data = item.get('embedding', [])
            
            # --- 核心修复：处理可能的嵌套列表 ---
            # 检查embedding_data是否是列表，并且其第一个元素也是列表
            if isinstance(embedding_data, list) and embedding_data and isinstance(embedding_data[0], list):
                # 如果是嵌套列表，我们只取第一个内部列表
                embedding_vector_raw = embedding_data[0]
                api_logger.debug("Detected a nested list in embedding output, taking the first element.")
            else:
                # 否则，我们假设它已经是我们期望的扁平列表
                embedding_vector_raw = embedding_data
            
            # 确保向量中的每个元素都是float
            embedding_vector = [float(x) for x in embedding_vector_raw]
            final_embeddings.append(embedding_vector)
            # --- 修复结束 ---

        api_logger.info(f"Successfully generated {len(final_embeddings)} embeddings.")
        return EmbeddingResponse(embeddings=final_embeddings, dimensions=model_dimension)
    except Exception as e: 
        api_logger.error(f"Error during embedding creation: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to create embeddings: {e}")

@app.get("/health")
async def health_check():
    if embedding_model and model_dimension:
        return {"status": "ok", "model_loaded": True, "dimension": model_dimension}
    else:
        return {"status": "error", "model_loaded": False, "message": "Embedding model failed to load."}

if __name__ == "__main__":
    # 默认运行在 8089 端口，避免与现有服务冲突
    port = int(os.getenv("EMBEDDING_API_PORT", "8089"))
    api_logger.info(f"Starting Embedding API Service on port {port}...")
    uvicorn.run("zhz_rag.api.embedding_api_service:app", host="0.0.0.0", port=port, reload=False)
```

    |-- main_api.py

``` py
# zhz_agent/main.py
from fastapi import FastAPI
from contextlib import asynccontextmanager
import uvicorn
import logging
from typing import Type, List, Dict, Any, Optional, ClassVar

# --- [修改] 导入 -> 改为绝对导入 ---
from zhz_rag.utils.db_utils import database, sqlalchemy_engine, Base, get_scheduler
from zhz_rag.api.task_manager_api import router as tasks_router
from zhz_rag.task_management import db_models # 确保 SQLAlchemy 模型被导入

@asynccontextmanager
async def lifespan(app_instance: FastAPI):
    print("--- Main FastAPI 应用启动 (已集成任务管理API 和 APScheduler) ---") # [修改] 更新了描述

    # --- 数据库初始化 ---
    await database.connect()
    print("数据库已连接。")
    try:
        Base.metadata.create_all(bind=sqlalchemy_engine)
        print("数据库表已执行 create_all。")
        from sqlalchemy import inspect
        inspector = inspect(sqlalchemy_engine)
        if inspector.has_table("tasks"):
            print("'tasks' 表已成功创建/存在于数据库中。")
        else:
            print("警告: 'tasks' 表在 create_all 之后仍未找到！这通常意味着模型没有在 create_all 之前被正确导入。")
            print(f"   已知的表: {inspector.get_table_names()}") # 打印所有实际创建的表
            print(f"   Base.metadata.tables: {Base.metadata.tables.keys()}") # 打印 SQLAlchemy 元数据中已注册的表
    except Exception as e:
        print(f"创建或检查数据库表时出错: {e}")
        import traceback
        traceback.print_exc() # 打印详细的异常堆栈


    # --- [修改] APScheduler 初始化 (使用 get_scheduler) ---
    current_scheduler = get_scheduler() # <--- 获取调度器实例
    try:
        logging.getLogger('apscheduler').setLevel(logging.DEBUG) # 设置为 DEBUG 级别

        if not current_scheduler.running: # <--- 只有在未运行时才启动
            current_scheduler.start()
            print("APScheduler 已启动并使用数据库作业存储。")
        else:
            print("APScheduler 已在运行。")
    except Exception as e:
        print(f"APScheduler 启动失败: {e}")

    print("RAG 组件的初始化和管理在 zhz_agent_mcp_server.py。")
    print("任务管理API已在 /tasks 路径下可用。")

    yield # FastAPI 应用在此运行

    print("--- Main FastAPI 应用关闭 ---")
    current_scheduler_on_shutdown = get_scheduler() # <--- 再次获取以确保是同一个实例
    if current_scheduler_on_shutdown and current_scheduler_on_shutdown.running:
        current_scheduler_on_shutdown.shutdown()
        print("APScheduler 已关闭。")
    await database.disconnect()
    print("数据库已断开连接。")
    print("RAG 组件的清理在 zhz_agent_mcp_server.py。")

# --- App 定义 (保持不变) ---
app = FastAPI(
    title="Hybrid RAG Backend with Task Management",
    description="主 FastAPI 应用，负责接收请求、编排 Agent，并提供任务管理API。",
    version="0.2.1",
    lifespan=lifespan
)

app.include_router(tasks_router)

@app.get("/")
async def read_root():
    return {
        "message": "Welcome to the Hybrid RAG Backend Main App.",
        "available_services": {
            "task_management": "/tasks/docs",
            "rag_via_mcpo": "mcpo proxy at port 8006 (see mcpo_servers.json)"
        }
    }

if __name__ == "__main__":
    print("--- 启动 Main FastAPI 服务器 (包含任务管理API) ---")
    uvicorn.run("zhz_agent.main:app", host="0.0.0.0", port=8000, reload=True) # Ensure correct run command
```

    |-- rag_api_service.py

``` py
# /home/zhz/zhz_agent/zhz_rag/api/rag_api_service.py
# 版本: 3.1.0 - 手动实现 Small-to-Big Retrieval (更新异步检索调用, 修复prompts导入)

import pandas as pd
import io
import os
import asyncio
from contextlib import asynccontextmanager
from typing import List, Dict, Any, Optional
import logging
import sys
import uvicorn
import traceback
from fastapi import FastAPI, Request, HTTPException
from dataclasses import dataclass
from dotenv import load_dotenv
import uuid
from datetime import datetime, timezone
from cachetools import TTLCache
import hashlib
import json
# LangChain 相关导入 - 我们仍然需要 Document 和 InMemoryStore
from langchain.storage import InMemoryStore
from langchain.docstore.document import Document as LangchainDocument

from zhz_rag.core_rag.fusion_engine import FusionEngine # <-- 添加导入

# --- .env 文件加载 (保持不变) ---
_current_file_dir = os.path.dirname(os.path.abspath(__file__))
_project_root_dir = os.path.abspath(os.path.join(_current_file_dir, "..", ".."))
_dotenv_path = os.path.join(_project_root_dir, ".env")
if os.path.exists(_dotenv_path):
    load_dotenv(dotenv_path=_dotenv_path)
    print(f"RagApiService: Successfully loaded .env file from: {_dotenv_path}")
else:
    print(f"RagApiService: .env file not found at {_dotenv_path}. Relying on system environment variables or defaults.")
    load_dotenv()

# --- 导入我们自己的模块 ---
from zhz_rag.config.pydantic_models import QueryRequest, HybridRAGResponse, RetrievedDocument
from zhz_rag.llm.llm_interface import (
    generate_answer_from_context,
    generate_query_plan,
    generate_table_lookup_instruction,
    generate_actionable_suggestion,
    generate_expanded_queries,
    generate_document_summary, # <--- 确保导入
    NO_ANSWER_PHRASE_ANSWER_CLEAN
)
from zhz_rag.utils.hardware_manager import HardwareManager

# 修复: 移除 get_table_qa_messages 的导入，因为它导致了 AttributeError
from zhz_rag.llm.rag_prompts import get_answer_generation_messages, get_table_qa_messages, get_fusion_messages
from zhz_rag.core_rag.retrievers.chromadb_retriever import ChromaDBRetriever
from zhz_rag.core_rag.retrievers.file_bm25_retriever import FileBM25Retriever
from zhz_rag.core_rag.retrievers.embedding_functions import LlamaCppEmbeddingFunction
from zhz_rag.llm.local_model_handler import LlamaCppEmbeddingFunction as LocalModelHandlerWrapper
from zhz_rag_pipeline_dagster.zhz_rag_pipeline.resources import GGUFEmbeddingResource
from zhz_rag.utils.interaction_logger import log_interaction_data

# --- 日志配置 (保持不变) ---
api_logger = logging.getLogger("RAGApiServiceLogger")
api_logger.setLevel(logging.INFO)
if not api_logger.hasHandlers():
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s')
    handler.setFormatter(handler)
    api_logger.addHandler(handler)
    api_logger.propagate = False

# --- 生产者-消费者队列 (保持不变) ---
log_queue = asyncio.Queue()

async def log_writer_task():
    api_logger.info("Log writer task started and is waiting for log entries.")
    while True:
        try:
            log_entry_to_write = await log_queue.get()
            await log_interaction_data(log_entry_to_write) 
            log_queue.task_done()
            api_logger.info(f"Log writer successfully wrote interaction ID: {log_entry_to_write.get('interaction_id')}")
        except Exception as e:
            api_logger.error(f"Critical error in log_writer_task: {e}", exc_info=True)

# --- 应用上下文 Dataclass ---
@dataclass
class RAGAppContext:
    chroma_retriever: ChromaDBRetriever # 我们现在直接使用自己的 retriever
    bm25_retriever: Optional[FileBM25Retriever]
    docstore: InMemoryStore             # docstore 仍然用来存储父文档
    gguf_embedding_resource: GGUFEmbeddingResource
    answer_cache: TTLCache
    llm_gbnf_instance: Any
    fusion_engine: FusionEngine # <-- 添加这一行


@asynccontextmanager
async def lifespan(app: FastAPI):
    api_logger.info("--- RAG API Service (v5.4 - HAL Corrected): Initializing... ---")
    
    # --- 1. 使用 HAL 获取硬件建议 ---
    hal = HardwareManager()
    
    # --- 2. 在应用层加载 GBNF LLM 模型 ---
    gbnf_llm = None
    model_path = os.getenv("LOCAL_LLM_GGUF_MODEL_PATH")
    if not model_path or not os.path.exists(model_path):
        api_logger.error(f"LLM model path not found or invalid: {model_path}. GBNF features will be disabled.")
    else:
        try:
            model_size_gb = os.path.getsize(model_path) / (1024**3)
            # 假设层数，这个值对于推荐很重要
            model_total_layers = 28 # Qwen3-1.7B
            
            n_gpu_layers = hal.recommend_llm_gpu_layers(
                model_total_layers=model_total_layers,
                model_size_on_disk_gb=model_size_gb
            )
            
            api_logger.info(f"Loading GBNF LLM from: {model_path} with {n_gpu_layers} layers offloaded to GPU.")
            # 导入Llama类
            from llama_cpp import Llama
            gbnf_llm = Llama(
                model_path=model_path,
                n_gpu_layers=n_gpu_layers,
                n_ctx=int(os.getenv("LLM_N_CTX", 4096)),
                verbose=False
            )
            api_logger.info("GBNF LLM instance pre-loaded successfully in API lifespan.")
        except Exception as e:
            api_logger.critical(f"FATAL: Failed to pre-load GBNF LLM model: {e}", exc_info=True)
            gbnf_llm = None

    # --- 3. 初始化其他服务 ---
    embedding_api_url = os.getenv("EMBEDDING_API_URL", "http://127.0.0.1:8089")
    chroma_persist_dir = os.getenv("CHROMA_PERSIST_DIRECTORY")
    chroma_collection_name = os.getenv("CHROMA_COLLECTION_NAME", "zhz_rag_collection")
    # --- 新增: 获取BM25索引路径 ---
    bm25_index_dir = os.getenv("BM25_INDEX_DIRECTORY")


    class FakeDagsterContext:
        def __init__(self, logger_instance): self.log = logger_instance
    
    gguf_embed_resource = GGUFEmbeddingResource(api_url=embedding_api_url)
    await asyncio.to_thread(gguf_embed_resource.setup_for_execution, FakeDagsterContext(api_logger))
    model_handler = LocalModelHandlerWrapper(resource=gguf_embed_resource)
    chroma_embedding_function = LlamaCppEmbeddingFunction(model_handler=model_handler)
    
    try:
        # --- 初始化 ChromaDB ---
        chroma_retriever_instance = ChromaDBRetriever(
            collection_name=chroma_collection_name,
            persist_directory=chroma_persist_dir,
            embedding_function=chroma_embedding_function
        )
        api_logger.info(f"Initialized ChromaDBRetriever. Collection: '{chroma_collection_name}'")

        # --- 新增: 初始化 BM25 检索器 ---
        bm25_retriever_instance = None
        if bm25_index_dir and os.path.isdir(bm25_index_dir):
            try:
                api_logger.info(f"Initializing FileBM25Retriever from: {bm25_index_dir}")
                bm25_retriever_instance = FileBM25Retriever(index_directory=bm25_index_dir)
                api_logger.info("FileBM25Retriever initialized successfully.")
            except Exception as e:
                api_logger.error(f"Failed to initialize FileBM25Retriever: {e}", exc_info=True)
                bm25_retriever_instance = None # 确保在失败时为 None
        else:
            api_logger.warning(f"BM25_INDEX_DIRECTORY not set or is not a valid directory. BM25 search will be disabled.")


        api_logger.info("Building docstore from ChromaDB metadata upon service startup...")
        docstore = InMemoryStore()
        
        try:
            count = chroma_retriever_instance._collection.count()
            if count > 0:
                all_chunks_from_db = chroma_retriever_instance._collection.get(include=["metadatas", "documents"])
                
                parent_docs_map: Dict[str, Dict[str, Any]] = {}
                for i, metadata in enumerate(all_chunks_from_db['metadatas']):
                    parent_id = metadata.get("parent_id")
                    if parent_id:
                        if parent_id not in parent_docs_map:
                            # 存储父文档的元数据和所有子块的内容
                            parent_docs_map[parent_id] = {"metadata": metadata, "texts": []}
                        parent_docs_map[parent_id]["texts"].append(all_chunks_from_db['documents'][i])
                
                docs_to_store_in_docstore = [
                    LangchainDocument(
                        page_content="\n\n".join(sorted(data["texts"])), 
                        metadata={**data["metadata"], "doc_id": parent_id} # Merging metadata, ensuring doc_id
                    ) for parent_id, data in parent_docs_map.items()
                ]
                docstore.mset([(doc.metadata["doc_id"], doc) for doc in docs_to_store_in_docstore])
                api_logger.info(f"Docstore built successfully with {len(docs_to_store_in_docstore)} parent documents.")
            else:
                api_logger.warning(f"ChromaDB collection '{chroma_collection_name}' is empty. Docstore will be empty.")

        except Exception as e:
            api_logger.error(f"Failed to build docstore during startup: {e}", exc_info=True)
            docstore = InMemoryStore() # Ensure docstore is initialized even on failure
            
        # --- 新增：初始化 FusionEngine ---
        fusion_engine_instance = FusionEngine(logger=api_logger)

        app.state.rag_context = RAGAppContext(
            chroma_retriever=chroma_retriever_instance,
            bm25_retriever=bm25_retriever_instance, # <--- 传递 BM25 实例
            docstore=docstore,
            gguf_embedding_resource=gguf_embed_resource,
            answer_cache=TTLCache(maxsize=100, ttl=900),
            llm_gbnf_instance=gbnf_llm,
            fusion_engine=fusion_engine_instance # <-- 传递实例
        )
        
        api_logger.info("--- RAG components initialized successfully. ---")
        asyncio.create_task(log_writer_task())
    except Exception as e:
        api_logger.critical(f"FATAL: Failed to initialize RAG components: {e}", exc_info=True)
        app.state.rag_context = None
    
    yield
    
    api_logger.info("--- RAG API Service: Cleaning up resources ---")
    
    if hasattr(app.state, 'rag_context') and app.state.rag_context and app.state.rag_context.gguf_embedding_resource:
        if hasattr(app.state.rag_context.gguf_embedding_resource, 'teardown_for_execution'):
            api_logger.info("Calling teardown_for_execution on GGUFEmbeddingResource...")
            class FakeDagsterContextTeardown:
                def __init__(self, logger_instance):
                    self.log = logger_instance
            fake_dagster_context_teardown = FakeDagsterContextTeardown(api_logger)
            await asyncio.to_thread(app.state.rag_context.gguf_embedding_resource.teardown_for_execution, fake_dagster_context_teardown)
            api_logger.info("GGUFEmbeddingResource teardown_for_execution called.")
        else:
            api_logger.warning("GGUFEmbeddingResource does not have a teardown_for_execution method.")
    else:
        api_logger.warning("No RAGAppContext or GGUFEmbeddingResource found for teardown.")

    if hasattr(app.state, 'rag_context') and app.state.rag_context and app.state.rag_context.llm_gbnf_instance:
        app.state.rag_context.llm_gbnf_instance = None
        api_logger.info("GBNF LLM instance released.")

    api_logger.info("--- Cleanup complete. ---")


def _fuse_results_rrf(
    vector_results: List[List[Dict[str, Any]]], 
    keyword_results: List[List[Dict[str, Any]]], 
    k: int = 60
) -> List[Dict[str, Any]]:
    """
    使用倒数排序融合（Reciprocal Rank Fusion - RRF）来合并向量和关键词搜索的结果。
    
    Args:
        vector_results: 来自向量检索器的结果列表（每个子查询一个列表）。
        keyword_results: 来自关键词检索器的结果列表（每个子查询一个列表）。
        k: RRF算法中的排名常数，用于降低低排名结果的权重。

    Returns:
        一个融合、去重并按RRF分数重新排序的文档块列表。
    """
    # 步骤1: 将来自多个子查询的结果平铺成两个总的排名列表
    flat_vector_results = [chunk for sublist in vector_results for chunk in sublist]
    flat_keyword_results = [chunk for sublist in keyword_results for chunk in sublist]
    
    scores = {}
    all_docs_map = {}

    # 步骤2: 计算RRF分数
    # 处理向量搜索结果
    for rank, doc in enumerate(flat_vector_results):
        doc_id = doc.get("id")
        if not doc_id: continue
        scores[doc_id] = 1 / (k + rank + 1)
        all_docs_map[doc_id] = doc

    # 处理关键词搜索结果
    for rank, doc in enumerate(flat_keyword_results):
        doc_id = doc.get("id")
        if not doc_id: continue
        if doc_id not in scores:
            scores[doc_id] = 0
        scores[doc_id] += 1 / (k + rank + 1)
        all_docs_map.setdefault(doc_id, doc) # 仅在doc_id不存在时添加，保留向量搜索的元数据
    
    # 步骤3: 按RRF分数降序排序
    sorted_doc_ids = sorted(scores.keys(), key=lambda x: scores[x], reverse=True)
    
    # 步骤4: 构建最终的融合结果列表
    fused_results = [all_docs_map[doc_id] for doc_id in sorted_doc_ids]

    return fused_results


# --- FastAPI 应用实例 (保持不变) ---
app = FastAPI(
    title="Advanced RAG API Service with Manual Small-to-Big Retrieval",
    description="Provides API access to the RAG framework, now with manual small-to-big retrieval.",
    version="3.1.0", # Version updated
    lifespan=lifespan
)


@app.post("/api/v1/rag/query", response_model=HybridRAGResponse)
async def query_rag_endpoint(request: Request, query_request: QueryRequest):
    api_logger.info(f"\n--- Received RAG query (v8.0 - Hybrid Search): '{query_request.query}' ---")
    start_time_total = datetime.now(timezone.utc)
    app_ctx: RAGAppContext = request.app.state.rag_context
    if not app_ctx or not app_ctx.llm_gbnf_instance or not app_ctx.fusion_engine:
        raise HTTPException(status_code=503, detail="RAG service or its core components are not initialized.")

    interaction_id_for_log = str(uuid.uuid4())
    exception_occurred: Optional[Exception] = None
    response_to_return: Optional[HybridRAGResponse] = None

    try:
        # 缓存逻辑保持不变
        cache_key = hashlib.md5(query_request.model_dump_json().encode('utf-8')).hexdigest()
        cached_response = app_ctx.answer_cache.get(cache_key)
        if cached_response is not None:
            api_logger.info(f"FINAL ANSWER CACHE HIT for query: '{query_request.query}'")
            return cached_response

        # --- 步骤 1 & 2: 查询扩展、规划和混合检索 ---
        api_logger.info("--- Step 1 & 2: Expansion, Planning, and HYBRID Retrieval ---")
        query_plan = await generate_query_plan(app_ctx.llm_gbnf_instance, user_query=query_request.query)
        sub_queries = await generate_expanded_queries(app_ctx.llm_gbnf_instance, original_query=query_request.query)
        unique_queries = list(dict.fromkeys([query_plan.query] + sub_queries if query_plan else sub_queries))
        api_logger.info(f"Expanded to {len(unique_queries)} unique queries for retrieval.")

        # --- 构建元数据过滤器 (逻辑不变) ---
        user_filter_conditions = query_request.filters.get("must", []) if query_request.filters else []
        llm_filter = query_plan.metadata_filter if query_plan else {}
        all_conditions = []
        for condition in user_filter_conditions:
            key = condition.get("key")
            match = condition.get("match")
            if key and match and "value" in match:
                all_conditions.append({key: {"$eq": match["value"]}})
        if llm_filter:
            if "$and" in llm_filter:
                all_conditions.extend(llm_filter["$and"])
            elif llm_filter:
                all_conditions.append(llm_filter)
        final_metadata_filter = {}
        if all_conditions:
            unique_conditions_as_strings = {json.dumps(c, sort_keys=True) for c in all_conditions}
            unique_conditions = [json.loads(s) for s in unique_conditions_as_strings]
            if len(unique_conditions) == 1:
                final_metadata_filter = unique_conditions[0]
            else:
                final_metadata_filter = {"$and": unique_conditions}
        api_logger.info(f"Final ChromaDB-compliant metadata filter: {final_metadata_filter}")

        # --- 并行执行向量和关键词检索 ---
        vector_retrieval_tasks = [
            app_ctx.chroma_retriever.retrieve(
                query_text=q,
                n_results=query_request.top_k_vector,
                where_filter=final_metadata_filter or None
            ) for q in unique_queries
        ]
        
        keyword_retrieval_tasks = []
        if app_ctx.bm25_retriever:
            api_logger.info("BM25 retriever is available, performing keyword search.")
            # 注意: BM25是同步的，使用 to_thread 在异步事件循环中运行它
            keyword_retrieval_tasks = [
                asyncio.to_thread(
                    app_ctx.bm25_retriever.retrieve,
                    query_text=q,
                    n_results=query_request.top_k_vector  # 复用 top_k_vector 作为BM25的top_k
                ) for q in unique_queries
            ]
        else:
            api_logger.info("BM25 retriever is not available. Skipping keyword search.")

        # 等待所有检索任务完成
        all_retrieval_results = await asyncio.gather(*(vector_retrieval_tasks + keyword_retrieval_tasks))
        
        # 分离结果
        vector_results = all_retrieval_results[:len(vector_retrieval_tasks)]
        keyword_results = all_retrieval_results[len(vector_retrieval_tasks):]
        
        num_vector_chunks = sum(len(r) for r in vector_results)
        num_keyword_chunks = sum(len(r) for r in keyword_results)
        api_logger.info(f"Retrieved {num_vector_chunks} chunks from vector search and {num_keyword_chunks} chunks from keyword search.")

        # --- 使用RRF融合结果 ---
        fused_child_chunks = _fuse_results_rrf(vector_results, keyword_results)
        api_logger.info(f"Hybrid search complete. Fused to {len(fused_child_chunks)} unique child chunks.")
        
        # --- 从融合后的子块中提取父文档 ---
        all_parent_ids = {chunk['metadata']['parent_id'] for chunk in fused_child_chunks if 'parent_id' in chunk.get('metadata', {})}
        parent_docs = app_ctx.docstore.mget(list(all_parent_ids))
        valid_parent_docs = [doc for doc in parent_docs if doc]
        api_logger.info(f"Retrieved {len(valid_parent_docs)} unique candidate parent documents from fused results.")

        # --- 后续步骤（重排、生成答案等）保持不变，但使用融合后的结果 ---
        # Stage 3: Reranking
        api_logger.info(f"--- Step 3: Reranking {len(valid_parent_docs)} documents... ---")
        reranked_docs = await app_ctx.fusion_engine.rerank_documents(
            query=query_request.query,
            documents=[RetrievedDocument(content=doc.page_content, metadata=doc.metadata, score=0.0, source_type="fused_retrieval") for doc in valid_parent_docs],
            top_n=5
        )
        api_logger.info(f"Reranking complete. Top {len(reranked_docs)} documents selected.")

        # --- Stage 4: Step-by-Step Synthesis ---
        # (此部分逻辑完全保持不变，直接使用 reranked_docs)
        api_logger.info(f"--- Step 4: Step-by-Step Synthesis on {len(reranked_docs)} reranked documents ---")
        final_answer = NO_ANSWER_PHRASE_ANSWER_CLEAN
        failure_reason = ""
        
        if not reranked_docs:
            failure_reason = "知识库中未能找到任何与您问题相关的信息。"
        else:
            # --- 核心修复：只要最相关的文档是表格，就优先使用表格专家 ---
            is_table_query_top_ranked = (reranked_docs and reranked_docs[0].metadata.get("paragraph_type") == "table")
            
            if is_table_query_top_ranked:
                api_logger.info("Dispatching to Table QA Hybrid Expert (Top Ranked Document is a Table).")
                table_doc = reranked_docs[0]
                try:
                    df = pd.read_csv(io.StringIO(table_doc.content), sep='|', skipinitialspace=True).dropna(axis=1, how='all').iloc[1:]
                    df.columns = [col.replace(" ", "").strip() for col in df.columns]
                    # --- START: 核心修正 - 清洗所有单元格数据中的空格 ---
                    for col in df.columns:
                        if df[col].dtype == 'object': # 只对字符串类型的列进行操作
                            df[col] = df[col].str.strip()
                    # --- END: 核心修正 ---

                    if len(df.columns) < 2:
                        raise ValueError("Table must have at least two columns for key-value lookup.")
                    
                    key_column_for_lookup = df.columns[1]
                    instruction = await generate_table_lookup_instruction(
                        llm_instance=app_ctx.llm_gbnf_instance,
                        user_query=query_request.query,
                        table_column_names=df.columns.tolist()
                    )

                    if instruction and "row_identifier" in instruction and "column_identifier" in instruction:
                        row_id = instruction.get("row_identifier", "").replace(" ", "")
                        col_id = instruction.get("column_identifier", "").replace(" ", "")
                        result_series = df.loc[df[key_column_for_lookup] == row_id, col_id]
                        
                        if not result_series.empty:
                            value = result_series.iloc[0]
                            final_answer = f"根据查找到的表格信息，{row_id}的{col_id}是{value}。"
                        else:
                             failure_reason = f"模型指令无法执行：在表格的'{key_column_for_lookup}'列中未能找到行'{row_id}'，或在表头中未能找到列'{col_id}'。"
                    else:
                        failure_reason = "模型未能从问题中生成有效的表格查询指令。"
                except Exception as e_pandas:
                    failure_reason = f"处理表格数据时遇到代码错误: {e_pandas}"
                
                if failure_reason:
                    api_logger.warning(f"Table QA Expert failed: {failure_reason}. Downgrading to Fusion Expert.")

            if final_answer == NO_ANSWER_PHRASE_ANSWER_CLEAN:
                summary_tasks = [generate_document_summary(app_ctx.llm_gbnf_instance, user_query=query_request.query, document_content=doc.content) for doc in reranked_docs]
                summaries = await asyncio.gather(*summary_tasks)
                
                relevant_summaries = []
                for doc, summary in zip(reranked_docs, summaries):
                    if summary:
                        filename = doc.metadata.get('filename', '未知文档')
                        relevant_summaries.append(f"根据文档《{filename}》的信息：{summary}")
                
                api_logger.info(f"Generated {len(relevant_summaries)} relevant summaries.")

                if not relevant_summaries:
                    failure_reason = "虽然检索到了相关文档，但无法从中提炼出与您问题直接相关的核心信息。"
                else:
                    fusion_context = "\n\n".join(relevant_summaries)
                    final_answer = await generate_answer_from_context(user_query=query_request.query, context_str=fusion_context, prompt_builder=lambda q, c: get_fusion_messages(q, c))
            
        if not final_answer or NO_ANSWER_PHRASE_ANSWER_CLEAN in final_answer:
            if not failure_reason: failure_reason = "根据检索到的上下文信息，无法直接回答您的问题。"
            suggestion = await generate_actionable_suggestion(app_ctx.llm_gbnf_instance, user_query=query_request.query, failure_reason=failure_reason)
            final_answer = f"{failure_reason} {suggestion}" if suggestion else failure_reason

        response_to_return = HybridRAGResponse(answer=final_answer, original_query=query_request.query, retrieved_sources=reranked_docs)
        if not failure_reason and NO_ANSWER_PHRASE_ANSWER_CLEAN not in final_answer:
            app_ctx.answer_cache[cache_key] = response_to_return
            api_logger.info(f"FINAL ANSWER CACHED.")
    except Exception as e:
        exception_occurred = e
        api_logger.error(f"Critical error in query_rag_endpoint: {e}", exc_info=True)
        response_to_return = HybridRAGResponse(answer=f"An internal server error occurred: {e}", original_query=query_request.query, retrieved_sources=[])
    finally:
        processing_time_seconds = (datetime.now(timezone.utc) - start_time_total).total_seconds()
        log_data_for_finally = {
            "interaction_id": interaction_id_for_log, "timestamp_utc": datetime.now(timezone.utc).isoformat(),
            "task_type": "rag_query_processing_v8_0_hybrid_search",
            "original_user_query": query_request.query,
            "final_answer_from_llm": response_to_return.answer if response_to_return else "N/A",
            "final_context_docs_full": [doc.model_dump() for doc in response_to_return.retrieved_sources] if response_to_return else [],
            "retrieval_parameters": query_request.model_dump(),
            "processing_time_seconds": round(processing_time_seconds, 3)
        }
        if exception_occurred:
            log_data_for_finally["error_details"] = f"{type(exception_occurred).__name__}: {str(exception_occurred)}"
            log_data_for_finally["error_traceback"] = traceback.format_exc()
        
        await log_queue.put(log_data_for_finally)
        
        if exception_occurred:
            raise HTTPException(status_code=500, detail=str(exception_occurred))
        
        if response_to_return is None:
            response_to_return = HybridRAGResponse(answer="An unexpected error occurred during response generation.", original_query=query_request.query, retrieved_sources=[])
        
        return response_to_return
    
if __name__ == "__main__":
    api_logger.info("Starting Standalone RAG API Service with Manual Small-to-Big Retrieval...")
    uvicorn.run("zhz_rag.api.rag_api_service:app", host="0.0.0.0", port=8081, reload=False)

```

    |-- rag_mcp_service.py

``` py
import os
import json
import asyncio
import traceback
from contextlib import asynccontextmanager
from typing import List, Dict, Any, Optional, AsyncIterator
from dataclasses import dataclass, field # 确保导入 field
import time
import logging
import sys
import hashlib # <--- 添加
from datetime import datetime, timezone # <--- 添加
import uuid # <--- 添加


# MCP 框架导入
from mcp.server.fastmcp import FastMCP, Context

# --- 配置 rag_service 的专用日志 ---
_rag_service_py_dir = os.path.dirname(os.path.abspath(__file__))
_rag_service_log_file = os.path.join(_rag_service_py_dir, 'rag_service_debug.log')

rag_logger = logging.getLogger("RagServiceLogger")
rag_logger.setLevel(logging.DEBUG)
rag_logger.propagate = False

if rag_logger.hasHandlers():
    rag_logger.handlers.clear()

try:
    _file_handler = logging.FileHandler(_rag_service_log_file, mode='w')
    _file_handler.setLevel(logging.DEBUG)
    _formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(filename)s:%(lineno)d - %(message)s')
    _file_handler.setFormatter(_formatter)
    rag_logger.addHandler(_file_handler)
    rag_logger.info("--- RagServiceLogger configured to write to rag_service_debug.log ---")
except Exception as e:
    print(f"CRITICAL: Failed to configure RagServiceLogger: {e}")


# --- 从项目内部导入所有 RAG 模块 ---
from zhz_rag.config.pydantic_models import QueryRequest, HybridRAGResponse, RetrievedDocument
from zhz_rag.llm.llm_interface import (
    generate_answer_from_context,
    generate_expanded_queries,
    generate_cypher_query,
    generate_clarification_question,
    generate_intent_classification,
    NO_ANSWER_PHRASE_ANSWER_CLEAN
)
from zhz_rag.core_rag.retrievers.chromadb_retriever import ChromaDBRetriever
from zhz_rag.core_rag.retrievers.file_bm25_retriever import FileBM25Retriever
from zhz_rag.core_rag.kg_retriever import KGRetriever
from zhz_rag.core_rag.fusion_engine import FusionEngine
from zhz_rag.utils.common_utils import log_interaction_data

from dotenv import load_dotenv

# 加载 .env 文件
# __file__ 是当前 rag_service.py 的路径: /home/zhz/zhz_agent/rag_service.py
# os.path.dirname(os.path.abspath(__file__)) 是 /home/zhz/zhz_agent 目录
# .env 文件与 rag_service.py 在同一个目录下 (zhz_agent 目录)
current_dir = os.path.dirname(os.path.abspath(__file__))
dotenv_path = os.path.join(current_dir, '.env')

if os.path.exists(dotenv_path):
    load_dotenv(dotenv_path=dotenv_path)
    rag_logger.info(f"Loaded .env file from: {dotenv_path}")
else:
    rag_logger.warning(f".env file not found at {dotenv_path}, will rely on environment variables or defaults.")
    # 仍然尝试加载，因为python-dotenv的默认行为是查找当前工作目录和上级目录的.env
    load_dotenv()

# --- 应用上下文 Dataclass ---
@dataclass
class AppContext:
    # vector_retriever: VectorRetriever # 旧的
    chroma_retriever: Optional[ChromaDBRetriever] = None # 新的
    kg_retriever: Optional[KGRetriever] = None
    # bm25_retriever: BM25Retriever # 旧的
    file_bm25_retriever: Optional[FileBM25Retriever] = None # 新的
    fusion_engine: Optional[FusionEngine] = None
    # llm_generator: Optional[Any] = None # LLMGenerator在您的代码中没有被实例化并放入AppContext

# --- MCP 服务器生命周期管理 ---
@asynccontextmanager
async def app_lifespan_for_rag_service(server: FastMCP) -> AsyncIterator[AppContext]:
    rag_logger.info("--- RAG Service (FastMCP): 正在初始化 RAG 组件 (新版) ---")
    
    chroma_retriever_instance: Optional[ChromaDBRetriever] = None
    kg_retriever_instance: Optional[KGRetriever] = None
    file_bm25_retriever_instance: Optional[FileBM25Retriever] = None
    fusion_engine_instance: Optional[FusionEngine] = None

    # 初始化 ChromaDB Retriever
    try:
        # 这些路径和名称应该与Dagster流水线中配置的一致
        # 优先从环境变量读取，如果不存在则使用默认值（如果适用）
        chroma_persist_dir = os.getenv("CHROMA_PERSIST_DIRECTORY", "/home/zhz/dagster_home/chroma_data")
        chroma_collection_name = os.getenv("CHROMA_COLLECTION_NAME", "rag_documents")
        embedding_model_path = os.getenv("EMBEDDING_MODEL_PATH", "/home/zhz/models/bge-small-zh-v1.5")

        if not os.path.isdir(chroma_persist_dir):
                rag_logger.warning(f"ChromaDB persist directory '{chroma_persist_dir}' not found. Retrieval may fail or use an in-memory DB if ChromaDBRetriever handles this.")
        if not os.path.exists(embedding_model_path): # embedding_model_path 应该是目录
            rag_logger.warning(f"Embedding model path '{embedding_model_path}' not found. ChromaDBRetriever initialization might fail.")

        chroma_retriever_instance = ChromaDBRetriever(
            collection_name=chroma_collection_name,
            persist_directory=chroma_persist_dir,
            embedding_model_name_or_path=embedding_model_path
        )
        rag_logger.info("RAG Service: ChromaDBRetriever 初始化成功。")
    except Exception as e:
        rag_logger.error(f"RAG Service: ChromaDBRetriever 初始化失败: {e}", exc_info=True)
        # 不在此处抛出异常，允许服务在部分组件失败时仍能启动（如果设计如此）
    
    # 初始化 File BM25 Retriever
    try:
        bm25_index_dir = os.getenv("BM25_INDEX_DIRECTORY", "/home/zhz/dagster_home/bm25_index_data/")
        if not os.path.isdir(bm25_index_dir):
            rag_logger.warning(f"BM25 index directory '{bm25_index_dir}' not found. FileBM25Retriever initialization might fail.")
            
        file_bm25_retriever_instance = FileBM25Retriever(
            index_directory_path=bm25_index_dir
        )
        rag_logger.info("RAG Service: FileBM25Retriever 初始化成功。")
    except Exception as e:
        rag_logger.error(f"RAG Service: FileBM25Retriever 初始化失败: {e}", exc_info=True)

    # 初始化 KG Retriever
    try:
        # KGRetriever 内部会从环境变量读取NEO4J配置
        # generate_cypher_query 是从 zhz_agent.llm 导入的
        kg_retriever_instance = KGRetriever(llm_cypher_generator_func=generate_cypher_query)
        rag_logger.info("RAG Service: KGRetriever 初始化成功。")
    except Exception as e:
        rag_logger.error(f"RAG Service: KGRetriever 初始化失败: {e}", exc_info=True)
        if kg_retriever_instance and hasattr(kg_retriever_instance, 'close'): # 确保在失败前尝试关闭
            kg_retriever_instance.close()
            
    # 初始化 Fusion Engine
    try:
        fusion_engine_instance = FusionEngine(logger=rag_logger)
        rag_logger.info("RAG Service: FusionEngine 初始化成功。")
    except Exception as e:
        rag_logger.error(f"RAG Service: FusionEngine 初始化失败: {e}", exc_info=True)

    rag_logger.info("--- RAG Service (FastMCP): RAG 组件初始化尝试完成。---")

    ctx = AppContext(
        chroma_retriever=chroma_retriever_instance,
        kg_retriever=kg_retriever_instance,
        file_bm25_retriever=file_bm25_retriever_instance,
        fusion_engine=fusion_engine_instance
    )
    try:
        yield ctx
    finally:
        rag_logger.info("--- RAG Service (FastMCP): 正在清理资源 ---")
        if kg_retriever_instance: # 确保只在成功初始化后才调用close
            kg_retriever_instance.close() 
        rag_logger.info("--- RAG Service (FastMCP): 清理完成 ---")

# --- 初始化 FastMCP 应用 ---
rag_mcp_application = FastMCP(
    name="zhz_agent_rag_service", # 修改了服务名称以区分
    description="Upgraded Hybrid RAG 服务，使用持久化知识库。",
    lifespan=app_lifespan_for_rag_service,
)

@rag_mcp_application.tool()
async def query_rag_v2( # 重命名工具函数以避免与旧的混淆 (如果需要)
    ctx: Context,
    query: str, # 直接使用 query 作为输入，而不是 QueryRequest 对象
    top_k_vector: int = 3,
    top_k_kg: int = 2,
    top_k_bm25: int = 3,
    top_k_final: int = 3 # 最终融合后返回的文档数
) -> str: 
    rag_logger.info(f"\n--- RAG Service (query_rag_v2): 接收到查询: '{query}' ---")
    rag_logger.info(f"      Params: top_k_vector={top_k_vector}, top_k_kg={top_k_kg}, top_k_bm25={top_k_bm25}, top_k_final={top_k_final}")
    start_time_total = time.time()

    app_ctx: AppContext = ctx.request_context.lifespan_context
    response_payload = {} 
    original_query_for_response = query 
    final_json_output = ""
    # --- [新增日志变量] ---
    log_all_raw_retrievals_summary: List[Dict[str, Any]] = []
    log_final_context_docs_summary: List[Dict[str, Any]] = [] # This will store the full doc model dumps
    log_fused_context_text_for_llm_snippet: str = "N/A"
    # --- [确保所有日志变量都有初始值] ---
    log_final_answer_from_llm: str = "N/A"
    log_intent_classification_result: Optional[Dict[str, Any]] = None
    log_expanded_queries: Optional[List[str]] = None
    # --- [结束确保所有日志变量都有初始值] ---

    try:
        # --- 1. LLM 驱动的意图分类和澄清触发 ---
        rag_logger.info(f"--- [TIME] 开始意图分类 at {time.time() - start_time_total:.2f}s ---")
        start_time_intent = time.time()
        intent_classification_result = await generate_intent_classification(query)
        log_intent_classification_result = intent_classification_result # <--- 记录日志
        rag_logger.info(f"--- [TIME] 结束意图分类, 耗时: {time.time() - start_time_intent:.2f}s. Result: {intent_classification_result}")

        if intent_classification_result.get("clarification_needed"):
            uncertainty_reason = intent_classification_result.get("reason", "查询可能存在歧义或信息不足。")
            clarification_question_text = await generate_clarification_question(query, uncertainty_reason)
            response_payload = {
                "status": "clarification_needed",
                "clarification_question": clarification_question_text,
                "original_query": original_query_for_response,
                "debug_info": {"uncertainty_reason": uncertainty_reason, "source": "intent_classification"}
            }
            rag_logger.info(f"--- 需要澄清，返回: {response_payload}")
            # final_json_output will be set before finally block

        else: 
             # --- 启用查询扩展 ---
            rag_logger.info(f"--- 查询清晰，无需澄清。将对原始查询 '{query}' 进行查询扩展 ---")
            start_time_expansion = time.time()
            expanded_queries = await generate_expanded_queries(query) # <--- 取消注释
            log_expanded_queries = expanded_queries # <--- 记录实际的扩展查询
            
            if not expanded_queries or query not in expanded_queries: # 确保原始查询一定在里面
                # 如果 generate_expanded_queries 返回空或不包含原始查询，至少处理原始查询
                if query not in (expanded_queries or []): # 处理 expanded_queries 可能为 None 的情况
                    expanded_queries = [query] + (expanded_queries or [])
                elif not expanded_queries:
                    expanded_queries = [query]

            rag_logger.info(f"--- 扩展后的查询列表 (共 {len(expanded_queries)} 个): {expanded_queries}. 耗时: {time.time() - start_time_expansion:.2f}s ---")
            
            all_raw_retrievals: List[RetrievedDocument] = []
            
            queries_to_process = expanded_queries # <--- 修改：现在处理所有扩展后的查询
            rag_logger.info(f"--- [TIME] 开始并行召回 for {len(queries_to_process)} queries at {time.time() - start_time_total:.2f}s ---")
            start_time_retrieval = time.time()

            for current_query_text in queries_to_process:
                rag_logger.info(f"Processing retrievals for query: '{current_query_text}'")
                
                # 向量检索 (ChromaDB)
                if app_ctx.chroma_retriever:
                    try:
                        chroma_docs_raw = app_ctx.chroma_retriever.retrieve(query_text=current_query_text, n_results=top_k_vector)
                        rag_logger.debug(f"   ChromaDB for '{current_query_text}' raw output: {chroma_docs_raw}") 
                        for doc_raw in chroma_docs_raw:
                            retrieved_doc = RetrievedDocument(
                                source_type="vector_chroma",
                                content=doc_raw.get("text", ""),
                                score=doc_raw.get("score", 0.0),
                                metadata={**doc_raw.get("metadata", {}), "original_query_part": current_query_text}
                            )
                            all_raw_retrievals.append(retrieved_doc)
                            log_all_raw_retrievals_summary.append(retrieved_doc.model_dump()) 
                        rag_logger.info(f"   ChromaDB for '{current_query_text}': found {len(chroma_docs_raw)} docs.")
                    except Exception as e_chroma:
                        rag_logger.error(f"   Error during ChromaDB retrieval for '{current_query_text}': {e_chroma}", exc_info=True)
                
                # 关键词检索 (BM25)
                if app_ctx.file_bm25_retriever:
                    try:
                        bm25_docs_raw = app_ctx.file_bm25_retriever.retrieve(query_text=current_query_text, n_results=top_k_bm25)
                        rag_logger.debug(f"   BM25 for '{current_query_text}' raw output (IDs and scores): {bm25_docs_raw}") 
                        for doc_raw_bm25 in bm25_docs_raw:
                            bm25_chunk_id = doc_raw_bm25.get("id")
                            text_content_for_bm25 = f"[BM25: Text for ID {bm25_chunk_id} pending]"
                            found_in_chroma = False
                            for existing_doc in all_raw_retrievals: 
                                if (existing_doc.metadata and (existing_doc.metadata.get("chunk_id") == bm25_chunk_id or existing_doc.metadata.get("id") == bm25_chunk_id)):
                                    text_content_for_bm25 = existing_doc.content
                                    found_in_chroma = True
                                    break
                            if not found_in_chroma and app_ctx.chroma_retriever and bm25_chunk_id: 
                                try:
                                    specific_chroma_doc = app_ctx.chroma_retriever._collection.get(ids=[bm25_chunk_id], include=["metadatas", "documents"]) # Also fetch documents for content
                                    if specific_chroma_doc:
                                        if specific_chroma_doc.get("documents") and specific_chroma_doc.get("documents")[0]:
                                            text_content_for_bm25 = specific_chroma_doc["documents"][0]
                                        elif specific_chroma_doc.get("metadatas") and specific_chroma_doc.get("metadatas")[0]: # Fallback to chunk_text in metadata
                                            text_content_for_bm25 = specific_chroma_doc["metadatas"][0].get("chunk_text", text_content_for_bm25)

                                except Exception as e_chroma_get:
                                    rag_logger.warning(f"   Failed to get text for BM25 ID {bm25_chunk_id} from Chroma: {e_chroma_get}")
                            
                            retrieved_doc = RetrievedDocument(
                                source_type="keyword_bm25s",
                                content=text_content_for_bm25,
                                score=doc_raw_bm25.get("score", 0.0),
                                metadata={"chunk_id": bm25_chunk_id, "original_query_part": current_query_text}
                            )
                            all_raw_retrievals.append(retrieved_doc)
                            log_all_raw_retrievals_summary.append(retrieved_doc.model_dump()) 
                        rag_logger.info(f"   BM25s for '{current_query_text}': found {len(bm25_docs_raw)} potential docs.")
                    except Exception as e_bm25:
                        rag_logger.error(f"   Error during BM25 retrieval for '{current_query_text}': {e_bm25}", exc_info=True)

                # 知识图谱检索
                if app_ctx.kg_retriever:
                    try:
                        rag_logger.info(f"   Performing KG retrieval for query: '{current_query_text}'")
                        kg_docs = await app_ctx.kg_retriever.retrieve_with_llm_cypher(query=current_query_text, top_k=top_k_kg)
                        rag_logger.debug(f"   KG for '{current_query_text}' raw output: {kg_docs}") 
                        for kg_doc_data in kg_docs: # kg_docs is List[Dict], needs conversion
                            retrieved_doc = RetrievedDocument(**kg_doc_data) # Convert dict to Pydantic model
                            if retrieved_doc.metadata:
                                retrieved_doc.metadata["original_query_part"] = current_query_text
                            else:
                                retrieved_doc.metadata = {"original_query_part": current_query_text}
                            all_raw_retrievals.append(retrieved_doc)
                            log_all_raw_retrievals_summary.append(retrieved_doc.model_dump()) 
                        rag_logger.info(f"   KG Retrieval for '{current_query_text}': found {len(kg_docs)} results.")
                    except Exception as e_kg:
                        rag_logger.error(f"   Error during KG retrieval for '{current_query_text}': {e_kg}", exc_info=True)
            
            rag_logger.info(f"--- [TIME] 结束所有召回, 耗时: {time.time() - start_time_retrieval:.2f}s ---")
            rag_logger.info(f"--- 总计从各路召回（所有查询处理后）的结果数: {len(all_raw_retrievals)} ---")
            if all_raw_retrievals:
                for i_doc, doc_retrieved in enumerate(all_raw_retrievals[:3]): # 日志只打印前3条摘要
                        rag_logger.debug(f"   Raw Doc {i_doc} (Summary): type={doc_retrieved.source_type}, score={doc_retrieved.score}, content='{str(doc_retrieved.content)[:50]}...'")

            if not all_raw_retrievals: 
                response_payload = {
                    "status": "success", 
                    "final_answer": "抱歉，根据您提供的查询，未能从知识库中找到相关信息。",
                    "original_query": original_query_for_response,
                    "retrieved_context_docs": [], 
                    "debug_info": {"message": "No documents retrieved from any source."}
                }
            else:
                rag_logger.info(f"--- [TIME] 开始结果融合与重排序 at {time.time() - start_time_total:.2f}s ---")
                start_time_fusion = time.time()
                final_context_docs: List[RetrievedDocument]
                if not app_ctx.fusion_engine:
                    rag_logger.error("FusionEngine not available! Skipping fusion and reranking.")
                    final_context_docs = sorted(all_raw_retrievals, key=lambda d: d.score if d.score is not None else -float('inf'), reverse=True)[:top_k_final]
                else:
                    final_context_docs = await app_ctx.fusion_engine.fuse_results(
                        all_raw_retrievals, 
                        original_query_for_response,
                        top_n_final=top_k_final
                    ) 
                log_final_context_docs_summary = [doc.model_dump() for doc in final_context_docs] 

                # --- 新增日志，检查 model_dump 的输出 ---
                if log_final_context_docs_summary:
                    rag_logger.info(f"DEBUG_MODEL_DUMP: First item of log_final_context_docs_summary (from model_dump()): {json.dumps(log_final_context_docs_summary[0], ensure_ascii=False, default=str)}")
                # --- 结束新增日志 ---

                rag_logger.info(f"--- [TIME] 结束结果融合与重排序, 耗时: {time.time() - start_time_fusion:.2f}s. Final context docs: {len(final_context_docs)} ---")
                if final_context_docs:
                    for i_fdoc, fdoc_retrieved in enumerate(final_context_docs[:3]): # 日志只打印前3条摘要
                        rag_logger.debug(f"   Fused Doc {i_fdoc} (Summary): type={fdoc_retrieved.source_type}, score={fdoc_retrieved.score}, content='{str(fdoc_retrieved.content)[:50]}...'")
                
                if not final_context_docs: 
                    fused_context_text_for_llm = "未在知识库中找到相关信息。"
                    final_answer_from_llm = "根据现有知识，未能找到您查询的相关信息。"
                    response_payload = {
                        "status": "success",
                        "final_answer": final_answer_from_llm,
                        "original_query": original_query_for_response,
                        "retrieved_context_docs": [], 
                        "debug_info": {"message": "No relevant context found after fusion."}
                    }
                else:
                    context_strings_for_llm = []
                    for doc in final_context_docs:
                        score_str = f"{doc.score:.4f}" if isinstance(doc.score, float) else str(doc.score if doc.score is not None else 'N/A')
                        context_strings_for_llm.append(
                            f"Source Type: {doc.source_type}, Score: {score_str}\nContent: {doc.content}"
                        )
                    fused_context_text_for_llm = "\n\n---\n\n".join(context_strings_for_llm)
                    log_fused_context_text_for_llm_snippet = fused_context_text_for_llm[:500] 

                    rag_logger.info(f"\n--- FUSED CONTEXT for LLM (length: {len(fused_context_text_for_llm)} chars) ---")
                    rag_logger.info(f"{fused_context_text_for_llm[:1000]}...") 
                    rag_logger.info(f"--- END OF FUSED CONTEXT ---\n")

                    rag_logger.info(f"--- [TIME] 开始最终答案生成 at {time.time() - start_time_total:.2f}s ---")
                    start_time_answer_gen = time.time()
                    final_answer_from_llm = await generate_answer_from_context(query, fused_context_text_for_llm)
                    log_final_answer_from_llm = final_answer_from_llm or "N/A" 
                    rag_logger.info(f"--- [TIME] 结束最终答案生成, 耗时: {time.time() - start_time_answer_gen:.2f}s ---")

                    if not final_answer_from_llm or final_answer_from_llm.strip() == NO_ANSWER_PHRASE_ANSWER_CLEAN:
                        final_answer_from_llm = "根据您提供的信息，我暂时无法给出明确的回答。"
                    
                    response_payload = {
                        "status": "success",
                        "final_answer": final_answer_from_llm,
                        "original_query": original_query_for_response,
                        "retrieved_context_docs": [doc.model_dump() for doc in final_context_docs], 
                        "debug_info": {"total_raw_retrievals_count": len(all_raw_retrievals)}
                    }

        final_json_output = json.dumps(response_payload, ensure_ascii=False)
        rag_logger.info(f"--- 'query_rag_v2' 逻辑执行完毕, 总耗时: {time.time() - start_time_total:.2f}s. ---")
        
    except Exception as e_main:
        rag_logger.error(f"RAG Service CRITICAL ERROR in 'query_rag_v2' (main try-except): {type(e_main).__name__} - {str(e_main)}", exc_info=True)
        user_query_for_err_log = original_query_for_response if 'original_query_for_response' in locals() and original_query_for_response else query
        response_payload = {
            "status": "error",
            "error_code": "RAG_SERVICE_INTERNAL_ERROR",
            "error_message": f"RAG服务内部发生未预期错误: {str(e_main)}",
            "original_query": user_query_for_err_log,
            "debug_info": {"exception_type": type(e_main).__name__}
        }
        final_json_output = json.dumps(response_payload, ensure_ascii=False)
    finally: 
        interaction_id_for_log = str(uuid.uuid4())
        current_app_version = "zhz_rag_mcp_service_0.2.1" 

        processed_final_context_docs_for_log = []
        temp_log_final_context_docs = locals().get('log_final_context_docs_summary') # 安全获取

        if temp_log_final_context_docs: # 如果 RAG 流程成功并且 final_context_docs 被处理了
            for doc_dict in temp_log_final_context_docs: # temp_log_final_context_docs 是 model_dump() 后的列表
                cleaned_doc = {}
                for key, value in doc_dict.items():
                    if isinstance(value, float) and (value != value or value == float('inf') or value == float('-inf')): 
                        cleaned_doc[key] = None 
                    else:
                        cleaned_doc[key] = value
                processed_final_context_docs_for_log.append(cleaned_doc)
        # 如果 temp_log_final_context_docs 为 None (例如澄清路径)，则 processed_final_context_docs_for_log 保持为 []

        full_log_entry = {
            "timestamp_utc": datetime.now(timezone.utc).isoformat(),
            "interaction_id": interaction_id_for_log,
            "original_query_interaction_id_ref": locals().get('original_query_interaction_id'), 
            "task_type": "rag_query_processing_full_log",
            "app_version": current_app_version,
            "original_user_query": locals().get('original_query_for_response', query), # query 总是有定义的
            "query_params": {
                "top_k_vector": top_k_vector, "top_k_kg": top_k_kg, 
                "top_k_bm25": top_k_bm25, "top_k_final": top_k_final
            },
            "intent_classification_result": locals().get('log_intent_classification_result'),
            "expanded_queries": locals().get('log_expanded_queries', []), # 默认为空列表
            "all_raw_retrievals_count": len(locals().get('log_all_raw_retrievals_summary', [])),
            "final_context_docs_count": len(processed_final_context_docs_for_log), # 使用清理后列表的长度
            "final_context_docs_summary": [ 
                {
                    "source_type": doc.get("source_type"), 
                    "score": doc.get("score"), 
                    "id": (doc.get("metadata",{}).get("chunk_id") or doc.get("metadata",{}).get("id")) if doc.get("metadata") else None, 
                    "content_preview": str(doc.get("content","N/A"))[:50]+"..."
                } 
                for doc in processed_final_context_docs_for_log[:5] # 使用清理后列表的摘要
            ], 
            "final_context_docs_full": processed_final_context_docs_for_log, # <--- 使用清理后的完整列表
            "fused_context_text_for_llm_snippet": locals().get('log_fused_context_text_for_llm_snippet', "N/A"),
            "final_answer_from_llm": locals().get('log_final_answer_from_llm', "N/A"),
            "final_response_payload_status": locals().get('response_payload', {}).get("status", "Unknown"),
            "total_processing_time_seconds": round(time.time() - start_time_total, 2) if 'start_time_total' in locals() else -1,
        }

        try:
            await log_interaction_data(full_log_entry) 
            rag_logger.info(f"Full RAG interaction log (ID: {interaction_id_for_log}) has been written.")
        except Exception as e_log_final:
            rag_logger.error(f"CRITICAL: Failed to write full RAG interaction log: {e_log_final}", exc_info=True)
        
        sys.stdout.flush(); sys.stderr.flush() 
    
    return final_json_output

if __name__ == "__main__":
    rag_logger.info("--- Starting RAG Service (FastMCP for mcpo via direct run) ---")
    rag_mcp_application.run()
```

    |-- rag_service_debug.log
    |-- task_manager_api.py

``` py
# zhz_agent/task_manager_service.py
from fastapi import APIRouter, HTTPException, Depends, Body, Query, Path, status
from typing import List, Optional, Any, cast
from datetime import datetime, timedelta
import uuid
import traceback # 导入 traceback
import pytz

# --- [修改] 从 pydantic_models 导入我们定义的模型 -> 改为绝对导入 ---
from zhz_rag.config.pydantic_models import TaskModel, CreateTaskRequest, UpdateTaskRequest, TaskStatus, ReminderMethod

# --- [修改] 从 database_models 导入 SQLAlchemy 表模型 -> 改为绝对导入 ---
from zhz_rag.task_management.db_models import TaskDB

# --- [修改] 从新的 database.py 导入 database 对象 和 get_scheduler -> 改为绝对导入 ---
from zhz_rag.utils.db_utils import database, get_scheduler # 将 db_utils 修改为 database

# --- [修改] 从 .task_jobs 导入作业函数 -> 改为绝对导入 ---
from zhz_rag.task_management.jobs import send_task_reminder, execute_task_action
from apscheduler.triggers.date import DateTrigger # 用于指定精确的运行时间
from apscheduler.jobstores.base import JobLookupError # <--- [修改] 导入 JobLookupError 的正确路径

# APIRouter 实例
router = APIRouter(
    prefix="/tasks",
    tags=["Task Management"],
    responses={404: {"description": "Not found"}},
)

def _ensure_utc(dt: datetime) -> datetime:
    """确保 datetime 对象是 UTC 时区感知的。"""
    if dt.tzinfo is None:
        return pytz.utc.localize(dt) # 如果是朴素时间，假定它是UTC并设为UTC
    return dt.astimezone(pytz.utc) # 如果是其他时区，转换为UTC

def _schedule_task_jobs(task: TaskModel):
    current_scheduler = get_scheduler() # 获取 scheduler 实例
    print(f"DEBUG SCHEDULER: _schedule_task_jobs called. Scheduler instance: {current_scheduler}, Is running: {current_scheduler.running if current_scheduler else 'N/A'}")
    if not current_scheduler or not current_scheduler.running:
        print("SCHEDULER_ERROR: APScheduler 未运行，无法调度作业。")
        return

    # 提醒作业
    if task.reminder_time and task.status == TaskStatus.PENDING:
        reminder_job_id = f"reminder_{task.id}"
        try:
            reminder_methods_list = task.reminder_methods
            reminder_utc = _ensure_utc(task.reminder_time)
            print(f"SCHEDULER DEBUG: Passing reminder_methods to job: {reminder_methods_list}") # 添加日志

            current_scheduler.add_job(
                send_task_reminder,
                trigger=DateTrigger(run_date=reminder_utc),
                args=[task.id, task.title, reminder_methods_list], # <--- [修复] 直接传递列表
                id=reminder_job_id,
                name=f"Reminder for task {task.title[:20]}",
                replace_existing=True
            )
            print(f"SCHEDULER: 已为任务 '{task.id}' 添加/更新提醒作业，运行于 {task.reminder_time}")
        except Exception as e:
            print(f"SCHEDULER_ERROR: 添加提醒作业失败 for task '{task.id}': {e}")
            traceback.print_exc() # 打印详细错误堆栈

    # 执行作业
    if task.due_date and task.status == TaskStatus.PENDING:
        execution_job_id = f"execution_{task.id}"
        try:
            due_utc = _ensure_utc(task.due_date) # <--- [新增] 确保时间是 UTC 感知的
            print(f"SCHEDULER DEBUG: Adding execution job at {due_utc} ({due_utc.tzinfo})") # <--- [新增] 添加时区日志
            current_scheduler.add_job(
                execute_task_action,
                trigger=DateTrigger(run_date=due_utc),
                args=[task.id, task.action_type, task.action_payload],
                id=execution_job_id,
                name=f"Execution for task {task.title[:20]}",
                replace_existing=True
            )
            print(f"SCHEDULER: 已为任务 '{task.id}' 添加/更新执行作业，运行于 {task.due_date}")
        except Exception as e:
            print(f"SCHEDULER_ERROR: 添加执行作业失败 for task '{task.id}': {e}")

def _cancel_task_jobs(task_id: str):
    """从 APScheduler 取消作业"""
    current_scheduler = get_scheduler()
    if not current_scheduler or not current_scheduler.running:
        print("SCHEDULER_ERROR: APScheduler 未运行，无法取消作业。")
        return

    reminder_job_id = f"reminder_{task_id}"
    execution_job_id = f"execution_{task_id}"

    try:
        current_scheduler.remove_job(reminder_job_id)
        print(f"SCHEDULER: 已移除提醒作业 for task '{task_id}'")
    except JobLookupError:
        print(f"SCHEDULER_INFO: 提醒作业 '{reminder_job_id}' 未找到，无需移除。")
    except Exception as e:
        print(f"SCHEDULER_ERROR: 移除提醒作业失败 for task '{task_id}': {e}")

    try:
        current_scheduler.remove_job(execution_job_id)
        print(f"SCHEDULER: 已移除执行作业 for task '{task_id}'")
    except JobLookupError:
        print(f"SCHEDULER_INFO: 执行作业 '{execution_job_id}' 未找到，无需移除。")
    except Exception as e:
        print(f"SCHEDULER_ERROR: 移除执行作业失败 for task '{task_id}': {e}")

@router.post("/", response_model=TaskModel, status_code=status.HTTP_201_CREATED)
async def create_task(task_request: CreateTaskRequest = Body(...)):
    """
    创建一个新任务。
    """
    now = datetime.utcnow()
    task_id = str(uuid.uuid4())

    reminder_time_val = None
    if task_request.due_date and task_request.reminder_offset_minutes is not None:
        reminder_time_val = task_request.due_date - timedelta(minutes=task_request.reminder_offset_minutes)

    reminder_methods_values = [
        method.value if hasattr(method, 'value') else str(method)
        for method in (task_request.reminder_methods or [ReminderMethod.NOTIFICATION])
    ]

    insert_query = TaskDB.__table__.insert().values(
        id=task_id,
        title=task_request.title,
        description=task_request.description,
        status=TaskStatus.PENDING,
        created_at=now,
        updated_at=now,
        due_date=task_request.due_date,
        reminder_time=reminder_time_val,
        reminder_offset_minutes=task_request.reminder_offset_minutes,
        reminder_methods=reminder_methods_values, # <--- 确保存入的是字符串列表
        priority=task_request.priority or 0,
        tags=task_request.tags or [],
        action_type=task_request.action_type,
        action_payload=task_request.action_payload or {}
    )

    try:
        await database.execute(insert_query)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to create task in database: {e}")

    created_task_db = await database.fetch_one(TaskDB.__table__.select().where(TaskDB.id == task_id))
    if not created_task_db:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to retrieve task after creation")

    response_task = TaskModel.model_validate(dict(created_task_db))

    response_task.reminder_methods = [
        m.value if hasattr(m, 'value') else str(m)
        for m in response_task.reminder_methods
    ]

    _schedule_task_jobs(response_task)
    print(f"TASK_MANAGER: Created task '{response_task.id}' with title '{response_task.title}' in DB")
    return response_task

@router.get("/", response_model=List[TaskModel])
async def list_tasks(
    status_filter: Optional[TaskStatus] = Query(None, alias="status"),
    priority_filter: Optional[int] = Query(None, alias="priority"),
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100)
):
    """
    获取任务列表，支持过滤和分页。
    """
    query = TaskDB.__table__.select()
    if status_filter:
        query = query.where(TaskDB.status == status_filter)
    if priority_filter is not None:
        query = query.where(TaskDB.priority == priority_filter)

    query = query.order_by(TaskDB.created_at.desc()).offset(skip).limit(limit)

    db_tasks = await database.fetch_all(query)
    return [TaskModel.model_validate(dict(task)) for task in db_tasks]

@router.get("/{task_id}", response_model=TaskModel)
async def get_task(task_id: str = Path(..., description="要获取的任务ID")):
    """
    根据ID获取单个任务的详细信息。
    """
    query = TaskDB.__table__.select().where(TaskDB.id == task_id)
    db_task = await database.fetch_one(query)
    if not db_task:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")
    return TaskModel.model_validate(dict(db_task))

@router.put("/{task_id}", response_model=TaskModel)
async def update_task(
    task_id: str = Path(..., description="要更新的任务ID"),
    task_update: UpdateTaskRequest = Body(...)
):
    """
    更新现有任务。
    """
    existing_task_query = TaskDB.__table__.select().where(TaskDB.id == task_id)
    db_task = await database.fetch_one(existing_task_query)
    if not db_task:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")

    update_data = task_update.model_dump(exclude_unset=True)
    update_data["updated_at"] = datetime.utcnow()

    if "reminder_methods" in update_data and update_data["reminder_methods"] is not None:
        update_data["reminder_methods"] = [
            method.value if hasattr(method, 'value') else str(method)
            for method in update_data["reminder_methods"]
        ]

    current_due_date = update_data.get("due_date", cast(Optional[datetime], db_task.due_date))
    current_offset = update_data.get("reminder_offset_minutes", cast(Optional[int], db_task.reminder_offset_minutes))

    if current_due_date and current_offset is not None:
        update_data["reminder_time"] = current_due_date - timedelta(minutes=current_offset)
    elif "due_date" in update_data and current_offset is None:
         update_data["reminder_time"] = None


    update_query = TaskDB.__table__.update().where(TaskDB.id == task_id).values(**update_data)
    await database.execute(update_query)

    updated_db_task = await database.fetch_one(existing_task_query)
    if not updated_db_task:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to retrieve task after update")

    response_task = TaskModel.model_validate(dict(updated_db_task))

    response_task.reminder_methods = [
        m.value if hasattr(m, 'value') else str(m)
        for m in response_task.reminder_methods
    ]

    _cancel_task_jobs(task_id)
    _schedule_task_jobs(response_task)
    print(f"TASK_MANAGER: Updated task '{response_task.id}' in DB")
    return response_task

@router.delete("/{task_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_task(task_id: str = Path(..., description="要删除的任务ID")):
    """
    删除一个任务。
    """
    existing_task_query = TaskDB.__table__.select().where(TaskDB.id == task_id)
    db_task = await database.fetch_one(existing_task_query)
    if not db_task:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")

    delete_query = TaskDB.__table__.delete().where(TaskDB.id == task_id)
    await database.execute(delete_query)

    _cancel_task_jobs(task_id)
    print(f"TASK_MANAGER: Deleted task '{task_id}' from DB")
    return None

@router.post("/{task_id}/complete", response_model=TaskModel)
async def mark_task_as_complete(task_id: str = Path(..., description="要标记为完成的任务ID")):
    """
    将任务标记为已完成。
    """
    existing_task_query = TaskDB.__table__.select().where(TaskDB.id == task_id)
    db_task_row = await database.fetch_one(existing_task_query)
    if not db_task_row:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")

    db_task = TaskModel.model_validate(dict(db_task_row))
    if db_task.status == TaskStatus.COMPLETED:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Task is already completed")

    update_data = {
        "status": TaskStatus.COMPLETED,
        "updated_at": datetime.utcnow()
    }
    update_query = TaskDB.__table__.update().where(TaskDB.id == task_id).values(**update_data)
    await database.execute(update_query)

    completed_db_task = await database.fetch_one(existing_task_query)
    if not completed_db_task:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to retrieve task after marking complete")

    response_task = TaskModel.model_validate(dict(completed_db_task))
    _cancel_task_jobs(task_id)
    print(f"TASK_MANAGER: Marked task '{response_task.id}' as completed in DB")
    return response_task
```


==================================================

