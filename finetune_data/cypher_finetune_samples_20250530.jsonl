{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "Replace ':Person' with ':ExtractedEntity' for both nodes. The corrected query should be: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`", "original_qwen_cypher": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "gemini_score": 2, "source_of_ideal": "gemini_suggestion", "interaction_id": "8ba6978c-630d-494e-bcc3-c2c98dac0bee"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三目前的工作地点是哪里？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "original_qwen_cypher": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS workLocation", "gemini_score": 2, "source_of_ideal": "gemini_suggestion", "interaction_id": "c5adbb87-83ca-4590-a5aa-eb654b9ed649"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三的公司名称是什么？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "无法生成Cypher查询。", "original_qwen_cypher": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "gemini_score": 2, "source_of_ideal": "gemini_cannot_generate", "interaction_id": "3ec85f51-fdc6-4307-aaa6-c533250b2cfc"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 张三在哪里工作？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "Replace ':Person' with ':ExtractedEntity' for the 'p' node. The corrected query is: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`", "original_qwen_cypher": "MATCH (p:Person {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName", "gemini_score": 2, "source_of_ideal": "gemini_suggestion", "interaction_id": "9c3e2cea-a354-4d13-89a7-9495d8fa75e1"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "original_qwen_cypher": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "223a5abc-57bf-4da8-bb1c-125f7ca59588"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配的员工有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "original_qwen_cypher": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "9f7f0c24-250f-4d9e-930c-1ce9c411e94e"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 项目Alpha的文档编写任务分配给了谁？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "original_qwen_cypher": "MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "401c1fd3-e5ae-4258-abcc-8a3589afb463"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "original_qwen_cypher": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "6a87b53e-892a-4322-a198-db1e9be5dc8e"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四目前负责的具体工作任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "original_qwen_cypher": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:Task) RETURN task.text AS taskName", "gemini_score": 1, "source_of_ideal": "gemini_suggestion", "interaction_id": "f06dc75d-ea05-43ad-b0a8-a008013ab304"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四在过去一年内完成的任务有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "无法生成Cypher查询。", "original_qwen_cypher": "MATCH (l4:Person {text: '李四', label: 'PERSON'})-[:COMPLETED_IN]->(task:Task) RETURN task.text AS taskName", "gemini_score": 1, "source_of_ideal": "gemini_cannot_generate", "interaction_id": "85a41f2b-9213-4d35-ba1f-90f597cc7484"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 李四负责哪些任务？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "original_qwen_cypher": "MATCH (l4:ExtractedEntity {text: '李四', label: 'PERSON'})-[:ASSIGNED_TO]->(task:ExtractedEntity {label: 'TASK'}) RETURN task.text AS taskName", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "a2e16ef8-a12e-4a79-8231-d1ebe2d28d1f"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(d:ExtractedEntity {label: 'ORGANIZATION'}) WHERE d.text CONTAINS '市场部' RETURN e.text AS employeeName", "original_qwen_cypher": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "gemini_score": 2, "source_of_ideal": "gemini_suggestion", "interaction_id": "da8a3d2b-4aac-482c-b36a-ae2c8cc0a04e"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部员工的详细名单是什么？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "无法生成Cypher查询。", "original_qwen_cypher": "MATCH (m:Person {label: 'PERSON'})-[:WORKS_AT]->(d:ExtractedEntity {label: 'DEPARTMENT'}) WHERE d.text = '市场部' RETURN m.text AS employeeName", "gemini_score": 2, "source_of_ideal": "gemini_cannot_generate", "interaction_id": "5e4409ca-4064-42dc-8d2a-e04519379939"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 市场部有哪些员工？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (e:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(m:ExtractedEntity {label: 'ORGANIZATION'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "original_qwen_cypher": "MATCH (m:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(e:ExtractedEntity {label: 'PERSON'}) WHERE m.text CONTAINS '市场部' RETURN e.text AS employeeName", "gemini_score": 2, "source_of_ideal": "gemini_suggestion", "interaction_id": "a1446e88-fb18-47a5-9c40-34568aaf7732"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "To correctly capture the 'and' condition, use a single MATCH clause with two relationship patterns connected to the same 'w5' node:\n\n```cypher\nMATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result\n```", "original_qwen_cypher": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "gemini_score": 3, "source_of_ideal": "gemini_suggestion", "interaction_id": "568dca86-1dbf-4171-8339-0de9e3d063af"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五是否负责了项目B？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "original_qwen_cypher": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:ASSIGNED_TO]->(proj:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "gemini_score": 5, "source_of_ideal": "qwen_high_score", "interaction_id": "11a1a0df-14e9-4848-9818-6ae3a1ec33e3"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 王五既在A公司工作，又负责了项目B吗？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "Use a single MATCH clause with multiple patterns connected by a common node.  For example:\n```cypher\nMATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN count(w5) > 0 AS result\n```\nThis ensures both conditions must be met for a true result.  Using `count(w5) > 0` is more efficient than `w5.text IS NOT NULL`.", "original_qwen_cypher": "MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(proj_b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result", "gemini_score": 3, "source_of_ideal": "gemini_suggestion", "interaction_id": "1b748526-4f92-4586-82fa-de67aa32aed5"}
{"prompt": "<|im_start|>system\n你是顶级Neo4j Cypher查询生成专家。你的任务是根据用户问题和严格提供的【知识图谱Schema】，生成一个【语法正确】、【逻辑合理】且【高效】的Cypher查询。\n\n**【核心指令与约束 - 必须严格遵守！】**\n\n1.  **【Schema绝对绑定 - 最高优先级】**:\n    *   你生成的Cypher查询中所有用到的【节点标签】、【关系类型】、【属性名称】及其对应的【数据类型】，都**必须严格存在于**下面提供的 \"知识图谱Schema描述\" 中。\n    *   在构建查询的每一步，都要反复与Schema核对。**严禁臆断、猜测或使用任何Schema中未明确定义的元素。**\n    *   **属性名称的大小写和确切拼写必须与Schema完全一致。**\n    *   **关系类型的名称和方向必须与Schema完全一致。** 例如，如果Schema定义为 `(Person)-[:WORKS_ON]->(Project)`，则查询中不能是 `(Project)-[:WORKS_ON]->(Person)`，除非Schema中也定义了反向关系。\n\n2.  **【纯净输出格式 - 严格要求】**:\n    *   如果能生成有效查询，你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   如果根据问题和Schema无法生成有效的Cypher查询（例如，问题超出了Schema表达能力，或问题本身逻辑不通），则**必须只输出固定的短语：“无法生成Cypher查询。”**\n    *   **绝对禁止**在有效的Cypher语句前后添加任何前缀（如“Cypher查询: ”）、后缀、解释、注释、markdown标记（如 ```cypher ```）或任何其他多余的文本。\n\n3.  **【属性与值的使用】**:\n    *   当在`WHERE`子句中对属性进行匹配时，确保值的类型与Schema中定义的属性类型一致。例如，如果`name`是字符串，则匹配 `name: '张三'`；如果`year`是数字，则匹配 `year: 2023`。\n    *   对于数值计算（如`SUM`, `AVG`），**必须**使用Schema中明确指定的数字类型属性（例如，`SalesAmount`节点的 `numeric_amount`）。\n\n4.  **【查询构建逻辑指引】**:\n    *   **实体识别**: 准确识别用户问题中的核心实体及其在Schema中对应的节点标签和属性。\n    *   **关系路径**: 基于问题和Schema构建清晰的`MATCH`路径。\n    *   **条件过滤**: 使用`WHERE`子句添加必要的过滤条件。\n    *   **结果返回**: 使用`RETURN`子句指定需要返回的信息，并用`AS`为返回的列指定清晰、合法的别名（字母或下划线开头）。\n    *   **多步查询**: 对于需要关联多个信息点的问题，合理使用`WITH`传递中间结果。\n    *   **聚合**: 如需统计或汇总，正确使用`COUNT()`, `SUM()`, `COLLECT()`等聚合函数。\n\n**【知识图谱Schema描述】**:\n\n你是一位顶级的Neo4j Cypher查询生成专家。你的唯一且最重要的使命是：严格、精确、无任何偏差地遵循下方【知识图谱Schema核心规则】，根据用户的问题生成Cypher查询。\n\n🛑 **最高指令：Schema规则高于一切！任何违反Schema的查询都将被视为完全失败！未能遵循将导致任务失败。你的首要任务是判断问题是否能在当前Schema下回答，如果不能，必须明确放弃。** 🛑\n\n**【Schema核心规则 - 你必须逐字逐句阅读、理解并严格执行！任何细微偏差都不可接受！】**\n\n**第一条铁律：节点标签的唯一强制规范 (这是最最最重要的规则!)**\n    1.1. **统一标签**: 在任何 `MATCH` 子句中，所有节点匹配时，**你必须、一定、且只能使用 `:ExtractedEntity` 这个唯一的节点标签**。\n    1.2. **【绝对禁止使用任何其他节点标签】**: 例如 `:Person`, `:Organization`, `:Task`, `:Project`, `:Company`, `:Department`, `User`, `Document`, `:SalesAmount`, `:Budget` 等所有这些具体的、非 `:ExtractedEntity` 的标签都是 **绝对错误且严禁使用的**！如果你生成了包含这些禁用标签的查询，那么这个查询就是 **完全错误** 的。\n    1.3. **实体类型的正确表示**: 节点的具体类型（例如人、组织、任务）**必须通过其 `label` 属性（全小写）进行筛选，并且该属性的值必须是英文大写字符串**。\n        *   **【正确示例 - 必须遵循此格式!】**:\n            `MATCH (n:ExtractedEntity {label: 'PERSON', text: '张三'}) ...`\n            `MATCH (org_node:ExtractedEntity {label: 'ORGANIZATION'}) WHERE org_node.text CONTAINS '科技' ...`\n            `MATCH (any_task:ExtractedEntity {label: 'TASK'}) ...`\n        *   **【错误示例 - 严禁生成此类查询! 后果严重!】**:\n            `MATCH (p:Person {text: '张三'}) ...` (错误！使用了禁用标签 `:Person`)\n            `MATCH (n:ExtractedEntity {type: 'PERSON'}) ...` (错误！应该使用 `label` 属性，而不是 `type`)\n            `MATCH (n:ExtractedEntity {Label: 'PERSON'}) ...` (错误！属性 `label` 必须小写)\n            `MATCH (n:ExtractedEntity {label: 'person'}) ...` (错误！`label` 的值必须大写)\n            `MATCH (o:ORGANIZATION {text: '谷歌'}) ...` (错误！使用了禁用标签 `:ORGANIZATION`)\n\n**第二条铁律：节点属性的严格白名单 (有且仅有以下两个，不多不少！)**\n    2.1. 每个 `:ExtractedEntity` 节点 **只允许拥有且只允许使用** 以下两个属性。\n    2.2. **【绝对禁止】虚构或使用任何其他属性名**: 例如 `name`, `id`, `deadline`, `period`, `amount`, `unit`, `age`, `budget`, `status`, `content`, `description`, `title`, `projectName`, `organizationName`, `workLocation`, `mainTaskName`, `completionPeriod`, `assignerName`, `teamMemberName`, `followUpStatus`, `followUpType`, `ownerName`, `totalBudget` 等所有不在下方白名单中的属性都是 **绝对错误且严禁使用的**。\n        *   `text`: 字符串 (String)，表示该实体的文本内容、名称或唯一标识。\n        *   `label`: 字符串 (String) (全小写)，表示该实体的类型。\n            *   **【已定义的 `label` 值 - 只能用这些!】**: \"PERSON\", \"ORGANIZATION\", \"TASK\"。\n\n**第三条铁律：关系类型的严格白名单与方向 (有且仅有以下两种，不多不少！)**\n    3.1. 目前 **只允许使用且只允许使用** 以下两种关系类型。它们严格连接特定 `label` 的 `:ExtractedEntity` 节点。\n    3.2. **【绝对禁止】虚构或使用任何其他关系类型或错误的关系方向**: 例如 `:RESPONSIBLE_FOR`, `:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:BELONGS_TO`, `:FOLLOWS_UP`, `:COMPLETED_IN` 等所有不在下方白名单中的关系都是 **绝对错误且严禁使用的**。\n        *   **关系名称: `:WORKS_AT`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"PERSON\"}) -[:WORKS_AT]-> (:ExtractedEntity {label:\"ORGANIZATION\"})`\n            *   **描述**: 表示一个 \"PERSON\" 实体在一个 \"ORGANIZATION\" 实体工作。\n        *   **关系名称: `:ASSIGNED_TO`**\n            *   **【严格方向和节点类型 - 必须如此!】**: `(:ExtractedEntity {label:\"TASK\"}) -[:ASSIGNED_TO]-> (:ExtractedEntity {label:\"PERSON\"})`\n            *   **描述**: 表示一个 \"TASK\" 实体分配给了一个 \"PERSON\" 实体。\n\n**【Cypher查询生成通用指令与约束】**\n\n1.  **【Schema的绝对权威性 - 生成前必须进行自我检查清单！】**:\n    *   你生成的Cypher查询的每一个部分都**必须严格且完全基于**上述【Schema核心规则】。\n    *   **在输出任何Cypher查询之前，你必须在内部进行以下自我检查。如果任何一项检查不通过，你都必须放弃生成该Cypher，并只输出“无法生成Cypher查询。”**：\n        1.  **节点标签检查**: 查询中的所有节点是否都严格使用了 `:ExtractedEntity` 标签？ (是/否)\n        2.  **实体类型表示检查**: 节点的具体类型是否都通过 `label` (小写) 属性和正确的大写值 (如 'PERSON', 'ORGANIZATION', 'TASK') 进行筛选？ (是/否)\n        3.  **节点属性白名单检查**: 查询中是否只使用了 `:ExtractedEntity` 节点允许的 `text` 和 `label` 这两个属性？没有使用任何其他属性名？ (是/否)\n        4.  **关系白名单与方向检查**: 查询中使用的关系类型和方向是否严格从定义的 `:WORKS_AT` 和 `:ASSIGNED_TO` 中选择，并且连接的节点类型符合规定？ (是/否)\n        5.  **无幻觉检查**: 查询中是否包含了任何在上述【Schema核心规则】中未明确定义的标签、属性或关系？ (是/否 - “是”表示无幻觉，“否”表示有幻觉，则不应生成)\n    *   **只有当以上检查1-4为“是”，检查5为“是”（即无幻觉）时，你才能输出该Cypher查询。否则，你必须输出“无法生成Cypher查询。”**\n\n2.  **【处理用户问题的约束条件】**:\n    *   仔细分析用户问题中的所有实体、关系和约束条件。确保所有这些条件都在Cypher查询的 `WHERE` 子句或模式匹配中得到准确体现，并且严格使用Schema中定义的元素。\n    *   **【处理“并且”逻辑的多重独立条件 - 关键模式！】**: 如果一个问题包含多个独立的条件（例如“某人A在机构B工作 **并且** 某人A负责任务C”），这通常意味着需要在 `MATCH` 子句中定义多个独立的模式路径，并通过公共的节点变量（如代表“某人A”的变量 `person_variable`）将它们关联起来。\n        *   **正确示例 (王五既在A公司工作，又负责了项目B吗？)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n            *(解释：这里通过共享变量 `w5` 连接了两个独立的MATCH模式，正确表达了“并且”的逻辑。)*\n        *   **错误示例 (严禁此类无效的链式连接!)**:\n            `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a_company:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n            *(错误原因：`:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点，这种链式连接在逻辑上也不符合“并且”的含义，是完全错误的。)*\n\n3.  **【输出格式的严格要求】**:\n    *   **如果能生成有效且完全遵循Schema的查询**：你的回答**必须只包含纯粹的Cypher查询语句本身**。\n    *   **如果无法生成有效查询（因为问题超出了上述严格Schema的表达能力）**：则**必须只输出固定短语：“无法生成Cypher查询。”**\n        *   **何时必须输出“无法生成Cypher查询。” (强制规则！)**:\n            *   当问题询问Schema中**未定义**的实体类型时 (例如：“会议室”、“部门”、“预算金额”、“项目”等，除非它们能被明确映射为现有\"PERSON\", \"ORGANIZATION\", \"TASK\"的 `text` 内容，并且问题本身不依赖于这个虚构的类型进行关系连接)。\n            *   当问题涉及Schema中**未定义**的节点属性时 (例如：任务的“截止日期”、“状态”、“优先级”，个人的“年龄”、“职位”、“薪水”，组织的“成立日期”、“业绩”、“规模”等)。\n            *   当问题涉及Schema中**未定义**的关系类型时 (例如：“同事关系”、“朋友关系”，“项目依赖”，“管理关系”，`:HAS_BUDGET`, `:HAS_DEADLINE`, `:HAS_PROGRESS`, `:HAS_STATUS`, `:BELONGS_TO`, `:WORKS_ON`, `:HAS_EMPLOYEE`, `:COMPLETED_IN` 等)。\n            *   当问题的核心意图无法通过已定义的Schema元素和上述规则精确满足时。**如果信息不在Schema定义的范围内，就直接判断为“无法生成Cypher查询。” 你的任务不是去猜测或创造不存在的Schema。**\n\n**【高质量Cypher查询示例 - 严格遵循所有规则】**\n*   用户问题: \"张三在哪里工作？\"\n    Cypher查询: MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName\n\n*   用户问题: \"项目Alpha的文档编写任务分配给了谁？\"\n    Cypher查询: MATCH (task:ExtractedEntity {text: '项目Alpha的文档编写任务', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS personName\n\n*   用户问题: \"列出所有在创新科技公司工作的员工。\"\n    Cypher查询: MATCH (p:ExtractedEntity {label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {text: '创新科技公司', label: 'ORGANIZATION'}) RETURN p.text AS employeeName\n\n*   用户问题: \"李四负责了哪些任务？\"\n    Cypher查询: MATCH (task:ExtractedEntity {label: 'TASK'})-[:ASSIGNED_TO]->(p:ExtractedEntity {text: '李四', label: 'PERSON'}) RETURN task.text AS taskName\n\n**【常见错误Cypher查询示例以及为何错误 (你绝对不应该生成这些！必须避免！)】**\n\n*   用户问题: \"张三在哪里工作？\"\n    *   **错误Cypher**: `MATCH (p:Person {name: '张三'})-[:WORKS_AT]->(org:Organization) RETURN org.text`\n    *   **为何错误**: 严重违反【第一条铁律】和【第二条铁律】！1. 使用了禁用标签 `:Person` 和 `:Organization`。 2. 可能错误使用了 `name` 属性。\n    *   **正确写法**: `MATCH (p:ExtractedEntity {text: '张三', label: 'PERSON'})-[:WORKS_AT]->(org:ExtractedEntity {label: 'ORGANIZATION'}) RETURN org.text AS organizationName`\n\n*   用户问题: \"项目X由谁负责？\" (假设“项目X”被视为一个“任务”)\n    *   **错误Cypher**: `MATCH (proj:Project {projectName: '项目X'})<-[:IS_RESPONSIBLE_FOR]-(p:Manager) RETURN p.managerName`\n    *   **为何错误**: 严重违反【第一条铁律】、【第二条铁律】和【第三条铁律】！1. 使用了未定义标签 `:Project`, `:Manager`。 2. 使用了未定义属性 `projectName`, `managerName`。 3. 使用了未定义关系 `:IS_RESPONSIBLE_FOR`。\n    *   **基于当前Schema的正确方向**: `MATCH (task:ExtractedEntity {text: '项目X', label: 'TASK'})-[:ASSIGNED_TO]->(person:ExtractedEntity {label: 'PERSON'}) RETURN person.text AS responsiblePerson`\n\n*   用户问题: \"所有任务的截止日期是什么时候？\"\n    *   **错误Cypher**: `MATCH (t:ExtractedEntity {label: 'TASK'}) RETURN t.deadline`\n    *   **为何错误**: 严重违反【第二条铁律】！Schema中 `:ExtractedEntity` 节点只有 `text` 和 `label` 属性，`deadline` 是虚构的属性，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"项目Alpha的预算有多少？\"\n    *   **错误Cypher**: `MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'}) RETURN bud.amount`\n    *   **为何错误**: 严重违反【第三条铁律】和【第二条铁律】！关系 `:HAS_BUDGET` 和 `label: 'BUDGET_INFO'` 以及属性 `amount` 都是虚构的，Schema中未定义。\n    *   **基于当前Schema的正确响应**: `无法生成Cypher查询。`\n\n*   用户问题: \"王五既在A公司工作，又负责了项目B吗？\" (假设项目B是一个任务)\n    *   **错误Cypher**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(a:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'})-[:ASSIGNED_TO]->(b:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text`\n    *   **为何错误**: 严重违反【第三条铁律】和【处理“并且”逻辑的多重独立条件】中的错误示例！关系 `:ASSIGNED_TO` 不能从 `ORGANIZATION` 类型的节点发出并指向 `TASK` 类型的节点。\n    *   **基于当前Schema的正确思路**: `MATCH (w5:ExtractedEntity {text: '王五', label: 'PERSON'})-[:WORKS_AT]->(:ExtractedEntity {text: 'A公司', label: 'ORGANIZATION'}), (w5)-[:ASSIGNED_TO]->(:ExtractedEntity {text: '项目B', label: 'TASK'}) RETURN w5.text IS NOT NULL AS result`\n\n现在，请根据以下用户问题和上述所有规则及Schema生成Cypher查询。记住，严格遵循Schema是你最重要的任务！\n\n\n**【查询示例 - 严格基于上述Schema】**:\n\n*   用户问题: \"张三参与了哪个项目？\"\n    Cypher查询: MATCH (p:Person {name: '张三'})-[:WORKS_ON]->(proj:Project) RETURN proj.name AS projectName\n\n*   用户问题: \"华东区域2024年第一季度的销售额是多少？\"\n    Cypher查询: MATCH (r:Region {name: '华东'})-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sa.numeric_amount AS salesAmount, sa.unit AS salesUnit\n\n*   用户问题: \"查询所有产品的名称。\"\n    Cypher查询: MATCH (prod:Product) RETURN prod.name AS productName\n\n*   用户问题: \"项目X有哪些人参与？\"\n    Cypher查询: MATCH (p:Person)-[:WORKS_ON]->(proj:Project {name: '项目X'}) RETURN p.name AS participantName\n\n*   用户问题: \"2024年第一季度所有区域的总销售额是多少？\"\n    Cypher查询: MATCH (r:Region)-[:HAS_SALES_AMOUNT]->(sa:SalesAmount {period: '2024年第一季度'}) RETURN sum(sa.numeric_amount) AS totalSales, sa.unit AS commonUnit LIMIT 1 \n    (此查询假设所有相关销售额的单位是相同的，并取第一个出现的单位作为代表)\n\n*   用户问题: \"与新产品A相关的文档ID是什么？\"\n    Cypher查询: MATCH (p:Product {name: '新产品A'})-[:RELATED_TO]->(d:Document) RETURN d.id AS documentId\n\n*   用户问题: \"公司CEO是谁？\" (假设Schema中没有CEO信息)\n    Cypher查询: 无法生成Cypher查询。\n\n现在，请根据以下用户问题和上述Schema及规则生成Cypher查询。\n<|im_end|>\n<|im_start|>user\n用户问题: 与项目Alpha相关的预算调整记录有哪些？\n<|im_end|>\n<|im_start|>assistant\n", "completion": "无法生成Cypher查询。", "original_qwen_cypher": "MATCH (proj:ExtractedEntity {text: '项目Alpha', label: 'TASK'})-[:HAS_BUDGET]->(bud:ExtractedEntity {label: 'BUDGET_INFO'})-[:HAS_ADJUSTMENT]->(adj:ExtractedEntity {label: 'ADJUSTMENT_RECORD'}) RETURN adj.text AS adjustmentRecord", "gemini_score": 1, "source_of_ideal": "gemini_cannot_generate", "interaction_id": "884206b3-908b-455a-a65c-81eddf4b11a3"}
